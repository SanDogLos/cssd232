// inject.js — Расширенный UI  для the-prison.ru
// Автор: shelt-magic

  (function () {
    'use strict';


    /** Global Variables **/
    let currentUserId = null;
    let selectedPlayers = [];
    let currentPlayers = [];
    let abortUpgrade = false;
    window.friendsList = [];
    let currentTalentsConfig = [];
    let talentFilteredPlayers = [];
    let activeInput = null;
    let playerCollections = {};
    let totalFoundHideouts = 0;
    let currentPrisonData = null;
    let highestZIndex = 10010;
    let reloginCooldownUntil = 0;
    let activeBossAttacks = 0;
    let activeModal = null;
    let lastSuccessfulReloginTime = 0;
    let friendsCache = null;
    let friendsCacheTimer = null;
    let latestPlayerData = null;

    window.talentsCache = window.talentsCache || {};

    if (window.Telegram?.WebApp?.initData) {
      localStorage.setItem('initData', window.Telegram.WebApp.initData);
      console.log('%cinitData автоматически сохранён из Telegram WebApp', 'color:#10b981;background:#166534;padding:8px;border-radius:8px;');
    }

    let reloginInProgress = null;
    let login429Until = 0;

    /** SilentRelogin **/
    async function silentRelogin(force = false) {

      if (reloginInProgress) {
        console.log('%cПовторный вызов silentRelogin — ждём уже запущенный', 'color:#fb923c;background:#451a03;padding:10px 20px;border-radius:12px;font-weight:bold;');
        return await reloginInProgress;
      }

      if (Date.now() < login429Until) {
        console.log('%cРелогин заблокирован из-за 429 на /auth/login — ждём', 'color:white;background:#7f1d1d;padding:10px 20px;border-radius:12px;font-weight:bold;');
        return false;
      }

      reloginInProgress = (async () => {
        try {
          let initData = localStorage.getItem('initData') ||
            localStorage.getItem('tgWebAppInitData') ||
            localStorage.getItem('webAppInitData') ||
            localStorage.getItem('webAppData');

          if (!initData || force) {
            if (window.Telegram?.WebApp?.initData) {
              initData = window.Telegram.WebApp.initData;
              localStorage.setItem('initData', initData);
              console.log('%cСвежий initData получен прямо из Telegram.WebApp!', 'color:#10b981;background:#166534;padding:8px;border-radius:8px;font-weight:bold;');
            }
          }

          if (!initData) {
            const hash = location.hash.slice(1);
            const search = location.search.slice(1);
            const params = new URLSearchParams(hash + '&' + search);
            initData = params.get('tgWebAppData') || params.get('initData');
            if (initData) localStorage.setItem('initData', initData);
          }

          if (!initData) {
            console.warn('silentRelogin: initData совсем нет — нужен хотя бы один вход через Telegram');
            return false;
          }

          const res = await originalFetch('https://oldprison-prod.luckygem.online/api/auth/login', {
            method: 'POST',
            credentials: 'include',
            headers: {
              'Content-Type': 'application/json',
              'Accept': 'application/json',
            },
            body: JSON.stringify({ initData })
          });

          const data = await res.json();

          if (data.success && data.accessToken) {
            localStorage.setItem('accessToken', data.accessToken);
            if (data.refreshToken) localStorage.setItem('refreshToken', data.refreshToken);
            console.log('%cМолчаливый релогин УСПЕШЕН! Токен обновлён', 'color:white;background:#166534;padding:10px;font-size:16px;font-weight:bold;border-radius:12px;');
            lastSuccessfulReloginTime = Date.now();
            return true;
          } else {
            if (data.message?.includes('Invalid initData') || data.message?.includes('invalid')) {
              ['initData', 'tgWebAppInitData', 'webAppInitData', 'webAppData'].forEach(k => localStorage.removeItem(k));
              console.warn('Старый initData удалён — зайди в игру через Telegram один раз!');
            }
            console.warn('silentRelogin провалился:', data);
            return false;
          }
        } catch (e) {
          console.warn('silentRelogin упал с ошибкой:', e);
          return false;
        } finally {
          setTimeout(() => { reloginInProgress = null; }, 800); // чуть меньше секунды — достаточно
        }
      })();

      return await reloginInProgress;
    }

    /** Получение ID/Token **/
    function getAuthToken() {
      try {
        const token = localStorage.getItem('accessToken');
        return token ? (token.startsWith('Bearer ') ? token : `Bearer ${token}`) : null;
      } catch (e) {
        return null;
      }
    }

    async function forceReloginBeforeAttack() {
      console.log('%cПеред стартом атаки — принудительный релогин', 'color:#fbbf24;background:#451a03;padding:8px 16px;border-radius:12px;font-weight:bold;');

      // Удаляем старый токен, чтобы точно получить новый
      localStorage.removeItem('accessToken');
      localStorage.removeItem('refreshToken');

      const success = await silentRelogin(true); // true = force
      if (!success) {
        showError('Релогин провалился', 'Не удалось получить новый токен перед атакой');
        return false;
      }
      return true;
    }

    function getCurrentUserId() {
      try {
        const token = localStorage.getItem('accessToken');
        if (!token) return null;
        const payload = JSON.parse(atob(token.split('.')[1]));
        return payload.userId;
      } catch (e) {
        return null;
      }
    }

    /** Fake Init **/
    // setInterval(async () => {
    //   try {
    //     if (Date.now() - lastSuccessfulReloginTime < 30000) {
    //       console.log(
    //         '%cПульс сессии пропущен — недавно был релогин (менее 30 сек)',
    //         'color:#fbbf24;background:#451a03;padding:6px 14px;border-radius:12px;font-size:11px;'
    //       );
    //       return;  // Выходим, не делаем запрос
    //     }
    //     const start = Date.now();
    //     const res = await fetch('https://oldprison-prod.luckygem.online/api/player/init', {
    //       method: 'POST',
    //       credentials: 'include',
    //       keepalive: true,
    //       headers: {
    //         'authorization': getAuthToken() || '',
    //         'content-type': 'application/json',
    //         'accept': 'application/json'
    //       },
    //       body: '{}'
    //     });
    //
    //     const duration = Date.now() - start;
    //
    //     if (res.ok || res.status === 403) {
    //       console.log(
    //         `%cПульс сессии ✓%c ${duration}мс`,
    //         'color:#10b981;background:#166534;padding:6px 14px;border-radius:12px;font-weight:bold;font-size:11px;',
    //         'color:#94a3b8;font-size:11px;'
    //       );
    //     } else {
    //       console.log(
    //         `%cПульс сессии — статус ${res.status}`,
    //         'color:#fb923c;background:#451a03;padding:6px 14px;border-radius:12px;font-weight:bold;font-size:11px;'
    //       );
    //     }
    //   } catch (e) {
    //     console.log(
    //       '%cПульс сессии — сеть недоступна',
    //       'color:#64748b;background:#1e293b;padding:6px 14px;border-radius:12px;font-size:11px;'
    //     );
    //   }
    // }, 2 * 60 * 1000 + Math.floor(Math.random() * 5 * 60 * 1000));

    /** FETCH **/
    const { fetch: originalFetch } = window;
    window._429clearTimer && clearTimeout(window._429clearTimer);
    window.fetch = async (input, init) => {
      const response = await originalFetch(input, init);

      // ─────── ЛОВИМ 429 ВЕЗДЕ ───────
      if (response.status === 429) {
        const retryAfter = parseInt(response.headers.get('Retry-After') || '300', 10);
        const waitMs = retryAfter * 1000 + 10000; // +10 сек запаса
        const newCooldownEnd = Date.now() + waitMs;

        const wasCooldown = reloginCooldownUntil;
        reloginCooldownUntil = Math.max(reloginCooldownUntil, newCooldownEnd);

        console.log(`%c429 Too Many Requests → ждём ${retryAfter} сек (~${Math.round(retryAfter/60)} мин) до ${new Date(newCooldownEnd).toLocaleTimeString()}`,
          'color:white;background:#7f1d1d;padding:14px 24px;border-radius:12px;font-size:17px;font-weight:bold;');

        if (newCooldownEnd > wasCooldown) {
          if (window._429clearTimer) clearTimeout(window._429clearTimer);
          window._429clearTimer = setTimeout(() => {
            reloginCooldownUntil = 0;
            console.log('%cКулдаун 429 снят автоматически — можно снова стучаться',
              'color:white;background:#166534;padding:12px 20px;border-radius:12px;font-size:16px;font-weight:bold;');
          }, waitMs);
        }

        // ─────── КРИТИЧЕСКАЯ ЗАЩИТА: 429 ИМЕННО НА ЛОГИН → БЛОКИРУЕМ ВСЕ ПОПЫТКИ РЕЛОГИНА ───────
        const url = typeof input === 'string' ? input : input?.url || '';
        if (url.includes('/api/auth/login')) {
          login429Until = Date.now() + waitMs;

          console.log(`%c429 НА /auth/login → ПОЛНЫЙ БЛОК РЕЛОГИНОВ НА ${retryAfter} сек!`,
            'color:white;background:#dc2626;padding:16px 28px;border-radius:16px;font-size:19px;font-weight:bold;');

          if (window._login429timer) clearTimeout(window._login429timer);
          window._login429timer = setTimeout(() => {
            login429Until = 0;
            console.log('%cБлокировка релогина снята — можно снова пробовать',
              'color:white;background:#166534;padding:12px 20px;border-radius:12px;font-size:16px;font-weight:bold;');
          }, waitMs);
        }
      }

      // ─────── Ловим 401/403 ───────
      if (response.status === 401 || response.status === 403) {
        console.log('%cОбнаружен 401/403 → делаем silentRelogin', 'color:#fb923c;background:#451a03;padding:8px;border-radius:8px;');

        const reloginSuccess = await silentRelogin();
        if (reloginSuccess) {
          const newHeaders = {
            ...(init?.headers || {}),
            authorization: getAuthToken() || ''
          };
          return originalFetch(input, { ...init, headers: newHeaders });
        }
      }

      return response;
    };

    /** SEE **/
    if ('EventSource' in window) {
      const OriginalEventSource = window.EventSource;

      window.EventSource = function(url, config) {
        if (typeof url === 'string' && url.includes('/api/realtime/wallet/sse')) {
          const token = getAuthToken()?.replace('Bearer ', '') || '';
          const cleanUrl = url.split('access_token=')[0];
          const separator = cleanUrl.includes('?') ? '&' : '?';
          const finalUrl = cleanUrl + separator + 'access_token=' + encodeURIComponent(token);

          const es = new OriginalEventSource(finalUrl, config);
          es.addEventListener('error', () => {
            if (es.readyState === EventSource.CLOSED) {
            }
          });

          return es;
        }

        return new OriginalEventSource(url, config);
      };

      // Константы
      window.EventSource.CONNECTING = 0;
      window.EventSource.OPEN = 1;
      window.EventSource.CLOSED = 2;
    }

    /** FriendList **/
    async function loadFriendsList() {
      const token = getAuthToken();
      if (!token) {
        console.warn('Нет токена для загрузки друзей');
        window.friendsList = [];
        return;
      }

      try {
        const res = await fetch('https://oldprison-prod.luckygem.online/api/friendship/list', {
          method: 'GET',
          headers: { 'accept': 'application/json', 'authorization': token }
        });

        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();

        if (Array.isArray(data)) {
          window.friendsList = data.map(id => String(id)).filter(Boolean);
        } else {
          console.warn('Неверный формат ответа API друзей:', data);
          window.friendsList = [];
        }

        console.log('Друзья загружены:', window.friendsList.length);
      } catch (e) {
        console.warn('Ошибка загрузки друзей:', e.message);
        window.friendsList = [];
      }
    }

    /** API Func **/
    async function fetchTopPlayers() {
      const token = getAuthToken();
      if (!token) return showError('Ошибка', 'Токен не найден');
      updateStatus('Загружаем список...');

      try {
        const res = await fetch('https://oldprison-prod.luckygem.online/api/weekly-top/top?limit=10000', {
          headers: { 'accept': 'application/json', 'authorization': token }
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();

        currentPlayers = (data.top || []).map(p => ({
          ...p,
          userId: String(p.userId)
        }));

        await loadFriendsList();
        selectedPlayers = [];
        updateStatus(`Загружено: ${currentPlayers.length} игроков`);
        updateRangeInfo();
        displayPlayersTable(currentPlayers);
      } catch (e) {
        showError('Ошибка загрузки', e.message);
        updateStatus('Ошибка');
      }
    }
    async function fetchTalentPoints(userId) {
      userId = String(userId);
      if (window.talentsCache[userId] !== undefined) {
        return window.talentsCache[userId];
      }

      try {
        const token = getAuthToken();
        const res = await fetch(`https://oldprison-prod.luckygem.online/api/summary/${userId}`, {
          headers: { 'authorization': token, 'accept': 'application/json' }
        });

        if (!res.ok) throw new Error(res.status);

        const json = await res.json();
        const points = json?.data?.overview?.talentPointsTotal ?? 0;
        window.talentsCache[userId] = points;
        return points;
      } catch (err) {
        console.warn(`Не удалось загрузить таланты для ${userId}:`, err.message);
        window.talentsCache[userId] = 0; // кэшируем как 0, чтобы не спамить повторно
        return 0;
      }
    }
    async function sendFriendRequest(player) {
      const userId = player.id || player.userId;
      const token = getAuthToken();
      const res = await fetch(`https://oldprison-prod.luckygem.online/api/friendship/send-request?toUserId=${userId}`, {
        method: 'POST',
        headers: { 'authorization': token }
      });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
    }
    async function removeFriend(userId) {
      const token = getAuthToken();
      const res = await fetch(`https://oldprison-prod.luckygem.online/api/friendship/remove-friend?friendUserId=${userId}`, {
        method: 'POST',
        headers: { 'authorization': token }
      });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
    }
    async function performInteraction(toUserId, type) {
      const token = getAuthToken();
      const res = await fetch('https://oldprison-prod.luckygem.online/api/interaction/perform', {
        method: 'POST',
        headers: { 'content-type': 'application/json', 'authorization': token },
        body: JSON.stringify({ fromUserId: currentUserId, toUserId, type })
      });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
    }

  /** Modal Windows **/
  function showModal(config) {
    // Удаляем предыдущую модалку
    if (activeModal) activeModal.remove();

    const {
      title = "Уведомление",
      content = "",
      buttons = [],
      onClose,
      draggable = false,
      minimizable = false,
      closable = true,
      escapeToClose = false,
      allowOutsideClick = true
    } = config;

    const modal = document.createElement('div');
    modal.className = 'prison-modal-overlay';
    modal.style.zIndex = highestZIndex + 100;

    const box = document.createElement('div');
    box.className = 'prison-modal-box';
    box.style.position = 'relative';

    // Заголовок (всегда есть)
    const header = document.createElement('div');
    header.className = 'prison-modal-header';
    header.style.cssText = `
    padding: 16px 20px;
    background: #1e293b;
    border-bottom: 1px solid #475569;
    border-radius: 20px 20px 0 0;
    cursor: move;
    user-select: none;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-weight: 700;
    color: #60a5fa;
    font-size: 17px;
  `;

    const titleEl = document.createElement('div');
    titleEl.textContent = title;

    const controls = document.createElement('div');
    controls.style.display = 'flex';
    controls.style.gap = '8px';

    // Кнопка сворачивания
    if (minimizable) {
      const minimizeBtn = document.createElement('button');
      minimizeBtn.innerHTML = '−';
      minimizeBtn.style.cssText = 'width:32px;height:32px;background:#64748b;color:white;border:none;border-radius:50%;font-size:18px;cursor:pointer;';
      let minimized = false;
      minimizeBtn.onclick = (e) => {
        e.stopPropagation();
        minimized = !minimized;
        contentWrapper.style.display = minimized ? 'none' : 'block';
        minimizeBtn.innerHTML = minimized ? '+' : '−';
        box.style.height = minimized ? '70px' : 'auto';
      };
      controls.appendChild(minimizeBtn);
    }

    // Крестик — только если разрешено
    if (closable) {
      const closeBtn = document.createElement('button');
      closeBtn.innerHTML = '×';
      closeBtn.style.cssText = 'width:32px;height:32px;background:#ef4444;color:white;border:none;border-radius:50%;font-size:20px;cursor:pointer;';
      closeBtn.onclick = (e) => {
        e.stopPropagation();
        modal.remove();
        onClose?.();
      };
      controls.appendChild(closeBtn);
    }

    header.append(titleEl, controls);

    // Контент
    const contentWrapper = document.createElement('div');
    contentWrapper.style.padding = '20px';
    contentWrapper.innerHTML = content;

    // блок кнопок
    const btnContainer = document.createElement('div');
    btnContainer.style.cssText = 'display:flex;gap:12px;justify-content:center;margin-top:20px;';

    buttons.forEach(btn => {
      const b = document.createElement('button');
      b.className = `prison-btn ${btn.danger ? 'danger' : 'primary'}`;
      b.textContent = btn.label;
      b.onclick = () => {
        if (btn.action) btn.action();
        if (btn.close !== false) modal.remove();
      };
      btnContainer.appendChild(b);
    });

    box.append(header, contentWrapper, btnContainer);
    modal.appendChild(box);
    document.body.appendChild(modal);

    activeModal = modal;

    // === ДРАГАНДРОП ===
    if (draggable) {
      makeInterfaceDraggable(box);
    }

    // === ЗАКРЫТИЕ ПО КЛИКУ ВНЕ — только если разрешено ===
    if (allowOutsideClick) {
      modal.onclick = (e) => {
        if (e.target === modal) {
          if (closable) {
            modal.remove();
            onClose?.();
          }
        }
      };
    }

    // === ESC ===
    const escHandler = (e) => {
      if (e.key === 'Escape' && escapeToClose && closable) {
        modal.remove();
        onClose?.();
      }
    };
    document.addEventListener('keydown', escHandler);

    modal.addEventListener('remove', () => {
      document.removeEventListener('keydown', escHandler);
      if (activeModal === modal) activeModal = null;
    });

    return modal;
  }

  function confirmAction(title, text, onConfirm) {
    showModal({
      title,
      content: text,
      buttons: [
        { label: 'Отмена', action: () => {} },
        { label: 'Подтвердить', danger: false, action: onConfirm }
      ]
    });
  }

    function showError(title, content) {
      showModal({
        title,
        content: `<div class="text-error">${content}</div>`,
        buttons: [{ label: 'Закрыть', danger: true, action: () => {} }],
        closable: true,
        allowOutsideClick: true
      });
    }

    function showSuccess(title, content, duration = 6000) {
      showModal({
        title,
        content: `<div class="text-success">${content}</div>`,
        buttons: [{ label: 'Готово', action: () => {} }],
        closable: true,
        allowOutsideClick: true
      });

      if (duration > 0) {
        setTimeout(() => document.querySelector('.prison-modal-overlay')?.remove(), duration);
      }
    }

  /** Button UI **/

  function mainButton() {
    // === УДАЛЯЕМ ВСЁ СТАРОЕ ===
    document.getElementById('ui-buttons-container')?.remove();
    document.getElementById('friends-plus-btn')?.remove();
    document.getElementById('refresh-display-btn')?.remove();

    // === КОНТЕЙНЕР ===
    const container = document.createElement('div');
    container.id = 'ui-buttons-container';
    container.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 1000000 !important;;
    display: flex;
    gap: 12px;
    align-items: center;
    pointer-events: auto;
    font-family: system-ui, sans-serif;
  `;

    // === КНОПКА "ОТКРЫТЬ UI" ===
    const openBtn = document.createElement('button');
    openBtn.id = 'friends-plus-btn';
    openBtn.innerHTML = `
    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 6px;">
      <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
    </svg>
    <span>Открыть UI</span>
    <div class="shine-effect" style="position: absolute; inset: 0; border-radius: 50px; overflow: hidden; pointer-events: none;">
      <div style="position: absolute; width: 30px; height: 100%; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent); transform: translateX(-100%); animation: shine 2s infinite;"></div>
    </div>
  `;
    openBtn.style.cssText = `
    position: relative; display: flex; align-items: center; gap: 6px;
    padding: 12px 18px; border: none; border-radius: 50px; cursor: pointer;
    background: linear-gradient(135deg, #6e8efb, #a777e3); color: white;
    font-weight: 600; font-size: 14px; min-width: 140px;
    box-shadow: 0 8px 32px rgba(110, 142, 251, 0.35);
    transition: all 0.3s ease; overflow: hidden;
  `;
    openBtn.onmouseover = () => openBtn.style.transform = 'translateY(-3px) scale(1.05)';
    openBtn.onmouseout = () => openBtn.style.transform = '';
    openBtn.onclick = createMainInter;

    // === КНОПКА "ОБНОВИТЬ" ===
    const refreshBtn = document.createElement('button');
    refreshBtn.id = 'refresh-display-btn';
    refreshBtn.innerHTML = `
  <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 6px; transition: transform 0.4s ease;">
    <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>
  </svg>
  <span class="btn-text">Обновить</span>
  <div class="shine-effect" style="position: absolute; inset: 0; border-radius: 50px; overflow: hidden; pointer-events: none;">
    <div style="position: absolute; width: 30px; height: 100%; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent); transform: translateX(-100%); animation: shine 2s infinite;"></div>
  </div>
`;
    refreshBtn.style.cssText = `
  position: relative; display: flex; align-items: center; gap: 6px;
  padding: 12px 16px; border: none; border-radius: 50px; cursor: pointer;
  background: linear-gradient(135deg, #22c55e, #16a34a); color: white;
  font-weight: 600; font-size: 14px; min-width: 120px;
  box-shadow: 0 8px 32px rgba(34, 197, 94, 0.35);
  transition: all 0.3s ease; overflow: hidden;
`;
    refreshBtn.onmouseover = () => {
      refreshBtn.style.transform = 'translateY(-3px) scale(1.05)';
      refreshBtn.querySelector('svg').style.transform = 'rotate(180deg)';
    };
    refreshBtn.onmouseout = () => {
      if (!refreshBtn.classList.contains('loading')) {
        refreshBtn.style.transform = '';
        refreshBtn.querySelector('svg').style.transform = '';
      }
    };
    refreshBtn.onclick = () => {
      if (refreshBtn.classList.contains('loading')) return;

      refreshBtn.classList.add('loading');
      refreshBtn.style.opacity = '0.7';
      refreshBtn.style.transform = 'translateY(-3px) scale(1.05)';
      refreshBtn.querySelector('.btn-text').textContent = 'Обновляю...';
      refreshBtn.querySelector('svg').style.transform = 'rotate(360deg)';
      refreshBtn.querySelector('svg').style.animation = 'spin 1s linear infinite';

      setTimeout(() => {
        location.reload();
      }, 400);
    }

    // === ДОБАВЛЯЕМ КНОПКИ В КОНТЕЙНЕР ===
    container.append(openBtn, refreshBtn);

    document.body.appendChild(container);

    setTimeout(() => {
      openBtn.style.animation = 'pulse 1.5s infinite';
      setTimeout(() => openBtn.style.animation = '', 6000);
    }, 1000);
  }

  /** MainInter **/
  function createMainInter() {
    const old = document.getElementById('friends-interface');
    if (old) old.remove();

    currentUserId = getCurrentUserId();
    const container = document.createElement('div');
    container.id = 'friends-interface';
    container.className = 'prison-interface';


    // Header
    const header = document.createElement('div');
    header.className = 'interface-header';
    header.innerHTML = `
      <div class="header-title">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
          <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
        </svg>
        <h3>The Prison Helpher</h3>
      </div>
    `;

    const controls = document.createElement('div');
    controls.className = 'header-controls';

    const minimizeBtn = document.createElement('button');
    minimizeBtn.className = 'ctrl-btn minimize';
    minimizeBtn.title = 'Свернуть';
    minimizeBtn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M5 12h14"/></svg>`;
    minimizeBtn.onclick = toggleMinimize;

    const closeBtn = document.createElement('button');
    closeBtn.className = 'ctrl-btn close';
    closeBtn.title = 'Закрыть';
    closeBtn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M18 6L6 18M6 6l12 12"/></svg>`;
    closeBtn.onclick = () => container.remove();

    controls.append(minimizeBtn, closeBtn);
    header.appendChild(controls);
    container.appendChild(header);

    // Content
    const content = document.createElement('div');
    content.className = 'interface-content';

    if (currentUserId) {
      const myDataSection = document.createElement('div');
      myDataSection.id = 'my-data-section';
      myDataSection.className = 'my-data-section';
      myDataSection.classList.add('collapsed');

      const header = document.createElement('div');
      header.className = 'my-data-header';
      header.innerHTML = `
  <span>Мои данные</span>
  <svg class="arrow" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
    <path d="M6 9l6 6 6-6"/>
  </svg>
`;

      const contentDiv = document.createElement('div');
      contentDiv.className = 'my-data-content';

      const list = document.createElement('div');
      list.className = 'my-data-list';
      list.innerHTML = '<div class="loading">Загрузка...</div>';

      contentDiv.appendChild(list);
      myDataSection.append(header, contentDiv);
      content.prepend(myDataSection);

      (async () => {
        try {
          const res = await fetch('https://oldprison-prod.luckygem.online/api/player/init', {
            method: 'POST',
            headers: {
              'authorization': getAuthToken(),
              'content-type': 'application/json'
            },
            body: '{}'
          });

          if (!res.ok) throw new Error();
          const data = await res.json();
          if (!data.success) throw new Error();

          const p = data;
          const c = p.currencies || {};

          list.innerHTML = '';

          const items = [
            { icon: 'https://oldprison-prod.luckygem.online/assets/Avtoritet.png', label: 'Авторитет', value: (p.authority || 0).toLocaleString('ru-RU'), highlight: 'gold' },
            { icon: 'https://oldprison-prod.luckygem.online/assets/bitseps.png', label: 'Бицуха', value: (p.biceps || 0).toLocaleString('ru-RU'), highlight: 'gold' },
            { icon: 'https://oldprison-prod.luckygem.online/assets/Energy.png', label: 'Энергия', value: `${p.energy ?? 0} / ${p.maxEnergy ?? 0}`, highlight: 'gold' },
            { icon: 'https://cdn.the-prison.ru/bayValyt/img/icon_Page/cigarettes/1.webp', label: 'Сигареты', value: (c.cigarettes || 0).toLocaleString('ru-RU'), highlight: c.cigarettes >= 1000000 ? 'million' : '' },
            { icon: 'https://cdn.the-prison.ru/bayValyt/img/icon_Page/rubles/1.webp', label: 'Рубли', value: (c.rubles || 0).toLocaleString('ru-RU'), highlight: c.rubles >= 1000000 ? 'million' : '' },
            { icon: 'https://cdn.the-prison.ru/bayValyt/img/icon_Page/sugar/4.webp', label: 'Сахар', value: (c.sugar || 0).toLocaleString('ru-RU'), highlight: c.sugar >= 1000000 ? 'million' : '' },
            { icon: 'https://cdn.the-prison.ru/bayValyt/img/icon_Page/paper/2.webp', label: 'Бумага', value: (c.paper || 0).toLocaleString('ru-RU'), highlight: c.paper >= 1000000 ? 'million' : '' },
            { icon: 'https://cdn.the-prison.ru/bayValyt/img/icon_Page/soap/2.webp', label: 'Мыло', value: (c.soap || 0).toLocaleString('ru-RU'), highlight: '' },
            { icon: 'https://cdn.the-prison.ru/bayValyt/img/icon_Page/condensed_milk/2.webp', label: 'Сгуха', value: (c.condensed_milk || 0).toLocaleString('ru-RU'), highlight: '' },
            { icon: 'https://cdn.the-prison.ru/MainRoom/chefir.png', label: 'Чефир', value: (c.chefir || 0).toLocaleString('ru-RU'), highlight: '' },
            { icon: 'https://cdn.the-prison.ru/Zaruba/ZarunIconfix.webp', label: 'Печатки', value: (c.signet || 0).toLocaleString('ru-RU'), highlight: '' },
            { icon: 'https://cdn.the-prison.ru/poker/pokerMatch.webp', label: 'Роз.Спички', value: (c.pink_matches || 0).toLocaleString('ru-RU'), highlight: '' },
            { icon: 'https://cdn.the-prison.ru/FortuneScene/Match_blue_reward.webp', label: 'Гол.Спички', value: (c.blue_matches || 0).toLocaleString('ru-RU'), highlight: '' },
            { icon: 'https://cdn.the-prison.ru/FortuneScene/biletic_jackpot.webp', label: 'Лот.билет', value: (c.fortune_tickets || 0).toLocaleString('ru-RU'), highlight: '' },
            { icon: 'https://cdn.the-prison.ru/PrisonV3/BARIGA/img/stewBalance.webp', label: 'Тушенка', value: (c.stew || 0).toLocaleString('ru-RU'), highlight: '' }
          ];

          items.forEach(item => {
            const row = document.createElement('div');
            row.className = `data-row ${item.highlight}`;
            row.innerHTML = `
        <span class="icon">
    <img src="${item.icon}" alt="${item.label}" onerror="this.style.display='none'">
  </span>
        <span class="label">${item.label}</span>
        <span class="value">${item.value}</span>
      `;
            list.appendChild(row);
          });

        } catch (err) {
          list.innerHTML = '<div class="error">Не удалось загрузить данные</div>';
        }
      })();

      // Клик по заголовку — раскрытие/сворачивание
      header.onclick = () => {
        myDataSection.classList.toggle('collapsed');
      };
    }

    // Tabs
    const tabs = createTabs();
    content.appendChild(tabs);

    // Tab Contents
    content.appendChild(createTopContent());
    content.appendChild(createFriendsContent());
    content.appendChild(createComboContent());
    content.appendChild(createTattooClothesContent());
    content.appendChild(createHideoutsContent());
    content.appendChild(createWorkerContent());
    content.appendChild(createTalentsContent());
    content.appendChild(createWeaponContent());
    content.appendChild(createCalculatorContent());
    content.appendChild(createCatalaContent());
    content.appendChild(createPokerContent());
    content.appendChild(createBossesContent());
    content.appendChild(createZarubaContent());
    content.appendChild(createGadalkaContent());
    content.appendChild(createZShContent());


    const status = document.createElement('div');
    status.id = 'friends-status';
    status.className = 'status-bar';
    status.textContent = 'Готов к работе';

    content.append(status);

    // === КОНСОЛЬ ЛОГОВ — ОПТИМИЗИРОВАНО ПОД 320PX ШИРИНУ ===
    const logSection = document.createElement('div');
    logSection.style.cssText = `
      margin-top: 16px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    `;

    const logHeader = document.createElement('div');
    logHeader.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 2px;
    `;

    const logTitle = document.createElement('span');
    logTitle.textContent = 'Логи';
    logTitle.style.cssText = `
      font-weight: 600;
      color: #94a3b8;
      font-size: 12.5px;
    `;

    const clearBtn = document.createElement('button');
    clearBtn.textContent = 'Очистить';
    clearBtn.style.cssText = `
      padding: 3px 8px;
      background: #334155;
      color: #cbd5e1;
      border: none;
      border-radius: 6px;
      font-size: 11px;
      cursor: pointer;
      transition: background 0.2s;
    `;
    clearBtn.onmouseover = () => clearBtn.style.background = '#475569';
    clearBtn.onmouseout = () => clearBtn.style.background = '#334155';

    const logConsole = document.createElement('div');
    logConsole.id = 'custom-log-console';
    logConsole.style.cssText = `
      min-height: 110px;
      max-height: 160px;
      overflow-y: auto;
      background: rgba(15, 23, 42, 0.96);
      border: 1px solid #334155;
      border-radius: 12px;
      padding: 8px 10px;
      font-family: 'JetBrains Mono', 'Consolas', 'Courier New', monospace;
      font-size: 11.2px;           /* чуть меньше — больше строк влезает */
      line-height: 1.4;            /* оптимально для читаемости */
      color: #e2e8f0;
      word-break: break-all;       /* критически важно: длинные токены рвутся */
      white-space: pre-wrap;
      scrollbar-width: thin;
      scrollbar-color: #475569 #1e293b;
    `;

    // Скроллбар для Chrome/Safari
    const scrollStyle = document.createElement('style');
    scrollStyle.textContent = `
      #custom-log-console::-webkit-scrollbar {
        width: 7px;
      }
      #custom-log-console::-webkit-scrollbar-track {
        background: transparent;
      }
      #custom-log-console::-webkit-scrollbar-thumb {
        background: #475569;
        border-radius: 4px;
      }
      #custom-log-console::-webkit-scrollbar-thumb:hover {
        background: #64748b;
      }
    `;
    document.head.appendChild(scrollStyle);

    clearBtn.onclick = () => logConsole.innerHTML = '';
    logHeader.appendChild(logTitle);
    logHeader.appendChild(clearBtn);
    logSection.appendChild(logHeader);
    logSection.appendChild(logConsole);
    content.appendChild(logSection);

    // === ПЕРЕХВАТ console.log ===
    const originalLog = console.log;
    console.log = function (...args) {
      originalLog.apply(console, args);
      if (args.length === 0) return;

      let messageParts = [];
      let style = '';

      for (let i = 0; i < args.length; i++) {
        const arg = args[i];
        if (typeof arg === 'string') {
          if (arg.match(/^(color|background|padding|font|border|margin)/i) && !style) {
            style = arg;
            continue;
          }
          if (arg.includes('%c')) {
            const parts = arg.split('%c');
            messageParts.push(parts[0].trim());
            if (parts[1] && i + 1 < args.length) {
              style = args[i + 1];
              i++;
            }
            messageParts.push(parts[1]?.trim() || '');
            continue;
          }
        }
        messageParts.push(String(arg));
      }

      const message = messageParts.join(' ').trim();
      if (!message) return;

      const line = document.createElement('div');
      line.style.cssText = `
        padding: 4px 8px;
        margin: 1.5px 0;
        border-radius: 7px;
        background: rgba(30, 41, 59, 0.55);
        font-size: 11.2px;
        line-height: 1.4;
        word-break: break-all;
        white-space: pre-wrap;
        ${style}
      `;

      if (!style) {
        const lower = message.toLowerCase();
        if (lower.includes('успешн') || lower.includes('токен обновлён') || lower.includes('свежий initdata')) {
          line.style.backgroundColor = '#166534';
          line.style.color = '#dcfce7';
          line.style.fontWeight = '600';
        } else if (lower.includes('очередь') || lower.includes('ожидание')) {
          line.style.color = '#fbbf24';
          line.style.fontWeight = '600';
        } else if (message.includes('+')) {
          line.style.color = '#86efac';
          line.style.fontWeight = '600';
        } else if (message.includes('–') || message.includes('-')) {
          line.style.color = '#fca5a5';
          line.style.fontWeight = '600';
        }
      }

      line.textContent = `[${new Date().toLocaleTimeString('ru-RU', {hour: '2-digit', minute: '2-digit', second: '2-digit'})}] ${message}`;
      logConsole.appendChild(line);
      logConsole.scrollTop = logConsole.scrollHeight;

      while (logConsole.children.length > 400) {  // можно больше строк — шрифт меньше
        logConsole.removeChild(logConsole.firstChild);
      }
    };

    // Перехват ошибок
    const originalError = console.error;
    console.error = function (...args) {
      originalError.apply(console, args);
      const line = document.createElement('div');
      line.style.cssText = 'color: #ff7b72; font-weight: 600; background: rgba(127, 29, 29, 0.35); padding: 4px 8px; border-radius: 7px; margin: 1.5px 0;';
      line.textContent = `[${new Date().toLocaleTimeString('ru-RU', {hour: '2-digit', minute:'2-digit', second:'2-digit'})}] ERROR: ${args.join(' ')}`;
      logConsole.appendChild(line);
      logConsole.scrollTop = logConsole.scrollHeight;
    };

    container.appendChild(content);
    document.body.appendChild(container);


    makeInterfaceDraggable(container);
    attachActionHandlers();

  }

  /** Tabs MainInter **/
  function createTabs()   {
    const tabs = document.createElement('div');
    tabs.className = 'tabs-container';

    const tabData = [
      { id: 'top', label: 'Список игроков', active: true },
      { id: 'combo', label: 'Combo', active: false },
      { id: 'tattoo', label: 'Тату/Шмот', active: false },
      { id: 'hideouts', label: 'Нычки', active: false },
      { id: 'worker', label: 'Рабочка', active: false },
      { id: 'talents', label: 'Таланты', active: false },
      { id: 'weapon', label: 'Оружие', active: false },
      { id: 'calculator', label: 'Калькулятор', active: false },
      { id: 'catala', label: 'Катала', active: false },
      { id: 'poker',     label: 'Покер',          active: false },
      { id: 'bosses', label: 'Боссы', icon: 'Skull', active: false },
      { id: 'zaruba', label: 'Зарубы', active: false },
      { id: 'gadalka',   label: 'Гадалка', active: false },
      { id: 'zsh', label: 'ЗШ', active: false },
    ];

    tabData.forEach(tab => {
      const btn = document.createElement('button');
      btn.dataset.tab = tab.id;
      btn.textContent = tab.label;
      btn.className = `tab-btn ${tab.active ? 'active' : ''}`;
      btn.onclick = () => switchTab(btn.dataset.tab);
      tabs.appendChild(btn);
    });

    return tabs;
  }

  function switchTab(tab) {
    document.querySelectorAll('.tab-content').forEach(c => {
      c.classList.remove('active');
      c.style.display = 'none';
    });

    const target = document.getElementById(tab + '-content');
    if (target) {
      target.classList.add('active');
      target.style.display = 'block'; // ← вот ключевой фикс
    }

    document.getElementById(tab + '-content').classList.add('active');
    document.querySelectorAll('.tab-btn').forEach(b => {
      b.classList.toggle('active', b.dataset.tab === tab);
    });
    if (tab === 'zaruba') {
      loadZarubaData();
    }
  }

  /** Content **/
  function createTopContent()   {
    const div = document.createElement('div');
    div.className = 'tab-content active';
    div.id = 'top-content';

    const centerWrapper = document.createElement('div');
    centerWrapper.className = 'center-wrapper';


    const loadBtn = document.createElement('button');
    loadBtn.textContent = 'Загрузить ТОП по урону';
    loadBtn.className = 'load-btn';
    loadBtn.onclick = fetchTopPlayers;
    centerWrapper.appendChild(loadBtn);

    const range = document.createElement('div');
    range.className = 'range-selector';
    range.innerHTML = `
    <div class="range-label">Диапазон:</div>
    <div class="range-inputs">
      <input id="range-start" type="number" value="1" min="1">
      <span class="range-separator">—</span>
      <input id="range-end" type="number" value="50" min="1">
    </div>
    <div id="range-info" class="range-info">Всего: 0</div>
  `;
    centerWrapper.appendChild(range);

    const applyBtn = document.createElement('button');
    applyBtn.textContent = 'Применить';
    applyBtn.className = 'apply-btn';
    applyBtn.onclick = () => {
      const start = parseInt(document.getElementById('range-start').value) || 1;
      const end = parseInt(document.getElementById('range-end').value) || 50;
      if (start > end || !currentPlayers.length) return showError('Ошибка', 'Некорректный диапазон');
      selectedPlayers = currentPlayers.slice(start - 1, end);
      updateRangeInfo();
      showSuccess('Выбрано', `${selectedPlayers.length} игроков`);
    };
    centerWrapper.appendChild(applyBtn);

    const friendsButtonContainer = document.createElement('div');
    friendsButtonContainer.style.cssText = 'margin: 20px 0; text-align: center;';

    const friendsBtn = document.createElement('button');
    friendsBtn.id = 'friends-master-button';
    friendsBtn.className = 'friends-master-btn';
    friendsBtn.style.cssText = `
      background: linear-gradient(135deg, #8b5cf6, #a78bfa);
      color: white;
      border: none;
      border-radius: 16px;
      padding: 16px 24px;
      font-size: 16px;
      font-weight: 700;
      width: 100%;
      max-width: 340px;
      cursor: pointer;
      box-shadow: 0 8px 32px rgba(139, 92, 246, 0.4);
      transition: all 0.3s ease;
    `;
    friendsBtn.innerHTML = `
      <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 10px; vertical-align: -3px;">
        <path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.83 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/>
      </svg>
      Чистка друзей
    `;

    friendsBtn.onclick = (e) => {
      e.stopPropagation();
      openFriendsModal();
    };

    friendsButtonContainer.appendChild(friendsBtn);
    centerWrapper.appendChild(friendsButtonContainer);

    // КНОПКА "Посмотреть в таблице"
    const viewBtn = document.createElement('button');
    viewBtn.id = 'view-top-table-btn';
    viewBtn.textContent = 'Посмотреть в таблице';
    viewBtn.className = 'action-btn success';
    viewBtn.style.display = 'none';
    viewBtn.style.marginTop = '20px';
    viewBtn.onclick = openTopPlayersModal;
    centerWrapper.appendChild(viewBtn);


    // Кнопки действий остаются внизу
    const actions = document.createElement('div');
    actions.className = 'actions-section';
    actions.innerHTML = `
    <button class="action-btn" data-action="send">Отправить заявки</button>
    <button class="action-btn danger" data-action="remove">Удалить друзей</button>
    <button class="action-btn" data-action="biceps">Бицуха</button>
    <button class="action-btn" data-action="droj">Дрожжи</button>
    <button class="action-btn danger" data-action="harknut">Харкнуть</button>
    <button class="action-btn danger" data-action="fight">Наезд</button>
   
  `;
    centerWrapper.appendChild(actions);

    div.appendChild(centerWrapper);
    return div;
  }

  function createFriendsContent() {
      const div = document.createElement('div');
      div.className = 'tab-content';
      div.id = 'friends-content';

      const filter = document.createElement('div');
      filter.className = 'talent-filter';
      filter.innerHTML = `
      <div class="filter-label">Фильтр по талантам:</div>
      <div class="range-inputs">
        <input id="min-talents" type="number" value="0" min="0">
        <span>-</span>
        <input id="max-talents" type="number" value="1000" min="0">
      </div>
      <button id="apply-talent-filter" class="filter-apply-btn">Применить фильтр</button>
    `;
      div.appendChild(filter);

      const range = document.createElement('div');
      range.className = 'range-selector';
      range.innerHTML = `
      <div class="range-label">Диапазон:</div>
      <div class="range-inputs">
        <input id="friends-range-start" type="number" value="1" min="1">
        <span>-</span>
        <input id="friends-range-end" type="number" value="50" min="1">
      </div>
      <div id="friends-range-info" class="range-info">Всего: 0</div>
    `;
      div.appendChild(range);

      const applyBtn = document.createElement('button');
      applyBtn.textContent = 'Выбрать диапазон';
      applyBtn.className = 'apply-btn';
      applyBtn.onclick = () => {
        if (!talentFilteredPlayers.length) return showError('Ошибка', 'Примените фильтр!');
        const start = parseInt(document.getElementById('friends-range-start').value) || 1;
        const end = parseInt(document.getElementById('friends-range-end').value) || 50;
        if (start > end) return showError('Ошибка', 'Некорректный диапазон!');
        showSuccess('Выбрано', `${talentFilteredPlayers.length} игроков`);
      };
      div.appendChild(applyBtn);

      return div;
    }

  function createComboContent() {
    const div = document.createElement('div');
    div.className = 'tab-content';
    div.id = 'combo-content';

    const textarea = document.createElement('textarea');
    textarea.id = 'combo-input';
    textarea.placeholder = 'Введите комбо. Проверьте ввод по кол-ву ударов\nДоступные удары:\n' +
      '- Ухо/Колено \n' +
      '- Пах\n' +
      '- Глаза/Глаз\n' +
      '- Грудь/Удар в грудь\n' +
      '- Яд\n' +
      '- Финка\n' +
      '- Самопал/Пал ';
    textarea.className = 'combo-textarea';

    const delayLabel = document.createElement('label');
    delayLabel.textContent = 'Задержка (мс) (Рекомендуем от 1200):';
    delayLabel.className = 'combo-label';

    const delayInput = document.createElement('input');
    delayInput.id = 'combo-delay';
    delayInput.type = 'number';
    delayInput.value = '1500';
    delayInput.min = '800';
    delayInput.className = 'combo-delay-input';

    const executeBtn = document.createElement('button');
    executeBtn.textContent = 'Выполнить комбо';
    executeBtn.className = 'combo-execute-btn';

    const stopBtn = document.createElement('button');
    stopBtn.textContent = 'Остановить';
    stopBtn.className = 'combo-stop-btn';

    const status = document.createElement('div');
    status.id = 'combo-status';
    status.className = 'combo-status';
    status.textContent = 'Готов к работе';


    const progress = document.createElement('div');
    progress.id = 'combo-progress';
    progress.className = 'combo-progress';

    const previewBox = document.createElement('div');
    previewBox.className = 'combo-preview-box';
    previewBox.innerHTML = `
  <div class="preview-title">Анализ комбо</div>
  <div class="preview-grid">
  <div class="preview-row">
    <span class="label">Всего ударов</span>
    <strong id="total-hits">0</strong>
  </div>
  <div class="preview-row">
    <span class="label">Бесплатных</span>
    <strong id="free-hits">0</strong>
  </div>
  <div class="preview-row">
    <span class="label">Платных</span>
    <strong id="paid-hits">0</strong>
  </div>
  
  <div class="preview-divider"></div>
  
  <div class="preview-row highlight">
    <span class="label">Общая Стоимость</span>
    <strong id="total-cost" class="cost-main">Бесплатно</strong>
  </div>
  
  <div class="preview-row highlight">
    <span class="label">Стоимость Восст.Ударов</span>
    <strong id="stock-restore-cost" class="cost-restore">0 ₽</strong>
  </div>
</div>
  <div class="preview-details" id="combo-details"></div>

  <div style="margin-top:16px; padding-top:12px; border-top:1px dashed #475569;">
    <div style="display:flex; gap:8px; margin-bottom:8px;">
      <input type="text" id="saved-combo-name" placeholder="Название комбо..." class="saved-combo-input">
      <button id="save-combo-btn" class="save-combo-button">Сохранить</button>
    </div>
    <div id="saved-combos-list" class="saved-combos-container"></div>
  </div>
`;

    div.append(textarea, previewBox, delayLabel, delayInput, executeBtn, stopBtn, status, progress);

    const weaponConfig = [
      { keys: ["ухо", "колено", "по уху", "в ухо"],           weapon: "kneeEar",    restore: "KneeEar",    name: "Ухо/Колено",    freeFirst: true,  cost: 3 },
      { keys: ["пах", "по яйцам", "в пах", "яйца"],          weapon: "kickBalls",  restore: "KickBalls",  name: "Пах",           freeFirst: true,  cost: 3 },
      { keys: ["глаза", "глаз", "палец в глаз", "по глазу", "в глаз", "тык в глаз"],
        weapon: "pokeEyes",   restore: "PokeEyes",   name: "Глаза",         freeFirst: true,  cost: 3 },
      { keys: ["грудь", "удар в грудь", "по груди", "в грудь", "кулаком в грудь"],
        weapon: "punchChest", restore: "PunchChest", name: "Грудь",         freeFirst: true,  cost: 3 },
      { keys: ["яд", "отравить", "ядом"],                   weapon: "poison",     restore: null,         name: "Яд",            freeFirst: false, cost: 18 },
      { keys: ["финка", "фин", "нож", "ножом", "финкой"],   weapon: "knife",      restore: null,         name: "Финка",         freeFirst: false, cost: 4 },
      { keys: ["самопал", "пал", "выстрел", "стрелять", "пистолет"],
        weapon: "gunshot",    restore: null,         name: "Самопал",       freeFirst: false, cost: 5 }
    ];

    const weapons = {};
    const displayNames = {};

    weaponConfig.forEach(config => {
      config.keys.forEach(key => {
        weapons[key.toLowerCase()] = {
          weapon: config.weapon,
          restore: config.restore,
          freeFirst: config.freeFirst,
          cost: config.cost
        };
        displayNames[config.weapon] = config.name;
      });
    });

    // === Парсер Комбо ===
    function parseComboInput(text) {
      if (!text || !text.trim()) return [];

      const moves = [];

      // Разбиваем по строкам и обрабатываем каждую
      text.split('\n').forEach(line => {
        if (!line.trim()) return;

        // Убираем нумерацию в начале строки: 1. 2) 3- 10— и т.д.
        let cleaned = line.replace(/^\d+[\.\)\-\–\—\_\•\*]\s*/g, '').trim();

        // Разбиваем по пробелам, запятым, точкам, тире и другим разделителям
        const words = cleaned.split(/[\s,.;:!?()[\]{}—–\-_+/\\|]+/);

        words.forEach(word => {
          if (!word) return;

          // оставляем только буквы
          let cleanWord = word.replace(/[^а-яА-ЯёЁ]/g, '').toLowerCase();

          // Допы: если слово было типа "1ухо" или "пах2" — пытаемся вытащить буквы
          if (cleanWord.length === 0) {
            const lettersOnly = word.match(/[а-яА-ЯёЁ]/g);
            if (lettersOnly) {
              cleanWord = lettersOnly.join('').toLowerCase();
            }
          }

          if (cleanWord && weapons[cleanWord]) {
            moves.push(cleanWord);
          }
        });
      });

      return moves;
    }

    let isRunning = false;
    let currentCombo = [];
    let currentIndex = 0;

    const usedFreeHit = {};

    const SAVED_COMBOS_KEY = 'tp_saved_combos_v3';
    let savedCombos = JSON.parse(localStorage.getItem(SAVED_COMBOS_KEY) || '[]');

    // === РЕНДЕР СОХРАНЁННЫХ ===
    function renderSavedCombos() {
      const list = previewBox.querySelector('#saved-combos-list');
      list.innerHTML = '';

      if (savedCombos.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'saved-combo-empty';
        empty.textContent = 'Нет сохранённых комбо';
        list.appendChild(empty);
        attachSaveHandler();
        return;
      }

      savedCombos.forEach((item, idx) => {
        const row = document.createElement('div');
        row.className = 'saved-combo-row';

        const nameEl = document.createElement('span');
        nameEl.className = 'saved-combo-name';
        nameEl.textContent = item.name;
        nameEl.title = 'Клик — вставить комбо';
        nameEl.onclick = () => {
          textarea.value = item.text;
          analyzeCombo();
          previewBox.scrollIntoView({ behavior: 'smooth', block: 'center' });
        };

        const countEl = document.createElement('small');
        countEl.className = 'saved-combo-count';
        const hits = parseComboInput(item.text).length;
        countEl.textContent = hits + ' ' + (hits % 10 === 1 && hits !== 11 ? 'удар' : hits % 10 >= 2 && hits % 10 <= 4 && (hits < 10 || hits > 20) ? 'удара' : 'ударов');

        const delBtn = document.createElement('button');
        delBtn.className = 'saved-combo-delete';
        delBtn.textContent = '×';
        delBtn.onclick = (e) => {
          e.stopPropagation();
          savedCombos.splice(idx, 1);
          localStorage.setItem(SAVED_COMBOS_KEY, JSON.stringify(savedCombos));
          renderSavedCombos();
        };

        row.append(nameEl, countEl, delBtn);
        list.appendChild(row);
      });

      attachSaveHandler();
    }

    function attachSaveHandler() {
      const saveBtn = previewBox.querySelector('#save-combo-btn');
      const nameInput = previewBox.querySelector('#saved-combo-name');
      if (!saveBtn || !nameInput) return;

      const newBtn = saveBtn.cloneNode(true);
      saveBtn.parentNode.replaceChild(newBtn, saveBtn);

      newBtn.onclick = () => {
        let name = nameInput.value.trim();
        const text = textarea.value.trim();
        if (!text) return showError('Ошибка', 'Введите комбо для сохранения');
        if (!name) name = `Комбо #${savedCombos.length + 1}`;

        savedCombos = savedCombos.filter(c => c.name !== name);
        savedCombos.unshift({ name, text, savedAt: Date.now() });
        if (savedCombos.length > 20) savedCombos.pop();

        localStorage.setItem(SAVED_COMBOS_KEY, JSON.stringify(savedCombos));
        nameInput.value = '';
        renderSavedCombos();
        showSuccess('Готово', `"${name}" сохранено`);
      };
    }

    function analyzeCombo() {
      const text = textarea.value.trim();
      const totalHitsEl = document.getElementById('total-hits');
      const freeHitsEl = document.getElementById('free-hits');
      const paidHitsEl = document.getElementById('paid-hits');
      const totalCostEl = document.getElementById('total-cost');
      const stockCostEl = document.getElementById('stock-restore-cost');
      const detailsEl = document.getElementById('combo-details');

      if (!text) {
        totalHitsEl.textContent = '0';
        freeHitsEl.textContent = '0';
        paidHitsEl.textContent = '0';
        totalCostEl.textContent = '0 ₽';
        stockCostEl.textContent = '0 ₽';
        detailsEl.innerHTML = '';
        previewBox.style.opacity = '0.5';
        return;
      }

      previewBox.style.opacity = '1';
      const moves = parseComboInput(text);
      const totalHits = moves.length;

      const usage = {};
      const displayCount = {};

      moves.forEach(move => {
        const w = weapons[move];
        if (w) {
          usage[w.weapon] = (usage[w.weapon] || 0) + 1;
          displayCount[move] = (displayCount[move] || 0) + 1;
        }
      });

      let freeHits = 0;
      let paidHits = 0;
      let totalCost = 0;
      let stockRestoreCost = 0;

      Object.entries(usage).forEach(([weapon, count]) => {
        const config = Object.values(weapons).find(w => w.weapon === weapon);
        if (!config) return;

        if (config.freeFirst) {
          freeHits++;
          if (count > 1) {
            paidHits += (count - 1);
            totalCost += (count - 1) * config.cost;
            // Каждый лишний стоковый удар требует восстановления за 3₽
            stockRestoreCost += (count - 1) * 3;
          }
        } else {
          paidHits += count;
          totalCost += count * config.cost;
        }
      });

      const unknown = moves.filter(m => !weapons[m]).length;

      totalHitsEl.textContent = totalHits;
      freeHitsEl.textContent = freeHits;
      paidHitsEl.textContent = paidHits;
      totalCostEl.textContent = totalCost > 0 ? `${totalCost} ₽` : 'Бесплатно';
      stockCostEl.textContent = stockRestoreCost > 0 ? `${stockRestoreCost} ₽` : '0 ₽';

      // === ГРУППИРУЕМ ПО ТИПУ ОРУЖИЯ ===
      const weaponUsage = {};

      moves.forEach(move => {
        const w = weapons[move];
        if (w) {
          weaponUsage[w.weapon] = (weaponUsage[w.weapon] || 0) + 1;
        }
      });

      const details = [];
      Object.entries(weaponUsage).forEach(([weaponType, count]) => {
        const config = weaponConfig.find(c => c.weapon === weaponType);
        if (!config) return;

        const paid = config.freeFirst ? (count > 1 ? count - 1 : 0) : count;
        const suffix = paid > 0
          ? ` <small style="color:#f59e0b">(${paid}×${config.cost}₽)</small>`
          : config.freeFirst ? ` <small style="color:#34d399">(беспл.)</small>` : '';

        details.push(`<span style="color:#60a5fa">${config.name}</span> ×${count}${suffix}`);
      });

      if (unknown > 0) details.push(`<span style="color:#ef4444">Неизвестно: ${unknown}</span>`);
      detailsEl.innerHTML = details.length > 0 ? details.join(' • ') : '<span style="color:#94a3b8">Только бесплатные</span>';
    }

    // === Reload ===
    async function executeCombo() {
      let consecutive429 = 0;
      const MAX_CONSECUTIVE_429 = 6;
      if (isRunning) return;
      const comboText = textarea.value.trim();
      const delay = Math.max(800, parseInt(delayInput.value) || 1500);
      if (!comboText) return showError('Ошибка', 'Введите комбо');

      const token = getAuthToken();
      if (!token) return showError('Ошибка', 'Токен не найден');

      isRunning = true;
      currentIndex = 0;
      executeBtn.disabled = true;
      stopBtn.style.opacity = '1';

      currentCombo = parseComboInput(comboText);
      Object.keys(usedFreeHit).forEach(k => delete usedFreeHit[k]);

      progress.textContent = `Очередь: ${currentCombo.map(m => {
        const cfg = weaponConfig.find(c => c.keys.some(k => k === m));
        return cfg?.name || m;
      }).join(' → ')}`;
      status.textContent = `Выполняю... (0/${currentCombo.length})`;
      status.className = 'combo-status warning';

      let rewardData = null;
      let beforeWeapons = null;
      let afterWeapons = null;

      // === 1. Получаем количество оружия ДО комбо ===
      try {
        const initRes = await fetch('https://oldprison-prod.luckygem.online/api/player/init', {
          method: 'POST',
          headers: { 'authorization': token, 'content-type': 'application/json' }
        });
        if (initRes.ok) {
          const data = await initRes.json();
          if (data.success) {
            beforeWeapons = {
              knife: data.knifeCount || 0,
              poison: data.poisonCount || 0,
              gunshot: data.gunshotCount || 0
            };
          }
        }
      } catch (e) {}

      for (let i = 0; i < currentCombo.length; i++) {
        if (!isRunning) break;
        currentIndex = i;

        const move = currentCombo[i];
        const w = weapons[move];
        if (!w) {
          status.textContent = `Неизвестный удар: ${move}`;
          continue;
        }

        const weaponType = w.weapon;
        const config = weaponConfig.find(c => c.weapon === weaponType);
        const displayName = config?.name || move;

        if (w.freeFirst && w.restore) {
          if (usedFreeHit[weaponType]) {
            status.textContent = `Восстанавливаю ${displayName} за 3₽...`;
            const restoreResp = await fetch("https://oldprison-prod.luckygem.online/api/boss/restore-free-hit", {
              method: "POST",
              headers: { "content-type": "application/json", "authorization": token },
              body: JSON.stringify({ weaponType: w.restore })
            });

            if (!restoreResp.ok) {
              status.textContent = `Не удалось восстановить ${displayName}`;
              isRunning = false;
              break;
            }
            await new Promise(r => setTimeout(r, 1400 + Math.random() * 400));
            usedFreeHit[weaponType] = false;
          }
          usedFreeHit[weaponType] = true;
        }

        status.textContent = `Бью ${displayName}... (${i + 1}/${currentCombo.length})`;

        const response = await fetch("https://oldprison-prod.luckygem.online/api/boss/use-weapon", {
          method: "POST",
          headers: { "content-type": "application/json", "authorization": token },
          body: JSON.stringify({ weapon: weaponType })
        });

        if (response.status === 429) {
          consecutive429++;

          if (consecutive429 > MAX_CONSECUTIVE_429) {
            status.textContent = `Слишком много 429 подряд — останавливаем`;
            status.className = 'combo-status error';
            isRunning = false;
            executeBtn.disabled = false;
            return;
          }

          const waitTime = 1000 + consecutive429 * 400; // растём: 1.4 → 1.8 → 2.2 → ...
          status.textContent = `429 (${consecutive429}/${MAX_CONSECUTIVE_429}) → ждём ~${Math.round(waitTime/1000)} сек`;
          status.className = 'combo-status warning';

          await new Promise(r => setTimeout(r, waitTime));
          i--;
          continue;
        } else {
          consecutive429 = 0; // сбрасываем при успешном ударе
        }

        // === БЕЗОПАСНО ЧИТАЕМ ОТВЕТ ОДИН РАЗ ===
        let rawText = "";
        let data = null;

        try {
          rawText = await response.text();

          // Пытаемся превратить в JSON — если получится
          if (rawText.trim() && rawText.startsWith('{')) {
            try {
              const parsed = JSON.parse(rawText);
              if (parsed && typeof parsed === 'object') {
                data = parsed;
                if (data?.comboReward) {
                  rewardData = data;
                }
              }
            } catch (e) {
              // Не JSON — нормально, бывает при ошибках
            }
          }
        } catch (e) {
          console.warn('Не удалось прочитать ответ сервера');
        }

        // === Перезарядка? Восстанавливаем! ===
        if (!response.ok && response.status === 400 && rawText.toLowerCase().includes('перезарядка')) {
          console.log(`Перезарядка ${displayName} — автоматически восстанавливаем`);

          status.textContent = `Перезарядка → восстанавливаю ${displayName}...`;

          const restoreResp = await fetch("https://oldprison-prod.luckygem.online/api/boss/restore-free-hit", {
            method: "POST",
            headers: { "content-type": "application/json", "authorization": token },
            body: JSON.stringify({ weaponType: w.restore })
          });

          if (!restoreResp.ok) {
            status.textContent = `Не удалось восстановить ${displayName}`;
            isRunning = false;
            break;
          }

          await new Promise(r => setTimeout(r, 1400 + Math.random() * 400));
          i--; // повторяем удар
          continue;
        }

        // === Любая другая ошибка — стоп комбо ===
        if (!response.ok || !data?.success || (data?.damage ?? 0) === 0) {
          status.textContent = `Комбо прервано на ${displayName}`;
          status.className = 'combo-status error';
          progress.textContent = `Ошибка: ${displayName}`;
          isRunning = false;
          executeBtn.disabled = false;
          stopBtn.style.opacity = '0.6';
          return;
        }

        if (i < currentCombo.length - 1) {
          await new Promise(r => setTimeout(r, delay));
        }
      }

      // === 2. Получаем количество оружия ПОСЛЕ комбо ===
      try {
        const initRes = await fetch('https://oldprison-prod.luckygem.online/api/player/init', {
          method: 'POST',
          headers: { 'authorization': token, 'content-type': 'application/json' }
        });
        if (initRes.ok) {
          const data = await initRes.json();
          if (data.success) {
            afterWeapons = {
              knife: data.knifeCount || 0,
              poison: data.poisonCount || 0,
              gunshot: data.gunshotCount || 0
            };
          }
        }
      } catch (e) {}

      isRunning = false;
      executeBtn.disabled = false;
      stopBtn.style.opacity = '0.6';
      status.textContent = `Комбо завершено! (${currentCombo.length} ударов)`;
      status.className = 'combo-status success';
      progress.textContent = 'Готово!';

      // === МОДАЛЬНОЕ ОКНО ===
      if (rewardData?.comboReward) {
        const r = rewardData.comboReward;
        const combo = rewardData.combo || {};

        const comboNames = {
          pacansky: "Пацанский",
          blotnoy:  "Блатной",
          avtoritetny: "Авторитетный"
        };
        const comboType = comboNames[combo.selectedType] || combo.selectedType || "Неизвестно";

        const currencies = r.currencies || [];
        const cigs = currencies.find(c => c.type === 'cigarettes')?.amount || 0;
        const rubles = currencies.find(c => c.type === 'rubles')?.amount || 0;
        const authority = r.authority || 0;
        const stashCount = r.stash?.count || 0;
        const tattoosCount = (r.tattoos || []).length;

        const weaponRewards = r.weapons || {};

        let rewardLines = [
          `<div style="font-size:18px;margin-bottom:12px;color:#60a5fa"><strong>Комбо: ${comboType}</strong></div>`
        ];

        if (authority > 0) rewardLines.push(`<div><strong>Авторитет:</strong> +${authority}</div>`);
        if (cigs > 0 || rubles > 0) {
          let currencyText = [];
          if (cigs > 0) currencyText.push(`+${cigs} папирос`);
          if (rubles > 0) currencyText.push(`+${rubles} ₽`);
          rewardLines.push(`<div><strong>Валюта:</strong> ${currencyText.join(', ')}</div>`);
        }
        if (stashCount > 0) rewardLines.push(`<div><strong>Нычки:</strong> +${stashCount} шт.</div>`);
        if (tattoosCount > 0) rewardLines.push(`<div><strong>Татуировки:</strong> +${tattoosCount} шт.</div>`);

        const statsHtml = (() => {
          if (!beforeWeapons || !afterWeapons) return '';

          // === Считаем, сколько потрачено в комбо ===
          const spent = { poison: 0, gunshot: 0, knife: 0 };
          currentCombo.forEach(move => {
            const w = weapons[move];
            if (w && !w.freeFirst) { // только платное оружие
              if (w.weapon === 'poison') spent.poison++;
              if (w.weapon === 'gunshot') spent.gunshot++;
              if (w.weapon === 'knife') spent.knife++;
            }
          });

          const format = n => n.toLocaleString('ru-RU');

          const weaponsList = [
            { key: 'poison',  name: 'Яд',      emoji: '☠️' },
            { key: 'gunshot', name: 'Самопал', emoji: '🔫' },
            { key: 'knife',   name: 'Финка',   emoji: '🔪' }
          ];

          let rows = '';

          weaponsList.forEach(w => {
            const was     = beforeWeapons[w.key] || 0;
            const now     = afterWeapons[w.key] || 0;
            const earned  = (weaponRewards[w.key] || 0);
            const used    = spent[w.key] || 0;
            const diff    = now - was;

            const diffColor = diff > 0 ? '#86efac' : diff < 0 ? '#fca5a5' : '#e2e8f0';

            rows += `
      <div style="display:grid;grid-template-columns:34px 1fr 1fr 1fr 1fr;gap:10px;align-items:center;padding:10px 0;border-bottom:1px solid #334155;font-size:14px;">
        <div style="font-size:22px;">${w.emoji}</div>
        <div style="color:#94a3b8;">${format(was)}</div>
        <div style="color:#fb923c;text-align:center;font-weight:600;">−${used}</div>
        <div style="color:#86efac;text-align:center;font-weight:600;">+${format(earned)}</div>
        <div style="color:${diffColor};font-weight:700;text-align:right;font-size:15px;">${format(now)}</div>
      </div>`;
          });

          return `
<div style="margin-top:20px;padding:16px;background:rgba(15,23,42,0.95);border-radius:12px;border:1px solid #475569;">
  <div style="color:#94a3b8;margin-bottom:14px;font-weight:600;font-size:15px;">Статистика по оружию</div>
  
  <div style="display:grid;grid-template-columns:34px 1fr 1fr 1fr 1fr;gap:10px;padding-bottom:8px;border-bottom:1px solid #475569;font-size:13px;color:#64748b;">
    <div></div>
    <div>Было</div>
    <div style="text-align:center;">Потрачено</div>
    <div style="text-align:center;">Получено</div>
    <div style="text-align:right;">Стало</div>
  </div>
  
  ${rows}
</div>`;
        })();

        showModal({
          title: 'Комбо выполнено! Награда',
          content: `
        <div style="text-align:center;font-family:system-ui;">
          <div style="font-size:32px;margin-bottom:8px;">Готово!</div>
          ${rewardLines.join('')}
          <div style="margin-top:16px;color:#94a3b8;font-size:14px;">
            Прогресс: ${combo.progress || 0}/${combo.required || 0}
          </div>
          ${statsHtml}
        </div>
      `,
          buttons: [{ label: 'Круто!', action: () => {} }]
        });
      }
    }

    // === ОБРАБОТЧИКИ ===
    executeBtn.onclick = executeCombo;
    stopBtn.onclick = () => {
      isRunning = false;
      status.textContent = `Остановлено на ${currentIndex + 1} ударе`;
      status.className = 'combo-status error';
      progress.textContent = `Остановлено: ${currentCombo[currentIndex] ? weapons[currentCombo[currentIndex]]?.name || currentCombo[currentIndex] : '—'}`;
      stopBtn.style.opacity = '0.6';
    };

    textarea.addEventListener('input', analyzeCombo);
    textarea.addEventListener('paste', () => setTimeout(analyzeCombo, 100));
    setTimeout(analyzeCombo, 200);
    renderSavedCombos();

    return div;
  }

  function createGadalkaContent() {
      const div = document.createElement('div');
      div.className = 'tab-content';
      div.id = 'gadalka-content';

      div.innerHTML = `
  <div class="gadalka-container">
      <p class="gadalka-description">
          Запусти бой с боссом.
          Если знаешь первые удары — введи их ниже (можно как угодно).
          Нажми «Начать» — буду продолжать со следующего.
      </p>

      <div style="margin: 16px 0;">
          <textarea id="known-prefix" placeholder="Введи известный префикс (можно как угодно: Грудь → Ухо, 1. Пах 2. Самопал, punchChest kneeEar и т.д.)" rows="3" style="resize:none;height:120px;width:100%; padding:8px; border-radius:8px; border:1px solid #475569; background:#1e293b; color:#e2e8f0;"></textarea>
      </div>
      
<div style="margin: 20px 0; padding: 12px; background: #1e293b; border-radius: 12px; border: 1px solid #475569; display: flex; flex-direction: column; align-items: center; gap: 10px;">
  <div class="toggle-container">
    <input type="checkbox" id="only-free-weapons" class="ios-toggle">
    <label for="only-free-weapons" class="ios-label">
      <span class="label-off">Все удары</span>
      <span class="label-on">Только Ухо/Пах/Глаза/Грудь</span>
      <span class="slider"></span>
    </label>
  </div>
  <div style="font-size: 0.82rem; color: #94a3b8; text-align: center;">
    Переключи, если Финка/Яд/Пал запрещены на боссе
  </div>
</div>

      <div class="gadalka-buttons">
          <button id="gadalka-start" class="gadalka-btn primary">Начать разгадку</button>
          <button id="gadalka-stop" class="gadalka-btn danger" disabled>Остановить</button>
          <button id="gadalka-reset" class="gadalka-btn secondary">Сбросить</button>
      </div>

      <div class="gadalka-progress">
          Прогресс: <strong id="gadalka-progress">— / —</strong>
      </div>

      <div class="gadalka-sequence-box">
          <div id="gadalka-sequence">—</div>
      </div>

      <div id="gadalka-status" class="gadalka-status">
          Готов начать...
      </div>
  </div>
`;

      const weapons = [
        { id: "kneeEar",    name: "Ухо", restore: "KneeEar", cost: 0 },
        { id: "kickBalls",  name: "Пах",        restore: "KickBalls", cost: 0 },
        { id: "pokeEyes",   name: "Глаза",      restore: "PokeEyes", cost: 0 },
        { id: "punchChest", name: "Грудь",      restore: "PunchChest", cost: 0 },
        { id: "poison",     name: "Яд",         restore: null, cost: 18 },
        { id: "knife",      name: "Финка",      restore: null, cost: 4 },
        { id: "gunshot",    name: "Самопал",    restore: null, cost: 5 }
      ];

    const FREE_WEAPONS = ["kneeEar", "kickBalls", "pokeEyes", "punchChest"];

      const weaponConfig = [
        { keys: ["ухо", "колено", "по уху", "в ухо"],           weapon: "kneeEar",    restore: "KneeEar",    name: "Ухо/Колено",    freeFirst: true,  cost: 3 },
        { keys: ["пах", "по яйцам", "в пах", "яйца"],          weapon: "kickBalls",  restore: "KickBalls",  name: "Пах",           freeFirst: true,  cost: 3 },
        { keys: ["глаза", "глаз", "палец в глаз", "по глазу", "в глаз", "тык в глаз"],
          weapon: "pokeEyes",   restore: "PokeEyes",   name: "Глаза",         freeFirst: true,  cost: 3 },
        { keys: ["грудь", "удар в грудь", "по груди", "в грудь", "кулаком в грудь"],
          weapon: "punchChest", restore: "PunchChest", name: "Грудь",         freeFirst: true,  cost: 3 },
        { keys: ["яд", "отравить", "ядом"],                   weapon: "poison",     restore: null,         name: "Яд",            freeFirst: false, cost: 18 },
        { keys: ["финка", "фин", "нож", "ножом", "финкой"],   weapon: "knife",      restore: null,         name: "Финка",         freeFirst: false, cost: 4 },
        { keys: ["самопал", "пал", "выстрел", "стрелять", "пистолет"],
          weapon: "gunshot",    restore: null,         name: "Самопал",       freeFirst: false, cost: 5 }
      ];

      const keyToId = {};
      weaponConfig.forEach(config => {
        config.keys.forEach(key => {
          keyToId[key.toLowerCase()] = config.weapon;
        });
      });

      function parsePrefix(text) {
        if (!text || !text.trim()) return [];

        const moves = [];

        text.split('\n').forEach(line => {
          if (!line.trim()) return;

          let cleaned = line.replace(/^\d+[\.\)\-\–\—\_\•\*]\s*/g, '').trim();
          const words = cleaned.split(/[\s,.;:!?()[\]{}—–\-_+/\\|]+/);

          words.forEach(word => {
            if (!word) return;

            let cleanWord = word.replace(/[^а-яА-ЯёЁ]/g, '').toLowerCase();
            if (cleanWord.length === 0) {
              const lettersOnly = word.match(/[а-яА-ЯёЁ]/g);
              if (lettersOnly) cleanWord = lettersOnly.join('').toLowerCase();
            }

            if (cleanWord && keyToId[cleanWord]) {
              moves.push(keyToId[cleanWord]);
            }
          });
        });

        return moves;
      }

      let isActive = false;
      let correctPrefix = [];
      let forbiddenByLength = new Map();
      let restoreCount = 0;
      let lastProgress = 0;

      const statusEl     = div.querySelector('#gadalka-status');
      const progressEl   = div.querySelector('#gadalka-progress');
      const sequenceEl   = div.querySelector('#gadalka-sequence');
      const startBtn     = div.querySelector('#gadalka-start');
      const stopBtn      = div.querySelector('#gadalka-stop');
      const resetBtn     = div.querySelector('#gadalka-reset');

    let onlyFreeMode = false;

    div.querySelector('#only-free-weapons').addEventListener('change', function(e) {
      onlyFreeMode = e.target.checked;
      if (!isActive) {
        setStatus(
          onlyFreeMode
            ? "Режим: только бесплатные удары"
            : "Режим: все удары разрешены",
          onlyFreeMode ? "#f59e0b" : "#94a3b8"
        );
      }
    });

      const DELAY_MS = 1000;

      function updateDisplay() {
        progressEl.textContent = `${correctPrefix.length} / ?`;
        sequenceEl.textContent = correctPrefix.length === 0
          ? '—'
          : correctPrefix.map(id => weapons.find(w => w.id === id)?.name || id).join(' → ');
      }

      function setStatus(text, color = '#94a3b8') {
        statusEl.textContent = text;
        statusEl.style.color = color;
      }

      async function makeHit(weaponId) {
        try {
          const res = await fetch("https://oldprison-prod.luckygem.online/api/boss/use-weapon", {
            method: "POST",
            headers: { "content-type": "application/json", "authorization": getAuthToken() },
            body: JSON.stringify({ weapon: weaponId })
          });

          if (!res.ok) {
            const text = await res.text();
            if (res.status === 400 && text.toLowerCase().includes('перезарядка')) {
              const cfg = weapons.find(w => w.id === weaponId);
              if (cfg?.restore) {
                setStatus(`Восстанавливаю ${cfg.name}...`, "#f59e0b");
                await fetch("https://oldprison-prod.luckygem.online/api/boss/restore-free-hit", {
                  method: "POST",
                  headers: { "content-type": "application/json", "authorization": getAuthToken() },
                  body: JSON.stringify({ weaponType: cfg.restore })
                });
                restoreCount++;
                await new Promise(r => setTimeout(r, DELAY_MS));
                return await makeHit(weaponId);
              }
            }
            return { success: false, data: null };
          }

          const data = await res.json();
          return { success: data.success && (data.damage ?? 0) > 0, data };
        } catch {
          return { success: false, data: null };
        }
      }

    function getNextWeapon() {
      const currentLength = correctPrefix.length;
      const lastId = correctPrefix.length > 0 ? correctPrefix.at(-1) : null;
      const forbiddenSet = forbiddenByLength.get(currentLength) || new Set();

      // ← Вот здесь выбираем, из какого набора брать кандидатов
      const available = onlyFreeMode
        ? weapons.filter(w => FREE_WEAPONS.includes(w.id))
        : weapons;

      let candidates = available.filter(w =>
        w.id !== lastId && !forbiddenSet.has(w.id)
      );

      // Если на этой позиции все уже запрещены — сбрасываем запрет
      if (candidates.length === 0) {
        forbiddenByLength.delete(currentLength);
        candidates = available.filter(w => w.id !== lastId);
      }

      if (candidates.length === 0) return null;

      // Случайный выбор из оставшихся
      return candidates[Math.floor(Math.random() * candidates.length)];
    }

      async function tryFindNext() {
        if (!isActive) return;

        let nextWeapon = getNextWeapon();
        if (!nextWeapon) {
          setStatus("Все варианты перепробованы... жду 3 сек", "#f59e0b");
          await new Promise(r => setTimeout(r, DELAY_MS * 3));
          tryFindNext();
          return;
        }

        if (correctPrefix.length > 0 && lastProgress === 0) {
          setStatus(`Повторяю префикс (${correctPrefix.length})...`, "#60a5fa");
          for (const weaponId of correctPrefix) {
            if (!isActive) return;
            await makeHit(weaponId);
            await new Promise(r => setTimeout(r, DELAY_MS));
          }
          nextWeapon = getNextWeapon();
          if (!nextWeapon) {
            setStatus("Все варианты перепробованы... жду 3 сек", "#f59e0b");
            await new Promise(r => setTimeout(r, DELAY_MS * 3));
            tryFindNext();
            return;
          }
        }

        setStatus(`Пробуем ${nextWeapon.name}...`, "#60a5fa");

        const result = await makeHit(nextWeapon.id);
        await new Promise(r => setTimeout(r, DELAY_MS));

        if (!result.success || !result.data?.combo) {
          setStatus("Ошибка. Проверяю снова...", "#ef4444");
          await new Promise(r => setTimeout(r, DELAY_MS * 2));
          tryFindNext();
          return;
        }

        const combo = result.data.combo;
        const { progress, required, lastOutcome } = combo;

        progressEl.textContent = `${progress} / ${required}`;
        lastProgress = progress;

        if (progress >= required) {
          setStatus("Комбо разгадано!", "#34d399");
          isActive = false;
          startBtn.disabled = false;
          stopBtn.disabled = true;

          // Формируем полный финальный массив ударов (префикс + последний успешный удар)
          const fullSequence = [...correctPrefix];
          if ((lastOutcome === "completed" || lastOutcome === "hit") && nextWeapon) {
            fullSequence.push(nextWeapon.id);
          }

          // Подсчёт использованных премиум-ударов
          let poisonUsed = 0, knifeUsed = 0, gunshotUsed = 0;
          fullSequence.forEach(id => {
            if (id === "poison") poisonUsed++;
            if (id === "knife") knifeUsed++;
            if (id === "gunshot") gunshotUsed++;
          });

          // Затраты
          const restoreCost = restoreCount * 3;
          const poisonCost = poisonUsed * 18;
          const knifeCost = knifeUsed * 4;
          const gunshotCost = gunshotUsed * 5;
          const totalCost = restoreCost + poisonCost + knifeCost + gunshotCost;

          // Текст комбо
          const comboText = fullSequence.map(id => weapons.find(w => w.id === id)?.name || id).join(" → ");

          // Награда
          let rewardText = "Награда не пришла";
          if (result.data.comboReward) {
            const r = result.data.comboReward;
            rewardText = `
            Тип: ${r.selectedType || "—"}<br>
            Авторитет: +${r.authority || 0}<br>
            Папиросы: +${r.currencies?.find(c => c.type === 'cigarettes')?.amount || 0}<br>
            Рубли: +${r.currencies?.find(c => c.type === 'rubles')?.amount || 0}<br>
            Нычки: +${r.stash?.count || 0}<br>
            Тату: +${r.tattoos?.length || 0}
          `;
          }

          // Разбивка затрат
          const costItems = [];
          if (restoreCost > 0) costItems.push(`Восстановления: ${restoreCount} × 3₽ = ${restoreCost}₽`);
          if (poisonUsed > 0) costItems.push(`Яд: ${poisonUsed} × 18₽ = ${poisonCost}₽`);
          if (knifeUsed > 0) costItems.push(`Финка: ${knifeUsed} × 4₽ = ${knifeCost}₽`);
          if (gunshotUsed > 0) costItems.push(`Самопал: ${gunshotUsed} × 5₽ = ${gunshotCost}₽`);

          const costDetails = costItems.length > 0
            ? costItems.join("<br>")
            : "Премиум-удары и восстановления не использовались";

          showModal({
            title: "Комбо разгадано!",
            content: `
            <div style="font-size:1.4rem; margin:20px 0; line-height:1.6;">
              ${comboText}
            </div>

            <div style="background:#1e293b; padding:12px; border-radius:8px; margin:16px 0; color:#e2e8f0;">
              <div style="font-weight:bold; color:#fbbf24; margin-bottom:8px; font-size:1.1rem;">
                Общая стоимость разгадки: ${totalCost}₽
              </div>
              ${costDetails}
            </div>

            <div style="color:#94a3b8; line-height:1.5;">
              ${rewardText}
            </div>

            <div style="margin-top:16px; color:#64748b; font-size:0.9rem;">
              Длина комбо: ${required}<br>
              Всего ударов: ${fullSequence.length}
            </div>
          `,
            buttons: [
              { label: "Копировать комбо", action: () => navigator.clipboard.writeText(comboText) },
              { label: "Закрыть" }
            ]
          });

          return;
        }

        const currentLength = correctPrefix.length;

        if (lastOutcome === "hit" || lastOutcome === "completed") {
          correctPrefix.push(nextWeapon.id);
          setStatus(`Верно! Добавлено: ${nextWeapon.name}`, "#34d399");
        } else {
          if (!forbiddenByLength.has(currentLength)) forbiddenByLength.set(currentLength, new Set());
          forbiddenByLength.get(currentLength).add(nextWeapon.id);
          setStatus(`Неверно (${nextWeapon.name}) → повторяю префикс`, "#f59e0b");
        }

        updateDisplay();

        if (isActive) setTimeout(tryFindNext, DELAY_MS);
      }

      startBtn.onclick = async () => {
        isActive = true;
        startBtn.disabled = true;
        stopBtn.disabled = false;

        const inputText = div.querySelector('#known-prefix').value.trim();
        correctPrefix = parsePrefix(inputText);

        forbiddenByLength.clear();
        restoreCount = 0;
        lastProgress = 0;
        setStatus(`Разгадка начата с префикса (${correctPrefix.length})...`, "#60a5fa");
        updateDisplay();

        if (correctPrefix.length > 0) {
          setStatus(`Пробиваю известный префикс (${correctPrefix.length})...`, "#60a5fa");
          for (const weaponId of correctPrefix) {
            if (!isActive) return;
            const result = await makeHit(weaponId);
            await new Promise(r => setTimeout(r, DELAY_MS));

            if (!result.success || !result.data?.combo || result.data.combo.lastOutcome !== "hit") {
              setStatus("Префикс не прошёл на сервере! Останавливаюсь", "#ef4444");
              isActive = false;
              startBtn.disabled = false;
              return;
            }
          }
          setStatus("Префикс успешно загружен! Продолжаю...", "#34d399");
        }

        tryFindNext();
      };

      stopBtn.onclick = () => {
        isActive = false;
        startBtn.disabled = false;
        stopBtn.disabled = true;
        setStatus("Остановлено", "#f87171");
      };

      resetBtn.onclick = () => {
        if (!confirm("Сбросить?")) return;
        correctPrefix = [];
        forbiddenByLength.clear();
        restoreCount = 0;
        lastProgress = 0;
        div.querySelector('#known-prefix').value = '';
        updateDisplay();
        setStatus("Сброшено", "#94a3b8");
      };

      updateDisplay();

      return div;
    }

  function createTattooClothesContent() {
    const div = document.createElement('div');
    div.className = 'tab-content';
    div.id = 'tattoo-content';

    // Контейнер для двух кнопок
    const buttonsContainer = document.createElement('div');
    buttonsContainer.className = 'tattoo-buttons-container';
    buttonsContainer.style.display = 'flex';
    buttonsContainer.style.gap = '12px';

    // Кнопка тату
    const viewTattooBtn = document.createElement('button');
    viewTattooBtn.textContent = '🎭 Посмотреть тату';
    viewTattooBtn.className = 'tattoo-action-btn tattoo';
    viewTattooBtn.onclick = () => initTattooPanel();

    // Кнопка шмота
    const viewClothingBtn = document.createElement('button');
    viewClothingBtn.textContent = '👕 Глянуть шмот';
    viewClothingBtn.className = 'tattoo-action-btn clothes';
    viewClothingBtn.onclick = () => initClothingPanel();

    buttonsContainer.append(viewTattooBtn, viewClothingBtn);
    div.appendChild(buttonsContainer);

    return div;
  }

  function createTalentsContent() {
    const div = document.createElement('div');
    div.className = 'tab-content';
    div.id = 'talents-content';

    const wrapper = document.createElement('div');
    wrapper.className = 'center-wrapper';

    // Кнопка загрузки
    const loadBtn = document.createElement('button');
    loadBtn.textContent = '🔄 Обновить таланты';
    loadBtn.className = 'load-btn';
    loadBtn.onclick = loadTalents;
    wrapper.appendChild(loadBtn);

    const resetBtn = document.createElement('button');
    resetBtn.id = 'reset-talents-btn';
    resetBtn.innerHTML = `
    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 6px;">
      <path d="M12 5V1L7 6h10L12 1zm-7.71 7.71a5.98 5.98 0 0 1-2.29-4.71A6.008 6.008 0 0 1 12 2a6.008 6.008 0 0 1 9.99 4.71 5.98 5.98 0 0 1-2.29 4.71A7.12 7.12 0 0 1 18 13v3h-2v-3a5 5 0 0 0-10 0v3H6v-3a7.12 7.12 0 0 1 1.29-4.29z"/>
    </svg>
    Сбросить все таланты
  `;
    resetBtn.className = 'reset-talents-btn';
    resetBtn.onclick = resetAllTalents;
    wrapper.appendChild(resetBtn);

    // Подпись о стоимости
    const costLabel = document.createElement('div');
    costLabel.className = 'reset-cost-label';
    costLabel.textContent = '💰 Стоимость сброса = 3 рубля';
    wrapper.appendChild(costLabel);

    // Контейнер талантов
    const container = document.createElement('div');
    container.id = 'talents-container';
    container.className = 'talents-container';
    container.innerHTML = '<div style="text-align:center; color:#94a3b8; padding:20px;">Нажмите "Обновить таланты", чтобы загрузить данные</div>';
    wrapper.appendChild(container);

    div.appendChild(wrapper);
    return div;
  }

  function createWeaponContent() {
    const div = document.createElement('div');
    div.className = 'tab-content';
    div.id = 'weapon-content';

    div.innerHTML = `
    <div class="center-wrapper">
      
      <button id="weapon-refresh-btn" class="load-btn" style="width:100%; max-width:340px; margin-bottom:20px; background:linear-gradient(135deg,#64748b,#475569); font-size:15px;">
        Обновить информацию
      </button>

      <div id="weapon-info-block" style="
        width:100%; max-width:340px; padding:18px 20px; background:rgba(30,41,59,0.6);
        border:1px solid #475569; border-radius:16px; font-family:system-ui; line-height:1.9;
        color:#e2e8f0; font-size:14px; backdrop-filter:blur(4px);
      ">
        <!-- Количество -->
        <div style="display:grid; grid-template-columns:1fr auto; gap:8px 12px; align-items:center;">
          <div>Количество Ядов</div>
          <div id="poison-count" style="font-weight:700; color:#86efac; text-align:right;">—</div>
          
          <div>Количество Самопалов</div>
          <div id="gunshot-count" style="font-weight:700; color:#86efac; text-align:right;">—</div>
          
          <div>Количество Финок</div>
          <div id="knife-count" style="font-weight:700; color:#86efac; text-align:right;">—</div>
        </div>

        <!-- Урон за 1 шт. -->
        <div style="margin-top:20px; padding-top:16px; border-top:1px solid #475569; 
                   display:grid; grid-template-columns:1fr auto; gap:8px 12px; align-items:center;">
          <div>Урон 1 шт. Яда</div>
          <div id="poison-damage" style="font-weight:700; color:#fca5a5; text-align:right;">—</div>
          
          <div>Урон 1 шт. Самопала</div>
          <div id="gunshot-damage" style="font-weight:700; color:#fca5a5; text-align:right;">—</div>
          
          <div>Урон 1 шт. Финки</div>
          <div id="knife-damage" style="font-weight:700; color:#fca5a5; text-align:right;">—</div>
        </div>

        <!-- Общий урон -->
        <div style="margin-top:20px; padding:20px; background:rgba(15,23,42,0.8); 
                   border-radius:14px; border:1px solid #475569;">
          <div style="font-weight:700; color:#a78bfa; margin-bottom:12px; text-align:center; font-size:15px;">
            Общий урон с имеющегося оружия
          </div>

          <div style="display:grid; grid-template-columns:1fr auto; gap:8px 12px; font-size:13px;">
            <div>▸ Общий урон с Ядов</div>
            <div id="total-poison" style="font-weight:700; color:#86efac; text-align:right;">—</div>
            
            <div>▸ Общий урон с Самопалов</div>
            <div id="total-gunshot" style="font-weight:700; color:#86efac; text-align:right;">—</div>
            
            <div>▸ Общий урон с Финок</div>
            <div id="total-knife" style="font-weight:700; color:#86efac; text-align:right;">—</div>
          </div>

          <div style="margin-top:16px; padding-top:14px; border-top:1px dashed #475569; 
                     text-align:center; font-size:16px; color:#c4b5fd;">
            <strong>ИТОГО:</strong> 
            <span id="total-all-damage" style="font-weight:900; color:#fbbf24;">—</span>
          </div>
        </div>
      </div>
    </div>
  `;

    const refreshBtn = div.querySelector('#weapon-refresh-btn');

    const updateDisplay = (data) => {
      if (!data) return;

      const poisonCount = data.poisonCount || 0;
      const gunshotCount = data.gunshotCount || 0;
      const knifeCount = data.knifeCount || 0;

      const poisonDmg = data.combatStats?.poison || 0;
      const gunshotDmg = data.combatStats?.gunshot || 0;
      const knifeDmg = data.combatStats?.knife || 0;

      // Количество
      div.querySelector('#poison-count').textContent = poisonCount.toLocaleString();
      div.querySelector('#gunshot-count').textContent = gunshotCount.toLocaleString();
      div.querySelector('#knife-count').textContent = knifeCount.toLocaleString();

      // Урон за единицу
      div.querySelector('#poison-damage').textContent = poisonDmg.toLocaleString();
      div.querySelector('#gunshot-damage').textContent = gunshotDmg.toLocaleString();
      div.querySelector('#knife-damage').textContent = knifeDmg.toLocaleString();

      // Общий урон по типам
      const totalPoison = poisonCount * poisonDmg;
      const totalGunshot = gunshotCount * gunshotDmg;
      const totalKnife = knifeCount * knifeDmg;
      const totalAll = totalPoison + totalGunshot + totalKnife;

      div.querySelector('#total-poison').textContent = totalPoison.toLocaleString();
      div.querySelector('#total-gunshot').textContent = totalGunshot.toLocaleString();
      div.querySelector('#total-knife').textContent = totalKnife.toLocaleString();
      div.querySelector('#total-all-damage').textContent = totalAll.toLocaleString();
    };

    async function loadWeaponStats() {
      refreshBtn.disabled = true;
      refreshBtn.textContent = 'Загрузка...';

      try {
        const token = getAuthToken();
        const res = await fetch('https://oldprison-prod.luckygem.online/api/player/init', {
          method: 'POST',
          headers: {
            'authorization': token,
            'content-type': 'application/json'
          }
        });

        if (!res.ok) throw new Error(`HTTP ${res.status}`);

        const data = await res.json();
        if (data.success) {
          updateDisplay(data);
        } else {
          showError('Ошибка', 'Не удалось получить данные');
        }
      } catch (err) {
        showError('Ошибка', err.message || 'Неизвестная ошибка');
      } finally {
        refreshBtn.disabled = false;
        refreshBtn.textContent = 'Обновить информацию';
      }
    }

    refreshBtn.onclick = loadWeaponStats;

    // Автозагрузка при открытии вкладки
    const observer = new MutationObserver((mutations) => {
      for (const m of mutations) {
        if (m.target.classList?.contains('active') && m.target.id === 'weapon-content') {
          loadWeaponStats();
          break;
        }
      }
    });
    observer.observe(div, { attributes: true, attributeFilter: ['class'] });

    return div;
  }

  function createCalculatorContent() {
    const div = document.createElement('div');
    div.className = 'tab-content';
    div.id = 'calculator-content';

    div.innerHTML = `
  <div class="center-wrapper">
    <div class="calculator-wrapper">
      <div class="calc-card">
        <!-- Яд -->
        <div class="calc-item">
          <label class="calc-label">Количество Яда в шт.</label>
          <div class="calc-input-group">
            <input type="number" id="calc-poison" class="calc-input" min="0" value="0" placeholder="0">
            <div class="calc-cost">= <span id="cost-poison">0</span> ₽</div>
          </div>
          <div class="calc-price-note">Стоимость 1 шт. = 18 руб.</div>
        </div>

        <!-- Самопал -->
        <div class="calc-item">
          <label class="calc-label">Количество Самопалов в шт.</label>
          <div class="calc-input-group">
            <input type="number" id="calc-gunshot" class="calc-input" min="0" value="0" placeholder="0">
            <div class="calc-cost">= <span id="cost-gunshot">0</span> ₽</div>
          </div>
          <div class="calc-price-note">Стоимость 1 шт. = 5 руб.</div>
        </div>

        <!-- Финки -->
        <div class="calc-item">
          <label class="calc-label">Количество Финок в шт.</label>
          <div class="calc-input-group">
            <input type="number" id="calc-knife" class="calc-input" min="0" value="0" placeholder="0">
            <div class="calc-cost">= <span id="cost-knife">0</span> ₽</div>
          </div>
          <div class="calc-price-note">Стоимость 1 шт. = 4 руб.</div>
        </div>

        <!-- Итоговая стоимость -->
        <div class="calc-total-cost">
          <div class="calc-total-label">Общая стоимость</div>
          <div class="calc-total-value" id="total-cost">0 ₽</div>
        </div>

        <!-- Итоговый урон -->
        <div class="calc-damage-block">
          <div class="calc-damage-title">Сможешь нанести общего урона</div>
          <div class="calc-damage-value" id="total-damage">0</div>
        </div>
      </div>
    </div>
  </div>
  `;

    const PRICES = { poison: 18, gunshot: 5, knife: 4 };
    let damagePerHit = { poison: 0, gunshot: 0, knife: 0 };

    const inputs = {
      poison: div.querySelector('#calc-poison'),
      gunshot: div.querySelector('#calc-gunshot'),
      knife: div.querySelector('#calc-knife')
    };

    const outputs = {
      costPoison: div.querySelector('#cost-poison'),
      costGunshot: div.querySelector('#cost-gunshot'),
      costKnife: div.querySelector('#cost-knife'),
      totalCost: div.querySelector('#total-cost'),
      totalDamage: div.querySelector('#total-damage')
    };

    function recalculate() {
      const p = parseInt(inputs.poison.value) || 0;
      const g = parseInt(inputs.gunshot.value) || 0;
      const k = parseInt(inputs.knife.value) || 0;

      const costP = p * PRICES.poison;
      const costG = g * PRICES.gunshot;
      const costK = k * PRICES.knife;
      const totalCost = costP + costG + costK;
      const damage = p * damagePerHit.poison + g * damagePerHit.gunshot + k * damagePerHit.knife;
      const formattedDamage = damage.toLocaleString('ru-RU');
      const digitLength = formattedDamage.replace(/\s/g, '').length;

      // Обновляем стоимость
      outputs.costPoison.textContent = costP.toLocaleString();
      outputs.costGunshot.textContent = costG.toLocaleString();
      outputs.costKnife.textContent = costK.toLocaleString();
      outputs.totalCost.textContent = totalCost.toLocaleString() + ' ₽';

      outputs.totalDamage.textContent = formattedDamage;
      outputs.totalDamage.setAttribute('data-length', digitLength);
    }

    async function loadDamageStats() {
      try {
        const token = getAuthToken();
        const res = await fetch('https://oldprison-prod.luckygem.online/api/player/init', {
          method: 'POST',
          headers: { 'authorization': token, 'content-type': 'application/json' }
        });
        if (!res.ok) return;

        const data = await res.json();
        if (data.success && data.combatStats) {
          damagePerHit.poison = data.combatStats.poison || 0;
          damagePerHit.gunshot = data.combatStats.gunshot || 0;
          damagePerHit.knife = data.combatStats.knife || 0;
          recalculate();
        }
      } catch (e) {
        console.warn('Не удалось загрузить урон для калькулятора');
      }
    }

    Object.values(inputs).forEach(input => {
      input.addEventListener('input', recalculate);
      input.addEventListener('change', recalculate);
    });

    const observer = new MutationObserver((mutations) => {
      for (const m of mutations) {
        if (m.target.classList?.contains('active') && m.target.id === 'calculator-content') {
          loadDamageStats();
          observer.disconnect();
        }
      }
    });
    observer.observe(div, { attributes: true, attributeFilter: ['class'] });

    loadDamageStats();

    return div;
  }

    function createZShContent() {
      const div = document.createElement('div');
      div.className = 'tab-content';
      div.id = 'zsh-content';

      const title = document.createElement('h3');
      title.textContent = 'Заныканный шмот (Барыга)';
      title.style.cssText = 'margin: 0 0 20px; color: #60a5fa; text-align: center;';
      div.appendChild(title);

      const inputContainer = document.createElement('div');
      inputContainer.style.cssText = 'display: flex; flex-direction: column; align-items: center; gap: 12px; margin-bottom: 20px;';

      const label = document.createElement('label');
      label.textContent = 'Сколько раз купить:';
      label.style.cssText = 'color: #cbd5e1; font-weight: 600;';
      inputContainer.appendChild(label);

      const input = document.createElement('input');
      input.type = 'number';
      input.min = '1';
      input.value = '1';
      input.placeholder = 'Количество покупок';
      input.style.cssText = `
    width: 180px;
    padding: 12px;
    font-size: 16px;
    border-radius: 12px;
    border: 1px solid #475569;
    background: #0f172a;
    color: white;
    text-align: center;
  `;
      inputContainer.appendChild(input);

      const buyBtn = document.createElement('button');
      buyBtn.textContent = 'Купить';
      buyBtn.className = 'combo-execute-btn';
      buyBtn.style.cssText = `
    padding: 14px 32px;
    font-size: 16px;
    font-weight: 700;
    background: linear-gradient(135deg, #f59e0b, #d97706);
    color: white;
    border: none;
    border-radius: 50px;
    cursor: pointer;
    box-shadow: 0 6px 20px rgba(245, 158, 11, 0.4);
    transition: all 0.25s;
  `;
      buyBtn.onmouseover = () => {
        buyBtn.style.transform = 'scale(1.06)';
        buyBtn.style.boxShadow = '0 10px 30px rgba(245, 158, 11, 0.6)';
      };
      buyBtn.onmouseout = () => {
        buyBtn.style.transform = '';
        buyBtn.style.boxShadow = '0 6px 20px rgba(245, 158, 11, 0.4)';
      };

      inputContainer.appendChild(buyBtn);
      div.appendChild(inputContainer);

      const infoText = document.createElement('div');
      infoText.textContent = 'Стоимость первой покупки = 8 Бумаги';
      infoText.style.cssText = 'text-align: center; color: #94a3b8; font-size: 13px; margin: 8px 0 24px;';
      div.appendChild(infoText);

      buyBtn.onclick = async () => {
        const countStr = input.value.trim();
        const count = parseInt(countStr);

        if (!count || count < 1 || isNaN(count)) {
          return showError('Ошибка', 'Введите корректное количество (≥1)');
        }

        const token = getAuthToken();
        if (!token) return showError('Ошибка', 'Токен авторизации не найден');

        const results = [];

        let totalBought = 0;
        let totalPaperSpent = 0;
        let stoppedDueToPaper = false;

        let nextDiscount = null;

        for (let i = 0; i < count; i++) {
          try {
            const res = await fetch('https://oldprison-prod.luckygem.online/api/stashgear/baryga/spin', {
              method: 'POST',
              headers: {
                'authorization': token,
                'content-type': 'application/json'
              },
              body: JSON.stringify({})
            });

            if (!res.ok) {
              showError('Ошибка сервера', `HTTP ${res.status}`);
              break;
            }

            const data = await res.json();

            if (!data.success) {
              showError('Ошибка', data.message || 'Не удалось совершить покупку');
              break;
            }

            const price = data.price || 0;
            const itemName = data.dropped?.name || '???';
            const discountNext = data.discount || 0;

            results.push({
              price,
              itemName,
              discountNext,
              purchaseNumber: i + 1
            });

            totalBought++;
            totalPaperSpent += price;

            nextDiscount = discountNext;

            if (data.paperLeft !== undefined && data.paperLeft < 2) {
              stoppedDueToPaper = true;
              break;
            }

          } catch (err) {
            console.error(err);
            showError('Сетевая ошибка', 'Не удалось выполнить запрос');
            break;
          }
        }

        if (results.length === 0) {
          if (totalPaperSpent === 0) {
            showError('Недостаточно бумаги', 'У вас недостаточно Бумаги для первой покупки');
          }
          return;
        }

        let blocksHtml = results.map(r => `
    <div style="
      background: rgba(30,41,59,0.7);
      border: 1px solid #475569;
      border-radius: 10px;
      padding: 12px 16px;
      margin: 10px 0;
      font-size: 14px;
      line-height: 1.5;
    ">
      <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
        <span style="color: #94a3b8; font-weight: 500;">Покупка #${r.purchaseNumber}</span>
        <span style="color: #f59e0b; font-weight: 600;">${r.price} бумаги</span>
      </div>
      <div style="color: #60a5fa; font-weight: 600; margin: 4px 0;">
        ${r.itemName}
      </div>
      <div style="color: #94a3b8; font-size: 13px;">
        Скидка на следующую: <strong style="color: #fbbf24;">${r.discountNext}%</strong>
      </div>
    </div>
  `).join('');

        const summaryHtml = `
    <div style="margin-top: 24px; padding-top: 16px; border-top: 2px dashed #475569; text-align: center;">
      <div style="font-size: 17px; color: #86efac; margin-bottom: 10px; font-weight: 600;">
        Всего куплено: ${totalBought} шт.
      </div>
      <div style="font-size: 17px; color: #fca5a5; font-weight: 600;">
        Потрачено: ${totalPaperSpent} бумаги
      </div>
    </div>
  `;

        let finalMessage = blocksHtml + summaryHtml;

        if (stoppedDueToPaper) {
          finalMessage += `
      <div style="margin-top: 20px; padding: 12px; background: rgba(248,113,113,0.15); border: 1px solid #f87171; border-radius: 10px; color: #fca5a5; text-align: center; font-weight: 600;">
        Покупка остановлена — закончилась бумага
      </div>
    `;
        }

        if (nextDiscount !== null) {
          finalMessage += `
      <div style="margin-top: 16px; text-align: center; color: #94a3b8; font-size: 14px;">
        Текущая скидка на следующую покупку: <strong style="color: #fbbf24;">${nextDiscount}%</strong>
      </div>
    `;
        }

        showModal({
          title: 'Результаты покупок ЗШ',
          content: `<div style="max-height: 380px; overflow-y: auto; padding-right: 8px;">${finalMessage}</div>`,
          buttons: [{ label: 'Закрыть', action: () => {} }],
          closable: true,
          allowOutsideClick: true
        });

        if (stoppedDueToPaper && totalBought < count) {
          setTimeout(() => {
            showError('Закончилась бумага', 'Покупка остановлена — у вас закончилась Бумага');
          }, 900);
        }
      };

      return div;
    }

    /** Зарубы **/

    window.currentZarubaMode = null;
    window.currentZarubaModeData = null;

    const MODE_INFO = {
      1: { name: 'Пацанские', requiredLevel: 1 },
      2: { name: 'Блатные', requiredLevel: 210 },
      3: { name: 'Авторитетные', requiredLevel: 300 }
    };

    function createZarubaContent() {
      const div = document.createElement('div');
      div.className = 'tab-content';
      div.id = 'zaruba-content';

      const container = document.createElement('div');
      container.style.cssText = `
    background: rgba(30,41,59,0.7);
    border-radius: 16px;
    padding: 16px; /* уменьшил паддинг */
    border: 1px solid #475569;
    box-shadow: 0 4px 20px rgba(0,0,0,0.4);
    color: #e2e8f0;
    font-family: system-ui;
  `;

      container.innerHTML = `
    <div style="text-align:center; margin-bottom:12px;">
      <div style="font-size:18px; font-weight:800; color:#a78bfa; margin-bottom:4px;">
        🔥 Зарубы
      </div>
      <div style="font-size:13px; color:#94a3b8;">Текущий прогресс и лимиты</div>
    </div>
  `;

      const statusBlock = document.createElement('div');
      statusBlock.style.cssText = `
    background: rgba(15,23,42,0.8);
    border-radius: 10px;
    padding: 12px;
    margin-bottom: 12px;
    border: 1px solid #475569;
    text-align: center;
  `;
      statusBlock.innerHTML = `
    <div style="font-size:15px; font-weight:700; color:#60a5fa; margin-bottom:6px;">
      Статус: <span id="zaruba-active" style="color:#fbbf24;">—</span>
    </div>
    <div style="margin:8px 0;">
      <div style="font-size:12px; color:#94a3b8; margin-bottom:4px;">Прогресс уровня</div>
      <div style="background:#334155; height:8px; border-radius:4px; overflow:hidden;">
        <div id="zaruba-progress-fill" style="height:100%; background:linear-gradient(90deg,#8b5cf6,#a78bfa); width:0%; transition:width 0.6s ease;"></div>
      </div>
      <div style="font-size:13px; margin-top:4px;">
        Ур. <span id="zaruba-level">—</span> • <span id="zaruba-xp">—</span> / <span id="zaruba-need">—</span>
      </div>
    </div>
  `;
      container.appendChild(statusBlock);

      const infoRow = document.createElement('div');
      infoRow.style.cssText = `
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    margin-bottom: 12px;
    justify-content: center;
  `;

      const balancesBlock = document.createElement('div');
      balancesBlock.style.cssText = `
    display: flex;
    gap: 12px;
    flex: 1;
    min-width: 220px;
  `;
      balancesBlock.innerHTML = `
  <div style="flex:1; background:#1e293b; padding:10px; border-radius:10px; border:1px solid #475569; text-align:center;">
    <div style="font-size:12px; color:#94a3b8; margin-bottom:2px;">Печатки</div>
    <div id="zaruba-signet" style="font-size:18px; font-weight:800; color:#fbbf24;">—</div>
  </div>
  <div style="flex:1; background:#1e293b; padding:10px; border-radius:10px; border:1px solid #475569; text-align:center;">
    <div style="font-size:12px; color:#94a3b8; margin-bottom:2px;">Руд. печатки</div>
    <div id="zaruba-ore-signet" style="font-size:18px; font-weight:800; color:#a78bfa;">—</div>
    <button id="zaruba-exchange-btn" style="margin-top:8px; padding:6px 12px; background:linear-gradient(135deg,#a78bfa,#60a5fa); color:white; border:none; border-radius:8px; cursor:pointer; font-weight:700; font-size:12px;">
      Переплавить
    </button>
  </div>
`;

      const limitsBlock = document.createElement('div');
      limitsBlock.style.cssText = `
    display: flex;
    gap: 12px;
    flex: 1;
    min-width: 220px;
  `;
      limitsBlock.innerHTML = `
    <div style="flex:1; background:#1e293b; padding:10px; border-radius:10px; border:1px solid #475569; text-align:center;">
      <div style="font-size:12px; color:#94a3b8;">Блатной</div>
      <div style="font-size:18px; font-weight:700; color:#fbbf24;">
        <span id="zaruba-blat-used">—</span> / <span id="zaruba-blat-max">—</span>
      </div>
    </div>
    <div style="flex:1; background:#1e293b; padding:10px; border-radius:10px; border:1px solid #475569; text-align:center;">
      <div style="font-size:12px; color:#94a3b8;">Авторитетный</div>
      <div style="font-size:18px; font-weight:700; color:#a78bfa;">
        <span id="zaruba-avt-used">—</span> / <span id="zaruba-avt-max">—</span>
      </div>
    </div>
  `;

      infoRow.appendChild(balancesBlock);
      infoRow.appendChild(limitsBlock);

      container.appendChild(infoRow);

      const modesBlock = document.createElement('div');
      modesBlock.id = 'zaruba-modes';
      modesBlock.style.cssText = `
    display: flex;
    flex-direction: column;
    gap: 10px;
  `;
      container.appendChild(modesBlock);

      div.appendChild(container);

      const exchangeBtn = div.querySelector('#zaruba-exchange-btn');
      if (exchangeBtn) {
        exchangeBtn.onclick = () => {
          exchangeOreSignets();
        };
      }
      return div;
    }
    async function loadZarubaData() {
      const token = getAuthToken();
      if (!token) {
        showError('Ошибка', 'Токен не найден');
        return;
      }

      try {
        const res = await fetch('https://oldprison-prod.luckygem.online/api/zaruba/state', {
          headers: { 'authorization': token }
        });

        if (!res.ok) throw new Error(`HTTP ${res.status}`);

        const data = await res.json();
        window.zarubaData = data;
        window.zarubaDataLoaded = true;

        renderZarubaData(data);

      } catch (err) {
        console.error('Ошибка загрузки Заруб:', err);
        document.querySelector('#zaruba-active').textContent = 'Ошибка загрузки';
      }
    }
    function renderZarubaData(data) {
      document.querySelector('#zaruba-active').textContent = data.active ? 'Активен' : 'Не активен';

      if (data.progress) {
        const prog = data.progress;
        const percent = (prog.xp / prog.need) * 100;
        document.querySelector('#zaruba-level').textContent = prog.level;
        document.querySelector('#zaruba-xp').textContent = prog.xp.toLocaleString();
        document.querySelector('#zaruba-need').textContent = prog.need.toLocaleString();
        document.querySelector('#zaruba-progress-fill').style.width = `${percent}%`;
      }

      if (data.balances) {
        document.querySelector('#zaruba-signet').textContent = data.balances.signet.toLocaleString();
        document.querySelector('#zaruba-ore-signet').textContent = data.balances.ore_signet.toLocaleString();
      }

      if (data.limits) {
        const blat = data.limits.blat;
        const avt = data.limits.avtoritet;
        document.querySelector('#zaruba-blat-used').textContent = blat.used;
        document.querySelector('#zaruba-blat-max').textContent = blat.max;
        document.querySelector('#zaruba-avt-used').textContent = avt.used;
        document.querySelector('#zaruba-avt-max').textContent = avt.max;
      }

      const modesContainer = document.querySelector('#zaruba-modes');
      modesContainer.innerHTML = '';

      if (window.currentZarubaMode && window.currentZarubaModeData) {
        renderTasks(window.currentZarubaModeData);
        return;
      }

      if (data.modes && data.modes.length) {
        data.modes.forEach(mode => {
          const info = MODE_INFO[mode.mode] || { name: `Режим ${mode.mode}`, requiredLevel: null };
          const unlocked = mode.unlocked;
          const reward = mode.rewardSignet;

          const card = document.createElement('div');
          card.style.cssText = `
        background: linear-gradient(135deg, ${unlocked ? '#1e3a2f' : '#1e293b'}, #0f172a);
        border: 1px solid ${unlocked ? '#10b981' : '#475569'};
        border-radius: 16px;
        padding: 16px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        display: flex;
        flex-direction: column;
        gap: 8px;
        position: relative;
        overflow: hidden;
        transition: transform 0.2s, box-shadow 0.2s;
      `;
          card.onmouseover = () => { card.style.transform = 'translateY(-4px)'; card.style.boxShadow = '0 8px 30px rgba(0,0,0,0.4)'; };
          card.onmouseout = () => { card.style.transform = 'translateY(0)'; card.style.boxShadow = '0 4px 20px rgba(0,0,0,0.3)'; };

          card.innerHTML = `
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div style="font-size:18px; font-weight:800; color:${unlocked ? '#10b981' : '#60a5fa'};">
            ${info.name}
            ${unlocked ? ' <span style="color:#10b981;">✓</span>' : ' <span style="color:#ef4444;">🔒</span>'}
          </div>
          <div style="font-size:14px; font-weight:700; color:#fbbf24;">
            ${unlocked ? 'Доступен' : 'Закрыт'}
          </div>
        </div>

        <div style="font-size:13px; color:#94a3b8;">
          Награда: <span style="color:#fbbf24; font-weight:700;">${reward} печат.</span>
        </div>

        <div style="font-size:12px; color:#64748b;">
          ${info.requiredLevel === 1 ? 'Открыт с 1 уровня' : `Нужен ${info.requiredLevel} уровень Заруб`}
        </div>

        ${unlocked ? `
          <button class="zaruba-start-btn" data-mode="${mode.mode}"
            style="margin-top:8px; padding:10px 20px; background:linear-gradient(135deg,#10b981,#34d399); color:white; border:none; border-radius:10px; cursor:pointer; font-weight:700; font-size:14px; box-shadow:0 4px 15px rgba(16,185,129,0.4); transition:all 0.2s;">
            Погнали!
          </button>
        ` : ''}
      `;

          modesContainer.appendChild(card);
        });

        document.querySelectorAll('.zaruba-start-btn').forEach(btn => {
          btn.onclick = async () => {
            const mode = parseInt(btn.dataset.mode);
            await startZarubaMode(mode);
          };
        });
      } else {
        modesContainer.innerHTML = '<div style="text-align:center; color:#94a3b8; padding:20px;">Нет доступных режимов</div>';
      }
    }
    async function startZarubaMode(mode) {
      const token = getAuthToken();
      if (!token) return showError('Ошибка', 'Токен не найден');

      try {
        const res = await fetch('https://oldprison-prod.luckygem.online/api/zaruba/start', {
          method: 'POST',
          headers: {
            'authorization': token,
            'content-type': 'application/json'
          },
          body: JSON.stringify({ mode })
        });

        if (!res.ok) throw new Error(`HTTP ${res.status}`);

        const data = await res.json();
        window.currentZarubaMode = mode;
        window.currentZarubaModeData = data;

        renderTasks(data);

      } catch (err) {
        console.error('Ошибка запуска Зарубы:', err);
        showError('Ошибка', 'Не удалось запустить режим');
      }
    }
    function renderTasks(data) {
      const modesContainer = document.querySelector('#zaruba-modes');
      modesContainer.innerHTML = '';

      const timeLeftMs = new Date(data.endUnix * 1000) - new Date();
      const timeLeftStr = timeLeftMs > 0
        ? `${Math.floor(timeLeftMs / 3600000)} ч ${Math.floor((timeLeftMs % 3600000) / 60000)} мин`
        : 'Завершено';

      const header = document.createElement('div');
      header.style.cssText = `
    text-align:center; padding:10px; background:rgba(15,23,42,0.8); border-radius:10px; margin-bottom:12px;
    border:1px solid #475569; font-size:14px;
  `;
      header.innerHTML = `
    <div style="font-size:16px; font-weight:700; color:#a78bfa; margin-bottom:4px;">Заруба в процессе</div>
    <div style="color:#94a3b8;">
      До конца: ${timeLeftStr} • Участников: ${data.participants.length} • Завершено: ${data.completedCount}
    </div>
  `;

      modesContainer.appendChild(header);

      const batchBlock = document.createElement('div');
      batchBlock.style.cssText = `
  background: rgba(15,23,42,0.8);
  border-radius: 10px;
  padding: 12px;
  margin-bottom: 12px;
  border: 1px solid #475569;
  text-align: center;
`;
      batchBlock.innerHTML = `
  <div style="font-size:15px; font-weight:700; color:#60a5fa; margin-bottom:6px;">
    Количество заруб
  </div>
  <input id="zaruba-batch-count" type="number" min="1" value="1" style="width:80px; padding:6px; border-radius:6px; border:1px solid #475569; background:#1e293b; color:#e2e8f0; text-align:center; font-size:14px;">
  <button id="zaruba-batch-run" style="margin-top:8px; padding:8px 16px; background:#fbbf24; color:#0f172a; border:none; border-radius:8px; cursor:pointer; font-weight:700; font-size:13px;">
    Запустить
  </button>
`;
      modesContainer.appendChild(batchBlock);

      const taskList = document.createElement('div');
      taskList.style.cssText = `display:flex; flex-direction:column; gap:8px;`;

      data.tasks.forEach(task => {
        const progress = Math.min(100, (task.currentAmount / task.requiredAmount) * 100);

        const taskDiv = document.createElement('div');
        taskDiv.style.cssText = `
      background: rgba(30,41,59,0.6);
      border-radius: 8px;
      padding: 8px 12px;
      border: 1px solid #475569;
      font-size:13px;
    `;

        taskDiv.innerHTML = `
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
        <div style="flex:1; color:#e2e8f0; font-weight:600;">
          ${task.title}
          ${task.subtitle ? ` <span style="color:#94a3b8;">(${task.subtitle})</span>` : ''}
        </div>
        <div style="color:#fbbf24; font-weight:700; white-space:nowrap;">
          ${task.currentAmount.toLocaleString()} / ${task.requiredAmount.toLocaleString()}
        </div>
      </div>
      <div style="background:#334155; height:4px; border-radius:2px; overflow:hidden; margin-bottom:6px;">
        <div style="height:100%; background:#10b981; width:${progress}%; transition:width 0.6s;"></div>
      </div>

      <div style="display:flex; justify-content:space-between; align-items:center;">
  <div style="color:#94a3b8; font-size:12px;">
    Стоимость: <span style="color:#fbbf24;">4 мыла</span>
  </div>
  ${task.currentAmount >= task.requiredAmount ? `
    <div style="color:#10b981; font-weight:700; font-size:12px;">Выполнено</div>
  ` : `
    <button class="zaruba-task-btn" data-task-id="${task.taskId}"
      style="padding:4px 12px; background:#60a5fa; color:white; border:none; border-radius:6px; cursor:pointer; font-size:11px; font-weight:600;">
      Выполнить
    </button>
  `}
</div>
    `;

        taskList.appendChild(taskDiv);
      });

      modesContainer.appendChild(taskList);

      const backBtn = document.createElement('button');
      backBtn.textContent = '← Назад к режимам';
      backBtn.style.cssText = `
    margin:12px auto 0; display:block; padding:8px 16px; background:#60a5fa; color:white; border:none;
    border-radius:8px; cursor:pointer; font-weight:600; font-size:13px;
  `;
      backBtn.onclick = () => {
        delete window.currentZarubaMode;
        delete window.currentZarubaModeData;
        renderZarubaData(window.zarubaData);
      };

      document.getElementById('zaruba-batch-run').onclick = () => {
        const N = parseInt(document.getElementById('zaruba-batch-count').value) || 1;
        if (N < 1) return showError('Ошибка', 'Введите количество ≥1');

        const unfinishedInCurrent = data.tasks.filter(t => t.currentAmount < t.requiredAmount).length;
        const soapCost = unfinishedInCurrent * 4 + (N - 1) * 32;

        confirmAction(
          'Подтверждение',
          `Вы точно хотите выполнить ${N} заруб(ы)?\nСтоимость: ${soapCost} мыла\n(первая заруба — ${unfinishedInCurrent} задач, остальные — 32 мыла на зарубу)`,
          async () => {
            let totalSoapSpent = 0;
            let completed = 0;
            const totalTasks = N * 8;

            showProgressModal(totalTasks, 'Выполнение заруб');

            for (let i = 0; i < N; i++) {
              if (window.cancelRequest) break;

              if (!window.currentZarubaModeData ||
                window.currentZarubaModeData.finishedSuccess ||
                window.currentZarubaModeData.finishedFail) {
                await startZarubaMode(window.currentZarubaMode);
                await new Promise(r => setTimeout(r, 1500));
              }

              const tasks = window.currentZarubaModeData.tasks;

              for (const task of tasks) {
                if (window.cancelRequest) break;
                if (task.currentAmount < task.requiredAmount) {
                  try {
                    await completeZarubaTask(task.taskId, true);
                    totalSoapSpent += 4;
                    completed++;
                    updateProgress(completed, totalTasks, completed, 0);
                  } catch (err) {
                    if (err.message === 'Недостаточно мыла') {
                      showError('Недостаточно мыла', 'Цикл остановлен — закончилось мыло.');
                      break; // ← прерываем весь цикл
                    }
                  }
                  await new Promise(r => setTimeout(r, 800));
                }
              }
              await new Promise(r => setTimeout(r, 2000));
            }

            completeProgress('Зарубы', completed, 0, totalTasks);
            await loadZarubaData();
            showSuccess('Готово', `Выполнено ${N} заруб!\nПотрачено ${totalSoapSpent} мыла.`);
          }
        );
      };
      modesContainer.appendChild(backBtn);

      document.querySelectorAll('.zaruba-task-btn').forEach(btn => {
        btn.onclick = async () => {
          const taskId = btn.dataset.taskId;
          await completeZarubaTask(taskId, false);
        };
      });
    }
    async function completeZarubaTask(taskId, silent = false) {
      const token = getAuthToken();
      if (!token) return showError('Ошибка', 'Токен не найден');

      try {
        const res = await fetch('https://oldprison-prod.luckygem.online/api/zaruba/skip', {
          method: 'POST',
          headers: {
            'authorization': token,
            'content-type': 'application/json'
          },
          body: JSON.stringify({ taskId })
        });

        if (!res.ok) {
          const errData = await res.json();
          if (errData.message?.includes('мыла') || errData.message?.includes('soap')) {
            throw new Error('Недостаточно мыла');
          }
          throw new Error(`HTTP ${res.status}`);
        }

        if (!res.ok) throw new Error(`HTTP ${res.status}`);

        const updatedData = await res.json();
        if (window.currentZarubaModeData && window.currentZarubaModeData.claimed) return;

        window.currentZarubaModeData = updatedData.active;
        window.zarubaData = updatedData;
        renderZarubaData(window.zarubaData);
        renderTasks(window.currentZarubaModeData);

        if (!silent) {
          showSuccess('Успех', 'Задание выполнено за 4 мыла!');
        }
      } catch (err) {
        console.error('Ошибка выполнения задания:', err);

        if (err.message === 'Недостаточно мыла') {
          if (!silent) showError('Недостаточно мыла', 'У вас закончилось мыло для выполнения задач.');
          throw err; // ← выбрасываем, чтобы пакетный цикл мог отреагировать
        }

        if (!silent) showError('Ошибка', 'Не удалось выполнить задание');
      }

      if (window.currentZarubaModeData.completedCount === window.currentZarubaModeData.tasks.length ||
        window.currentZarubaModeData.finishedSuccess) {
        await new Promise(r => setTimeout(r, 1500));
        await claimZarubaReward();
        window.currentZarubaModeData.claimed = true;
      }
    }
    async function claimZarubaReward() {
      const token = getAuthToken();
      if (!token) return;

      try {
        const res = await fetch('https://oldprison-prod.luckygem.online/api/zaruba/claim', {
          method: 'POST',
          headers: {
            'authorization': token,
            'content-type': 'application/json'
          },
          body: JSON.stringify({})
        });

        if (!res.ok) throw new Error(`HTTP ${res.status}`);

        const data = await res.json();
        if (data.ok) {
          showSuccess('Награда получена!', 'Все печатки и награды зачислены.');
          await loadZarubaData();
        }
      } catch (err) {
        console.error('Ошибка получения награды:', err);
      }
    }
    async function exchangeOreSignets() {
      const token = getAuthToken();
      if (!token) return showError('Ошибка', 'Токен не найден');

      try {
        const res = await fetch('https://oldprison-prod.luckygem.online/api/zaruba/exchange-ore', {
          method: 'POST',
          headers: {
            'authorization': token,
            'content-type': 'application/json'
          },
          body: JSON.stringify({})
        });

        if (!res.ok) {
          const errData = await res.json();
          if (errData.message?.includes('недостаточно') || res.status === 400) {
            return showError('Недостаточно руд. печаток', 'У вас недостаточно печаток для переплавки');
          }
          throw new Error(`HTTP ${res.status}`);
        }

        const data = await res.json();
        if (data.oreLeft !== undefined && data.signet !== undefined) {
          document.querySelector('#zaruba-ore-signet').textContent = data.oreLeft.toLocaleString();
          document.querySelector('#zaruba-signet').textContent = data.signet.toLocaleString();
          showSuccess('Успех', 'Рудные печатки переплавлены!');
        }
      } catch (err) {
        console.error('Ошибка переплавки:', err);
        showError('Ошибка', 'Не удалось переплавить печатки');
      }
    }

  /** Боссы **/
  function createBossesContent() {
    const div = document.createElement('div');
    div.className = 'tab-content';
    div.id = 'bosses-content';
    div.style.cssText = `
    padding: 30px 20px;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 44px;
    background: linear-gradient(145deg, #1e293b, #0f172a);
    border-radius: 20px;
    min-height: 280px;
    text-align: center;
  `;

    div.innerHTML = `
    <div style="color: #cbd5e1; font-size: 16px; line-height: 1.6; max-width: 280px;margin-bottom: 20px;">
      Открой таблицу для дальнейших действий
    </div>
    
    <button id="open-bosses-panel" class="bosses-panel-btn">
      Открыть таблицу
    </button>
    
    <div style="
      margin-top: 20px;
      padding: 12px 24px;
      background: rgba(34, 197, 94, 0.15);
      color: #86efac;
      font-size: 13px;
      font-weight: 600;
      border-radius: 16px;
      border: 1px solid rgba(34, 197, 94, 0.3);
    ">
      Готов к работе
    </div>
  `;

    const btn = div.querySelector('#open-bosses-panel');
    if (btn) {
      btn.onclick = () => createBossesPanel();
    }

    return div;
  }
  function createBossesPanel() {
    const existing = document.getElementById('tp-bosses-panel');
    if (existing) { bringToFront(existing); return; }

    const panel = document.createElement('div');
    panel.id = 'tp-bosses-panel';
    panel.style.zIndex = ++highestZIndex;

    panel.innerHTML = `
    <div class="interface-header" style="padding:20px 28px; background:#1e293b; border-bottom:1px solid #475569; cursor:move; user-select:none; flex-shrink:0;">
      <div style="font-size:24px; font-weight:800; color:#a78bfa;">БОСС — Автоатака</div>
      <div class="header-controls">
        <button class="ctrl-btn minimize" title="Свернуть">−</button>
        <button class="ctrl-btn close" title="Закрыть">×</button>
      </div>
    </div>

    <div class="bosses-tabs" style="display:flex; background:#1e293b; border-bottom:1px solid #475569; flex-shrink:0;">
      <button class="boss-tab-btn active" data-cat="1">Беспредельщики</button>
      <button class="boss-tab-btn" data-cat="2">Вертухаи</button>
    </div>

    <div id="bosses-main-content" style="flex:1; padding:20px; overflow-y:auto; display:flex; flex-direction:column; gap:18px;">
      <div id="bosses-panel-content">
        <div class="boss-loading">Загружаем боссов...</div>
      </div>
    </div>
  `;

    document.body.appendChild(panel);

    const rect = panel.getBoundingClientRect();
    panel.style.left = Math.max(20, (window.innerWidth - rect.width) / 2 + window.scrollX) + 'px';
    panel.style.top = Math.max(20, (window.innerHeight - rect.height) / 2 + window.scrollY) + 'px';
    bringToFront(panel);

    let isDragging = false, startX, startY, startLeft, startTop;
    const header = panel.querySelector('.interface-header');
    const startDrag = e => {
      if (e.target.closest('.header-controls')) return;
      isDragging = true;
      startX = e.clientX; startY = e.clientY;
      startLeft = panel.offsetLeft; startTop = panel.offsetTop;
      bringToFront(panel);
      document.body.style.userSelect = 'none';
    };
    const onMove = e => {
      if (!isDragging) return;
      panel.style.left = (startLeft + e.clientX - startX) + 'px';
      panel.style.top = (startTop + e.clientY - startY) + 'px';
    };
    const onUp = () => { isDragging = false; document.body.style.userSelect = ''; };
    header.addEventListener('mousedown', startDrag);
    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);

    let minimized = false;
    panel.querySelector('.close').onclick = () => panel.remove();
    panel.querySelector('.minimize').onclick = () => {
      minimized = !minimized;
      panel.style.height = minimized ? '80px' : '720px';
      panel.querySelector('.minimize').textContent = minimized ? '+' : '−';
      panel.querySelector('#bosses-main-content').style.display = minimized ? 'none' : 'flex';
      panel.querySelector('.bosses-tabs').style.display = minimized ? 'none' : 'flex';
    };

    panel.querySelectorAll('.boss-tab-btn').forEach(btn => {
      btn.onclick = () => {
        panel.querySelectorAll('.boss-tab-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        loadBossesForCategory(+btn.dataset.cat);
      };
    });

    loadBossesForCategory(1);


    panel.querySelector('.close').onclick = () => {
        if (activeBossAttacks > 0 || isQueueRunning) {
          showSuccess?.(
            'НЕЛЬЗЯ ЗАКРЫВАТЬ',
            'Дождитесь завершения всех атак<br><br>' +
            'Все боссы должны быть атакованы и убиты<br><br>' +
            '<span style="color:#86efac;font-weight:800">Можно только свернуть (−)</span>',
            14000
          );

        const header = panel.querySelector('.interface-header div');
        if (header) {
          const orig = header.style.color;
          [1,2,3,4,5].forEach(n => setTimeout(() => {
            header.style.color = n % 2 ? '#ef4444' : '#a78bfa';
          }, n * 300));
          setTimeout(() => header.style.color = orig, 1800);
        }
        return;
      }
      panel.remove();
    };
  }
  async function loadBossesForCategory(categoryId) {
    const container = document.querySelector('#tp-bosses-panel #bosses-panel-content');
    if (!container) return;

    container.innerHTML = `<div style="text-align:center;padding:140px;color:#94a3b8;font-size:28px;">Загружаем боссов...</div>`;

    const token = getAuthToken();
    if (!token) {
      container.innerHTML = `<div style="color:#f87171;text-align:center;padding:140px;">Токен не найден</div>`;
      return;
    }
    setTimeout(() => {
      const tabsContainer = document.querySelector('#tp-bosses-panel .bosses-tabs');
      if (!tabsContainer || tabsContainer.querySelector('.boss-tab-btn[data-cat="queue"]')) return;

      const queueBtn = document.createElement('button');
      queueBtn.className = 'boss-tab-btn';
      queueBtn.dataset.cat = 'queue';
      queueBtn.textContent = 'Очередь';
      // queueBtn.style.cssText = 'padding:10px 16px; background:#22c55e; color:white; border:none; border-radius:12px; font-weight:800; font-size:14px; cursor:pointer; margin-left:8px;';

      queueBtn.onclick = () => {
        document.querySelectorAll('.boss-tab-btn').forEach(b => {
          b.classList.remove('active');
          b.style.background = '#334155';
        });
        queueBtn.classList.add('active');
        queueBtn.style.background = '#16a34a';
        localStorage.setItem('active_boss_tab', 'queue');

        container.innerHTML = '';
        renderQueuePanel();
      };

      tabsContainer.appendChild(queueBtn);

      if (localStorage.getItem('active_boss_tab') === 'queue') {
        setTimeout(() => queueBtn.click(), 100);
      }
    }, 100);

    let weaponCache = null;
    let weaponCacheTime = 0;
    const CACHE_TTL = 45_000;

    async function getCurrentWeapons() {
      const now = Date.now();
      if (weaponCache && (now - weaponCacheTime) < CACHE_TTL) {
        return weaponCache;
      }

      try {
        const res = await fetch('https://oldprison-prod.luckygem.online/api/player/init', {
          method: 'POST',
          headers: {
            'authorization': getAuthToken(),
            'content-type': 'application/json'
          },
          credentials: 'include'
        });

        if (!res.ok) throw new Error('HTTP ' + res.status);
        const data = await res.json();

        if (data.success) {
          weaponCache = {
            poison: data.poisonCount || 0,
            gunshot: data.gunshotCount || 0,
            knife: data.knifeCount || 0
          };
          weaponCacheTime = now;
          return weaponCache;
        }
      } catch (e) {
        console.warn('Не удалось получить оружие из /player/init:', e);
      }

      return { poison: 0, gunshot: 0, knife: 0 };
    }

    function invalidateWeaponCache() {
      weaponCache = null;
      weaponCacheTime = 0;
    }

    try {
      const res = await fetch(`https://oldprison-prod.luckygem.online/api/boss/list?categoryId=${categoryId}`, {
        headers: { 'authorization': getAuthToken() },
        credentials: 'include'
      });
      const data = await res.json();

      const modeNames = { pacansky: 'Пацанский', blotnoy: 'Блатной', avtoritetny: 'Авторитетный', odin: 'В одного' };

      if (!data.success && data.message === "Session in progress" && data.session) {
        const s = data.session;
        const bossTitle   = s.title ?? "Неизвестный босс";
        const currentHP   = s.currentHp != null ? Number(s.currentHp).toLocaleString('ru-RU') : "—";
        const maxHP       = s.maxHp != null     ? Number(s.maxHp).toLocaleString('ru-RU')     : "—";
        const modeName    = modeNames[s.mode] || s.mode || "Неизвестно";
        const bossId = s.bossId;

        let currentKill = 0;
        let targetKills = 1;
        let comboMode   = null;
        let doCombo     = false;

        const savedRaw = localStorage.getItem(`boss_farm_${bossId}`);
        if (savedRaw) {
          try {
            const saved = JSON.parse(savedRaw);
            currentKill = saved.currentKill || 0;
            targetKills = saved.killCount   || 1;
            comboMode   = saved.comboMode    || null;
            doCombo     = saved.doCombo      || false;
          } catch (e) {
            console.warn("Не удалось распарсить настройки босса из localStorage");
          }
        }

        container.innerHTML = `
  <div style="background: linear-gradient(135deg, #1e293b, #111827); border: 3px solid #a78bfa; border-radius: 24px; padding: 40px 30px; margin: 20px; text-align: center; box-shadow: 0 20px 60px rgba(167,139,250,0.3); color: #e2e8f0;">
    <div style="font-size:19px; color:#fb923c; font-weight:800; letter-spacing:1.5px; margin-bottom:20px;">АКТИВНЫЙ БОЙ</div>
    <div style="font-size: 42px; font-weight: 900; margin: 20px 0; line-height: 1.2;">${bossTitle}</div>
    <div style="font-size: 28px; color: #94a3b8; margin: 30px 0;">Остаток HP: <span style="color: #f87171; font-weight: 800;">${currentHP}</span></div>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; max-width: 520px; margin: 30px auto;">
      <div style="background:#334155;padding:18px;border-radius:14px;">
        <div style="color:#94a3b8;font-size:14px;">Режим убийства</div>
        <div style="color:#60a5fa;font-weight:700;font-size:19px;margin-top:6px;">${modeName}</div>
      </div>
      ${comboMode || doCombo ? `
      <div style="background:#334155;padding:18px;border-radius:14px;">
        <div style="color:#94a3b8;font-size:14px;">Комбо</div>
        <div style="color:#f59e0b;font-weight:700;font-size:19px;margin-top:6px;">
          ${modeNames[comboMode] || comboMode || 'Включено'} ${doCombo ? '(активно)' : ''}
        </div>
      </div>` : '<div></div>'}
    </div>
    <div style="font-size: 27px; color: #fcd34d; font-weight: 800; margin: 35px 0;">
      Прогресс: <span style="color:#86efac;">${currentKill}/${targetKills}</span> убийств
    </div>
    <button id="stop-active-boss-farm" style="padding: 16px 40px; background: #7f1d1d; color: white; border: none; border-radius: 14px; font-weight: 700; font-size: 18px; cursor: pointer; box-shadow: 0 10px 25px rgba(127,29,29,0.5); transition: all 0.2s;" onmouseover="this.style.background='#991b1b'" onmouseout="this.style.background='#7f1d1d'">
      Закрыть таблицу
    </button>
    <div style="margin-top: 25px; color: #94a3b8; font-size: 15px; line-height: 1.5;">
      Убийство идёт в фоне — закрытие таблицы не остановит атаку
    </div>
  </div>
`;

        const stopBtn = document.getElementById('stop-active-boss-farm');
        if (stopBtn) {
          stopBtn.onclick = () => {
            localStorage.removeItem(`boss_farm_${bossId}`);
            container.innerHTML = `<div style="text-align:center; padding:80px 20px; color:#86efac; font-size:26px; font-weight:800;">Таблица закрыта, убийство не остановлено</div>`;
            setTimeout(() => loadBossesForCategory(categoryId), 2200);
          };
        }
        return;
      }

      if (!data.success || !data.bosses?.length) {
        container.innerHTML = `<div style="text-align:center;color:#f87171;padding:140px;font-size:28px;">Боссы не найдены</div>`;
        return;
      }

      container.innerHTML = '';
      container.style.cssText = `display:flex;flex-direction:column;gap:20px;`;

      function printVictoryToConsole(rewards, bossTitle, currentKill, totalKills) {
        const { globalReward, mode = 'pacansky', result, startedAt, time } = rewards;

        const modeNames = { pacansky: 'Пацанский', blotnoy: 'Блатной', avtoritetny: 'Авторитетный', odin: 'В одного' };
        const modeColors = { pacansky: '#60a5fa', blotnoy: '#f59e0b', avtoritetny: '#10b981', odin: '#ef4444' };

        const modeName = modeNames[mode] || mode;
        const modeColor = modeColors[mode] || '#94a3b8';

        const startTime = new Date(startedAt);
        const endTime = new Date(time);
        const fightDuration = Math.round((endTime - startTime) / 1000);

        const currencies = globalReward?.currencies || [];
        const cigarettes = currencies.find(c => c.type === 'cigarettes')?.amount || 0;
        const sugar = currencies.find(c => c.type === 'sugar')?.amount || 0;
        const rubles = currencies.find(c => c.type === 'rubles')?.amount || 0;
        const keys = globalReward?.keys || 0;
        const authority = globalReward?.authority || 0;

        console.log(`%cУСПЕШНАЯ АТАКА БОССА!`, `background:${modeColor}; color:white; font-size:16px; font-weight:bold; padding:8px 16px; border-radius:8px;`);
        console.log(`%c${bossTitle}`, `color:${modeColor}; font-size:14px; font-weight:bold;`);
        console.group('Детали боя:');
        console.log(`%cРежим: ${modeName}`, `color:${modeColor}`);
        console.log(`%cРезультат: ${result === 'victory' ? 'ПОБЕДА' : result}`, `color:#10b981`);
        console.log(`%cДлительность боя: ${fightDuration} сек.`, `color:#f59e0b`);
        console.log(`%cПрогресс: ${currentKill}/${totalKills}`, `color:#8b5cf6`);
        console.groupEnd();

        console.group('Награды:');
        if (cigarettes > 0) console.log(`%cСигареты: +${cigarettes.toLocaleString()}`, `color:#f59e0b`);
        if (sugar > 0)      console.log(`%cСахар: +${sugar.toLocaleString()}`, `color:#ec4899`);
        if (rubles > 0)     console.log(`%cРубли: +${rubles.toLocaleString()} ₽`, `color:#ec4899`);
        if (keys > 0)       console.log(`%cКлючи: +${keys}`, `color:#ef4444`);
        if (authority > 0)  console.log(`%cАвторитет: +${authority}`, `color:#f59e0b`);
        if (!cigarettes && !sugar && !rubles && !keys && !authority)
          console.log(`%cНаграды не получены`, `color:#f59e0b`);
        console.groupEnd();

        console.log(`%c${endTime.toLocaleTimeString()}`, `color:#64748b; font-size:12px;`);
        console.log('%c' + '='.repeat(50), 'color:#374151');

        // === МОДАЛКА ПОСЛЕ УБИЙСТВА ===
        const lines = [
          `<div style="font-size:32px; margin:20px 0; color:#86efac; font-weight:900;">${bossTitle} УБИТ!</div>`,
          `<div style="font-size:28px; color:${modeColor}; font-weight:900; margin-bottom:16px;">${modeName.toUpperCase()}</div>`,
          `<div style="font-size:19px; color:#fcd34d; margin-bottom:20px;">Убийство ${currentKill}</div>`
        ];

        const rewardsList = [];
        if (cigarettes > 0) rewardsList.push(`<div style="color:#fde68a;">+${cigarettes.toLocaleString()} папирос</div>`);
        if (sugar > 0)      rewardsList.push(`<div style="color:#fda4af;">+${sugar.toLocaleString()} сахара</div>`);
        if (rubles > 0)     rewardsList.push(`<div style="color:#fca5a5;">+${rubles.toLocaleString()} ₽</div>`);
        if (keys > 0)       rewardsList.push(`<div style="color:#fca5a5;">+${keys} ключей</div>`);
        if (authority > 0)  rewardsList.push(`<div style="color:#fbbf24;">+${authority} авторитета</div>`);

        if (rewardsList.length > 0) {
          lines.push(`<div style="margin:20px 0; line-height:1.8; font-size:18px;">${rewardsList.join('')}</div>`);
        } else {
          lines.push(`<div style="color:#94a3b8; margin:20px 0;">Наград не было</div>`);
        }

        lines.push(`<div style="color:#94a3b8; font-size:15px; margin-top:16px;">
    Бой длился: <strong>${fightDuration} сек</strong>
  </div>`);

        showModal({
          title: `Босс убит! • ${currentKill}/${totalKills}`,
          content: `
      <div style="text-align:center; font-family:system-ui; padding:15px;">
        ${lines.join('')}
      </div>
    `,
          buttons: [{ label: 'Круто!', action: () => {} }]
        });
      }

      data.bosses.forEach(item => {
        const boss = item.boss;
        const combos = item.combos || {};
        const killModes = Object.keys(boss.battleModes || {});
        const comboModes = Object.keys(combos);

        const defaultKill = ['pacansky','blotnoy','avtoritetny','odin'].find(m=>killModes.includes(m)) || killModes[0];
        const hasCombo = comboModes.length > 0;
        const defaultCombo = hasCombo ? ['pacansky','blotnoy','avtoritetny'].find(m=>comboModes.includes(m)) || comboModes[0] : null;

        const block = document.createElement('div');
        block.style.cssText = `background:#1e293b; border-radius:16px; padding:18px; border:2px solid transparent; transition:all 0.3s; display:flex; flex-direction:column; gap:14px;`;
        block.onmouseover = () => block.style.borderColor = '#a78bfa';
        block.onmouseout  = () => block.style.borderColor = 'transparent';

        const comboInputBlock = createComboInputBlock();

        const savedSettings = localStorage.getItem(`boss_farm_${boss.id}`);
        const saved = savedSettings ? JSON.parse(savedSettings) : null;

        let currentKill = 0;
        let targetKills = 1;
        let stopAttacking = false;
        let monitorInterval = null;
        let isSessionActive = false;


        block.innerHTML = `
  <div style="display:flex; align-items:center; gap:16px;">
    <input type="checkbox" class="boss-checkbox" value="${boss.id}" checked style="width:22px;height:22px;cursor:pointer;">
    <div style="font-size:22px;font-weight:800;color:#e2e8f0;flex:1;">${boss.title}</div>
  </div>

  <div style="display:grid; grid-template-columns:1fr 1fr 1fr auto; gap:12px; align-items:end;">
    <div>
      <div style="color:#94a3b8;font-size:13px;margin-bottom:6px;">Режим убийства</div>
      <select class="boss-kill-mode" style="width:100%;padding:10px;background:#334155;color:white;border:1px solid #475569;border-radius:10px;font-size:14px;">
        ${killModes.map(m=>`<option value="${m}" ${m===defaultKill?'selected':''}>${modeNames[m]||m}</option>`).join('')}
      </select>
    </div>

    ${hasCombo ? `
    <div>
      <div style="color:#94a3b8;font-size:13px;margin-bottom:6px;">Режим комбо</div>
      <select class="boss-combo-mode" style="width:100%;padding:10px;background:#334155;color:white;border:1px solid #475569;border-radius:10px;font-size:14px;">
        ${comboModes.map(m=>`<option value="${m}" ${m===defaultCombo?'selected':''}>${modeNames[m]} (x${combos[m].length})</option>`).join('')}
      </select>
    </div>` : '<div></div>'}

    <div>
      <div style="color:#94a3b8;font-size:13px;margin-bottom:6px;">Убить раз</div>
      <input type="number" class="boss-kill-count" value="1" min="1" max="999" 
             style="width:100%;padding:10px;background:#334155;color:white;border:1px solid #475569;border-radius:10px;font-size:14px;">
    </div>

    <div style="display:flex; flex-direction:column; gap:8px;">
      <button class="boss-attack-btn" style="padding:12px 20px;background:#ef4444;color:white;border:none;border-radius:10px;font-weight:700;font-size:15px;cursor:pointer;">
        АТАКОВАТЬ
      </button>
      <div class="boss-reward-info" style="padding:8px;background:#166534;color:#86efac;border-radius:8px;text-align:center;display:none;font-size:13px;font-weight:700;"></div>
    </div>

    ${['Сизый', 'Махно', 'Лютый', 'Циклоп', 'Бес', 'Раиса'].some(name => boss.title.includes(name)) ? `
<div style="grid-column:1/-1; display:flex; gap:12px; align-items:center; margin-top:8px;">
  <div style="color:#94a3b8;font-size:13px; white-space:nowrap;">Докупать ключи?</div>
  <select class="boss-buy-keys" style="padding:8px 14px; background:#334155; color:white; border:1px solid #475569; border-radius:10px; font-size:14px; min-width:120px;">
    <option value="yes">Да</option>
    <option value="no">Нет</option>
  </select>
</div>
` : ''}
    
    ${['Сизый', 'Махно', 'Палыч', 'Лютый', 'Циклоп', 'Бес'].some(name => boss.title.includes(name)) ? `
<div class="boss-needle-wrapper" style="grid-column:1/-1; gap:12px; align-items:center; margin-top:8px; display:flex;">
  <div style="color:#94a3b8;font-size:13px; white-space:nowrap; display:flex; align-items:center;">
    Добивать Иглой?
    <span style="margin-left:8px; font-size:11px; color:#fbbf24; background:#451a03; padding:2px 6px; border-radius:4px;">
      только «В одного» + общак
    </span>
  </div>
  <select class="boss-needle" style="padding:8px; background:#334155; color:white; border:1px solid #475569; border-radius:10px; font-size:14px;">
    <option value="yes">Да</option>
    <option value="no" selected>Нет</option>
  </select>
</div>
` : ''}

    <div class="boss-surrender-wrapper" style="grid-column:1/-1; display:none; gap:12px; align-items:center; margin-top:8px;">
      <div style="color:#94a3b8;font-size:13px; white-space:nowrap; display:flex; align-items:center;">
        Выйти за мыло после комбо?
        <span style="margin-left:8px; font-size:11px; color:#fbbf24; background:#451a03; padding:2px 6px; border-radius:4px;">
          только «В одного»
        </span>
      </div>
      <select class="boss-surrender" style="padding:8px; background:#334155; color:white; border:1px solid #475569; border-radius:10px; font-size:14px;">
        <option value="yes">Да</option>
        <option value="no" selected>Нет</option>
      </select>
    </div>
  </div>

  <div style="margin-top:8px;">
    <div style="color:#94a3b8;font-size:13px;margin-bottom:6px;">Делать комбо</div>
    <select class="boss-do-combo" style="width:100%;padding:10px;background:#334155;color:white;border:1px solid #475569;border-radius:10px;font-size:14px;">
      <option value="no">Нет</option>
      <option value="yes">Да</option>
    </select>
  </div>
`;

        block.appendChild(comboInputBlock);
        container.appendChild(block);

        const attackBtn = block.querySelector('.boss-attack-btn');
        const queueBtnContainer = attackBtn.parentNode;

        const queueBtn = document.createElement('button');
        queueBtn.textContent = 'В очередь';
        queueBtn.className = 'boss-queue-btn';
        queueBtn.style.cssText = 'flex:1; padding:12px 20px; background:#22c55e; color:white; border:none; border-radius:10px; font-weight:700; font-size:15px; cursor:pointer;';

        const alreadyInQueue = bossQueue.some(x => x.boss.id == boss.id);
        if (alreadyInQueue) {
          queueBtn.textContent = 'В очереди';
          queueBtn.disabled = true;
          queueBtn.style.background = '#166534';
        }

        queueBtn.onclick = () => {
          if (alreadyInQueue) return;

          const settings = {
            killCount: parseInt(block.querySelector('.boss-kill-count')?.value) || 1,
            killMode: block.querySelector('.boss-kill-mode')?.value || 'pacansky',
            comboMode: block.querySelector('.boss-combo-mode')?.value || null,
            doCombo: block.querySelector('.boss-do-combo')?.value === 'yes',
            comboText: block.querySelector('.boss-combo-textarea')?.value?.trim() || '',
            comboDelay: parseInt(block.querySelector('.boss-combo-delay')?.value) || 1500,
            buyKeys: block.querySelector('.boss-buy-keys')?.value || 'no',
            needle: block.querySelector('.boss-needle')?.value || 'no',
            surrender: block.querySelector('.boss-surrender')?.value || 'no',
          };

          bossQueue.push({
            boss: { id: boss.id, title: boss.title, cat: categoryId },
            settings
          });

          localStorage.setItem('boss_queue_v6', JSON.stringify(bossQueue));
          // showSuccess?.('Очередь', `${boss.title} добавлен`);

          queueBtn.textContent = 'В очереди';
          queueBtn.disabled = true;
          queueBtn.style.background = '#166534';
        };

        queueBtnContainer.appendChild(queueBtn);

        if (saved) {
          if (saved.killCount) block.querySelector('.boss-kill-count').value = saved.killCount;
          if (saved.killMode) block.querySelector('.boss-kill-mode').value = saved.killMode;
          if (saved.comboMode) {
            const comboSelect = block.querySelector('.boss-combo-mode');
            if (comboSelect) comboSelect.value = saved.comboMode;
          }
          if (saved.doCombo !== undefined) block.querySelector('.boss-do-combo').value = saved.doCombo ? 'yes' : 'no';
          if (saved.comboText) comboInputBlock.querySelector('.boss-combo-textarea').value = saved.comboText;
          if (saved.comboDelay) comboInputBlock.querySelector('.boss-combo-delay').value = saved.comboDelay;
          const buyKeysSelect = block.querySelector('.boss-buy-keys');
          if (buyKeysSelect && saved?.buyKeys) {
            buyKeysSelect.value = saved.buyKeys;
          }
          const needleSelect = block.querySelector('.boss-needle');
          if (needleSelect && saved?.needle) {
            needleSelect.value = saved.needle;
          }
          const surrenderSelect = block.querySelector('.boss-surrender');
          if (surrenderSelect && saved?.surrender) {
            surrenderSelect.value = saved.surrender;
          }
        }

        const doComboSelect = block.querySelector('.boss-do-combo');
        doComboSelect.onchange = () => {
          comboInputBlock.style.display = doComboSelect.value === 'yes' ? 'flex' : 'none';
        };
        // ─────── "Добивать Иглой?" ───────
        const killModeSelect = block.querySelector('.boss-kill-mode');
        const needleWrapper = block.querySelector('.boss-needle-wrapper');
        const needleSelect = block.querySelector('.boss-needle');

        const updateNeedleVisibility = () => {
          const isOdinMode = killModeSelect.value === 'odin';
          const isTargetBoss = ['Сизый', 'Махно', 'Палыч', 'Лютый', 'Циклоп', 'Бес'].some(name => boss.title.includes(name));

          if (isTargetBoss && isOdinMode) {
            needleWrapper.style.display = 'flex';
            if (needleSelect) needleSelect.disabled = false;
          } else {
            needleWrapper.style.display = 'none';
            if (needleSelect) needleSelect.disabled = true;
          }

          // При переключении с "В одного" — сбрасываем на "Нет", если было "Да"
          if (!isOdinMode && needleSelect && needleSelect.value === 'yes') {
            needleSelect.value = 'no';
            // Сохраняем сброс
            let settings = { needle: 'no' };
            try {
              const old = localStorage.getItem(`boss_farm_${boss.id}`);
              if (old) settings = { ...JSON.parse(old), needle: 'no' };
            } catch {}
            localStorage.setItem(`boss_farm_${boss.id}`, JSON.stringify(settings));
          }
        };

        // ─────── "Добивать Иглой?" ───────
        if (killModeSelect && needleWrapper) {
          killModeSelect.addEventListener('change', updateNeedleVisibility);
          updateNeedleVisibility();
        }

        // ─────── "Выйти за мыло после комбо?" ─────── (на всех боссах)
        const surrenderWrapper = block.querySelector('.boss-surrender-wrapper');
        const surrenderSelect = block.querySelector('.boss-surrender');

        const updateSurrenderVisibility = () => {
          const isOdinMode = killModeSelect.value === 'odin';
          if (isOdinMode) {
            surrenderWrapper.style.display = 'flex';
            if (surrenderSelect) surrenderSelect.disabled = false;
          } else {
            surrenderWrapper.style.display = 'none';
            if (surrenderSelect) surrenderSelect.disabled = true;
            if (surrenderSelect && surrenderSelect.value === 'yes') {
              surrenderSelect.value = 'no';
            }
          }
        };

        if (killModeSelect && surrenderWrapper) {
          killModeSelect.addEventListener('change', updateSurrenderVisibility);
          updateSurrenderVisibility();
        }

        comboInputBlock.style.display = doComboSelect.value === 'yes' ? 'flex' : 'none';

        const textarea = comboInputBlock.querySelector('.boss-combo-textarea');
        const preview = comboInputBlock.querySelector('.boss-combo-preview');
        textarea.addEventListener('input', () => parseAndAnalyzeCombo(textarea.value, preview));
        textarea.addEventListener('paste', () => setTimeout(() => parseAndAnalyzeCombo(textarea.value, preview), 50));


        const btn = block.querySelector('.boss-attack-btn');
        const rewardDiv = block.querySelector('.boss-reward-info');

        const resetButton = () => {
          stopAttacking = false;
          currentKill = 0;
          clearInterval(monitorInterval);
          monitorInterval = null;
          btn.textContent = 'АТАКОВАТЬ';
          btn.style.background = '#ef4444';
          btn.disabled = false;
          rewardDiv.style.display = 'none';
          rewardDiv.innerHTML = '';
        };

        const executeBossCombo = async (killNumber) => {
          const text = textarea.value?.trim();
          let consecutive429 = 0;

          // ─────── Проверка добива иглой — КАЖДЫЙ РАЗ, когда убиваем босса в режиме "В одного" ───────
          const needleSelect = block.querySelector('.boss-needle');
          const killModeSelect = block.querySelector('.boss-kill-mode');
          const doNeedle = needleSelect?.value === 'yes' &&
            killModeSelect?.value === 'odin' &&
            ['Сизый', 'Махно', 'Палыч', 'Лютый', 'Циклоп', 'Бес'].some(name => boss.title.includes(name));

          await sleep(1500);
          await claimBossReward();

          // Если нет ни комбо, ни иглы — просто выходим
          if (!text && !doNeedle) return { completed: true };

          const delay = Math.max(800, parseInt(comboInputBlock.querySelector('.boss-combo-delay')?.value || 1500));
          const moves = text ? parseAndAnalyzeCombo(text, preview) : [];
          if (text && moves.length === 0) return { completed: true };

          const beforeWeapons = await getCurrentWeapons();
          const usedFreeHit = {};
          let lastComboResponse = null;
          let comboInterruptedAt = null;
          let needleDamage = 0;

          // ─── 1.Выполняем комбо (если есть) ───
          if (text && moves.length > 0) {
            for (let i = 0; i < moves.length; i++) {
              if (stopAttacking) return { completed: false, interrupted: true };

              const move = moves[i];
              const w = weaponsDict[move];
              if (!w) continue;

              if (w.freeFirst && w.restore && usedFreeHit[w.weapon]) {
                await fetch("https://oldprison-prod.luckygem.online/api/boss/restore-free-hit", {
                  method: "POST",
                  headers: { "content-type": "application/json", "authorization": getAuthToken() },
                  body: JSON.stringify({ weaponType: w.restore })
                });
                await new Promise(r => setTimeout(r, 1400 + Math.random() * 400));
                usedFreeHit[w.weapon] = false;
              }
              if (w.freeFirst) usedFreeHit[w.weapon] = true;

              rewardDiv.innerHTML = `Комбо ${killNumber}/${targetKills}: ${w.name} (${i + 1}/${moves.length})`;
              rewardDiv.style.background = '#7c2d12';
              rewardDiv.style.display = 'block';

              const currentTokenForAttack = getAuthToken();

              const resp = await fetch("https://oldprison-prod.luckygem.online/api/boss/use-weapon", {
                method: "POST",
                headers: { "content-type": "application/json", "authorization": currentTokenForAttack },
                body: JSON.stringify({ weapon: w.weapon })
              });

              if (resp.status === 429) {
                let consecutive429 = consecutive429 || 0;
                consecutive429++;

                if (consecutive429 > 6) {
                  rewardDiv.innerHTML = `Слишком много 429 подряд — комбо прервано`;
                  rewardDiv.style.background = '#7f1d1d';
                  rewardDiv.style.display = 'block';
                  return { completed: false, interrupted: true };
                }

                const waitTime = 1200 + consecutive429 * 600; // 1.8 → 2.4 → 3.0 → 3.6 → 4.2 → 4.8 сек
                rewardDiv.innerHTML = `429 (${consecutive429}/6) — ждём ≈${Math.round(waitTime/1000)} сек`;
                rewardDiv.style.background = '#7c2d12';
                rewardDiv.style.display = 'block';

                await new Promise(r => setTimeout(r, waitTime));

                i--;  // повторяем ТОТ ЖЕ удар
                continue;
              } else {
                consecutive429 = 0; // сбрасываем при любом успешном ответе
              }

              if (resp.status === 401 || resp.status === 403) {
                console.log('%c401/403 на use-weapon → принудительный релогин и повтор удара', 'color:#dc2626;background:#7f1d1d;padding:12px 20px;border-radius:12px;font-weight:bold;');

                rewardDiv.innerHTML = `403 → релогин (удар ${i + 1}/${moves.length})`;
                rewardDiv.style.background = '#7f1d1d';
                rewardDiv.style.display = 'block';

                // Принудительно чистим старые токены и делаем force-релогин
                localStorage.removeItem('accessToken');
                localStorage.removeItem('refreshToken');

                const reloginOk = await silentRelogin(true);
                if (!reloginOk) {
                  rewardDiv.innerHTML = 'Релогин провалился — комбо остановлено';
                  rewardDiv.style.background = '#7f1d1d';
                  return { completed: false };
                }

                await new Promise(r => setTimeout(r, 1000 + Math.random() * 500));

                i--; // повторяем текущий удар с новым токеном
                continue;
              }

              // Новый безопасный парсер + сохранение comboReward
              let data = null;
              const responseText = await resp.text();
              if (responseText.trim()) {
                try {
                  data = JSON.parse(responseText);
                } catch (e) {
                  data = { success: false, message: responseText };
                }
              }
              if (data?.comboReward) {
                lastComboResponse = data;
              }
              const msgForChecks = (data?.message || responseText || "").toLowerCase();

              // Перезарядка — восстанавливаем
              if (!resp.ok && resp.status === 400 && responseText.toLowerCase().includes('перезарядка')) {
                console.log(`Перезарядка ${w.name} — автоматически восстанавливаем`);

                rewardDiv.innerHTML = `Перезарядка → восстанавливаю ${w.name}...`;
                rewardDiv.style.background = '#1e40af';

                const restoreResp = await fetch("https://oldprison-prod.luckygem.online/api/boss/restore-free-hit", {
                  method: "POST",
                  headers: { "content-type": "application/json", "authorization": getAuthToken() },
                  body: JSON.stringify({ weaponType: w.restore })
                });

                if (!restoreResp.ok) {
                  rewardDiv.innerHTML = `Не удалось восстановить ${w.name}`;
                  rewardDiv.style.background = '#7f1d1d';
                  return { completed: false };
                }

                await new Promise(r => setTimeout(r, 1400 + Math.random() * 400));
                usedFreeHit[w.weapon] = false;
                i--;
                continue;
              }

              // Любая другая ошибка / смерть босса
              if (!resp.ok || !data?.success) {
                const deadSignals = ["dead","убит","победа","already","сессия не найдена","завершена","finished","победа над боссом","сессия завершена","нет активной сессии","already dead"];
                if (deadSignals.some(s => msgForChecks.includes(s))) {
                  comboInterruptedAt = i + 1;
                  rewardDiv.innerHTML = `<strong>Комбо остановлено на ${i + 1}/${moves.length}</strong><br><small>${killNumber}/${targetKills} — босс умер раньше</small>`;
                  rewardDiv.style.background = '#7f1d1d';
                  break;
                } else {
                  rewardDiv.innerHTML = data?.message || responseText || "Ошибка удара";
                  rewardDiv.style.background = '#7f1d1d';
                  return { completed: false };
                }
              }

              if (i < moves.length - 1) await new Promise(r => setTimeout(r, delay));
            }
          }

          invalidateWeaponCache();
          const afterWeapons = await getCurrentWeapons();

          // ─────── 2. Добивание иглой (КАЖДЫЙ РАЗ, если включено) ───────
          if (doNeedle) {
            rewardDiv.innerHTML = 'Добиваем иглой через 2 сек...';
            rewardDiv.style.background = '#1e40af';
            rewardDiv.style.display = 'block';

            await new Promise(r => setTimeout(r, 2000));

            try {
              const stateRes = await fetch('https://oldprison-prod.luckygem.online/api/vpi/damage-left', {
                headers: { 'authorization': getAuthToken() },
                credentials: 'include'
              });
              const state = await stateRes.json();

              if (state.active && state.damageLeft > 0) {
                const amount = state.damageLeft;

                const spendRes = await fetch('https://oldprison-prod.luckygem.online/api/vpi/spend-damage', {
                  method: 'POST',
                  headers: { 'content-type': 'application/json', 'authorization': getAuthToken() },
                  body: JSON.stringify({ bossId: boss.id, amount: amount, Amount: amount }),
                  credentials: 'include'
                });

                const result = await spendRes.json();

                if (result.ok) {
                  needleDamage = result.actualSpent;
                  const dmg = needleDamage.toLocaleString('ru-RU');
                  rewardDiv.innerHTML = `<strong>Иглой добил: −${dmg} HP</strong>`;
                  rewardDiv.style.background = '#7c2d12';

                  console.log(
                    `%cИГЛОЙ ДОБИЛ: ${boss.title} — ${dmg} урона`,
                    'color:#fbbf24; background:#451a03; font-weight:bold; padding:10px 16px; border-radius:12px; font-size:16px;');
                } else {
                  rewardDiv.innerHTML = 'Игла: не удалось';
                  rewardDiv.style.background = '#7f1d1d';
                }
              } else {
                rewardDiv.innerHTML = 'Игла: нет урона в общаке';
                rewardDiv.style.color = '#94a3b8';
              }
            } catch (e) {
              console.warn('Ошибка иглы:', e);
              rewardDiv.innerHTML = 'Игла: ошибка сети';
              rewardDiv.style.background = '#7f1d1d';
            }

            await new Promise(r => setTimeout(r, 1500));
          }

          // ─────── 3. Модалка + игла в ней ───────
          if (lastComboResponse?.comboReward) {
            const r = lastComboResponse.comboReward;
            const combo = lastComboResponse.combo || {};
            const comboNames = {
              pacansky: "Пацанский",
              blotnoy:  "Блатной",
              avtoritetny: "Авторитетный"
            };
            const typeName = comboNames[combo.selectedType] || "Неизвестно";

            const spent = { poison: 0, gunshot: 0, knife: 0 };
            moves.forEach(move => {
              const w = weaponsDict[move];
              if (w && !w.freeFirst) {
                if (w.weapon === 'poison') spent.poison++;
                if (w.weapon === 'gunshot') spent.gunshot++;
                if (w.weapon === 'knife') spent.knife++;
              }
            });

            console.log(`%cКОМБО ВЫПОЛНЕНО! ${typeName}`, `background:#a78bfa; color:white; font-size:16px; font-weight:bold; padding:8px 16px; border-radius:8px;`);
            console.log(`%c${boss.title} • Убийство ${killNumber}`, `color:#e2e8f0; font-size:14px; font-weight:bold;`);
            console.group('Награда от комбо:');
            if (r.authority) console.log(`%cАвторитет: +${r.authority}`, `color:#f59e0b`);
            (r.currencies || []).forEach(c => {
              if (c.type === 'cigarettes') console.log(`%cСигареты: +${c.amount.toLocaleString()}`, `color:#f59e0b`);
              if (c.type === 'rubles') console.log(`%cРубли: +${c.amount.toLocaleString()}`, `color:#ec4899`);
            });
            if (r.stash?.count) console.log(`%cНычки: +${r.stash.count}`, `color:#60a5fa`);
            if (r.tattoos?.length) console.log(`%cТатуировки: +${r.tattoos.length} шт.`, `color:#8b5cf6`);
            console.groupEnd();

            console.group('Оружие после комбо:');
            ['poison', 'gunshot', 'knife'].forEach(key => {
              const name = { poison: 'Яд', gunshot: 'Самопал', knife: 'Финка' }[key];
              const was = beforeWeapons[key] || 0;
              const now = afterWeapons[key] || 0;
              const used = spent[key];
              const earned = r.weapons?.[key] || 0;
              const diff = now - was;
              const arrow = diff > 0 ? 'вверх' : diff < 0 ? 'вниз' : '→';
              const color = diff > 0 ? '#86efac' : diff < 0 ? '#fca5a5' : '#e2e8f0';
              console.log(`%c${name}: ${was.toLocaleString()} − ${used} + ${earned} %c${arrow} ${now.toLocaleString()}`, `color:#94a3b8`, `color:${color}; font-weight:bold`);
            });
            console.groupEnd();
            console.log('%c' + '═'.repeat(50), 'color:#475569');

            const format = n => n.toLocaleString('ru-RU');
            const weaponsList = [
              { key: 'poison',  name: 'Яд',      emoji: '☠️' },
              { key: 'gunshot', name: 'Самопал', emoji: '🔫' },
              { key: 'knife',   name: 'Финка',   emoji: '🔪' }
            ];

            let rows = '';
            weaponsList.forEach(w => {
              const was = beforeWeapons[w.key] || 0;
              const now = afterWeapons[w.key] || 0;
              const earned = r.weapons?.[w.key] || 0;
              const used = spent[w.key] || 0;
              const diff = now - was;
              const diffColor = diff > 0 ? '#86efac' : diff < 0 ? '#fca5a5' : '#e2e8f0';

              rows += `
  <div style="display:grid;grid-template-columns:34px 1fr 1fr 1fr 1fr;gap:10px;align-items:center;padding:10px 0;border-bottom:1px solid #334155;font-size:14px;">
    <div style="font-size:22px;">${w.emoji}</div>
    <div style="color:#94a3b8;">${format(was)}</div>
    <div style="color:#fb923c;text-align:center;font-weight:600;">−${used}</div>
    <div style="color:#86efac;text-align:center;font-weight:600;">+${format(earned)}</div>
    <div style="color:${diffColor};font-weight:700;text-align:right;font-size:15px;">${format(now)}</div>
  </div>`;
            });

            const statsHtml = `
<div style="margin-top:20px;padding:16px;background:rgba(15,23,42,0.95);border-radius:12px;border:1px solid #475569;">
  <div style="color:#94a3b8;margin-bottom:14px;font-weight:600;font-size:15px;">Статистика по оружию</div>
  <div style="display:grid;grid-template-columns:34px 1fr 1fr 1fr 1fr;gap:10px;padding-bottom:8px;border-bottom:1px solid #475569;font-size:13px;color:#64748b;">
    <div></div><div>Было</div><div style="text-align:center;">−</div><div style="text-align:center;">+</div><div style="text-align:right;">Стало</div>
  </div>
  ${rows}
</div>`;

            let lines = [`<div style="font-size:28px;color:#60a5fa;margin-bottom:12px;"><strong>${typeName}</strong></div>`];
            if (r.authority) lines.push(`<div><strong>Авторитет:</strong> +${r.authority}</div>`);
            if (r.currencies?.length) {
              const cur = r.currencies.map(c => c.type === 'cigarettes' ? `+${c.amount} папирос` : `+${c.amount} ₽`).join(', ');
              lines.push(`<div><strong>Валюта:</strong> ${cur}</div>`);
            }
            if (r.stash?.count) lines.push(`<div><strong>Нычки:</strong> +${r.stash.count} шт.</div>`);
            if (r.tattoos?.length) lines.push(`<div><strong>Тату:</strong> +${r.tattoos.length} шт.</div>`);

            // ─────── Строка Иглы в модалке ───────
            if (needleDamage > 0) {
              lines.push(`<div style="margin-top:20px;padding:14px;background:rgba(251,191,36,0.2);border:2px solid #fbbf24;border-radius:12px;font-size:22px;font-weight:900;color:#fbbf24;">
        Иглой добил: −${needleDamage.toLocaleString('ru-RU')} HP
      </div>`);
            }

            showModal({
              title: `Комбо выполнено! • ${killNumber}/${targetKills}`,
              content: `
  <div style="text-align:center;font-family:system-ui;">
    <div style="font-size:32px;margin-bottom:8px;">Готово!</div>
    ${lines.join('')}
    <div style="margin-top:16px;color:#94a3b8;font-size:14px;">
      Прогресс комбо: ${combo.progress || 0}/${combo.required || 0}
    </div>
    ${statsHtml}
  </div>
`,
              buttons: [{ label: 'Круто!', action: () => {} }]
            });

            rewardDiv.innerHTML = '<strong>Комбо + Игла (Если вкл.): готово!</strong>';
            rewardDiv.style.background = '#166534';

            // ─────── СРАЗУ ВЫХОДИМ ЗА МЫЛО ПОСЛЕ КОМБО ───────
            const surrenderSelect = block.querySelector('.boss-surrender');
            const killModeSelect = block.querySelector('.boss-kill-mode');
            const doSurrender = surrenderSelect?.value === 'yes' && killModeSelect?.value === 'odin';

            if (doSurrender) {
              rewardDiv.innerHTML = 'Выходим за мыло через 2 сек...';
              rewardDiv.style.background = '#7c2d12';
              rewardDiv.style.display = 'block';

              await new Promise(r => setTimeout(r, 2000));

              try {
                const res = await fetch('https://oldprison-prod.luckygem.online/api/boss/surrender', {
                  method: 'POST',
                  headers: {
                    'authorization': getAuthToken(),
                    'content-type': 'application/json'
                  },
                  credentials: 'include'
                });

                if (res.ok) {
                  rewardDiv.innerHTML = '<strong>Вышли за мыло</strong>';
                  console.log('%cВЫШЛИ ЗА МЫЛО после комбо', 'color:#fbbf24;background:#451a03;padding:10px 16px;border-radius:12px;font-weight:bold;');
                } else {
                  rewardDiv.innerHTML = 'Не удалось выйти за мыло';
                  rewardDiv.style.background = '#7f1d1d';
                }
              } catch (e) {
                console.warn('Ошибка surrender:', e);
                rewardDiv.innerHTML = 'Ошибка сети при выходе';
                rewardDiv.style.background = '#7f1d1d';
              }

              await new Promise(r => setTimeout(r, 1500));
            }


            return { completed: true };
          }

          // Если комбо не было, но игла была
          if (needleDamage > 0) {
            rewardDiv.innerHTML = `<strong>Иглой добил: −${needleDamage.toLocaleString('ru-RU')} HP</strong>`;
            rewardDiv.style.background = '#7c2d12';
          } else if (!text) {
            rewardDiv.innerHTML = '<strong>Готово</strong>';
            rewardDiv.style.background = '#166534';
          }

          return { completed: true };
        };

        btn.onclick = async function () {
          let currentSessionStart = 0;
          const isFromQueue = !!localStorage.getItem(`boss_queue_active_${boss.id}`);
          let queueSettings = null;
          activeBossAttacks++;

          // Сначала получаем все элементы формы ДО их использования!
          const killCountInput = block.querySelector('.boss-kill-count');
          const killModeSelect = block.querySelector('.boss-kill-mode');
          const comboModeSelect = block.querySelector('.boss-combo-mode');
          const doComboSelect = block.querySelector('.boss-do-combo');
          const buyKeysSelect = block.querySelector('.boss-buy-keys');
          const needleSelect = block.querySelector('.boss-needle');
          const textarea = block.querySelector('.boss-combo-textarea');
          const comboDelayInput = comboInputBlock.querySelector('.boss-combo-delay');

          // Берём значения из формы (по умолчанию)
          let targetKills = Math.min(Math.max(parseInt(killCountInput?.value || 1, 10), 1), 999);
          let mode = killModeSelect?.value || 'pacansky';
          let comboMode = comboModeSelect?.value || null;
          let doCombo = doComboSelect?.value === 'yes';
          let buyKeys = buyKeysSelect?.value || 'no';
          let currentKill = 0;
          let retry403Count = 0;
          const MAX_403_RETRIES = 3;
          let consecutive429 = 0;

          // Если босс запущен из очереди — берём настройки из localStorage (ПЕРЕОПРЕДЕЛЯЕМ ВСЁ!)
          if (isFromQueue) {
            try {
              queueSettings = JSON.parse(localStorage.getItem(`boss_queue_active_${boss.id}`));
              if (queueSettings) {
                targetKills = queueSettings.killCount ?? targetKills;
                mode = queueSettings.killMode ?? mode;
                comboMode = queueSettings.comboMode ?? comboMode;
                doCombo = !!queueSettings.doCombo;
                buyKeys = queueSettings.buyKeys ?? 'yes';
                currentKill = queueSettings.currentKill || 0;

                // Восстанавливаем текст и задержку комбо из очереди
                if (doCombo && queueSettings.comboText) {
                  textarea.value = queueSettings.comboText;
                }
                if (queueSettings.comboDelay) {
                  comboDelayInput.value = queueSettings.comboDelay;
                }
              }
            } catch (e) {
              console.warn("Ошибка чтения очереди", e);
            }
          }

          // Сохраняем настройки ТОЛЬКО если это обычный запуск (не из очереди)
          if (!isFromQueue) {
            localStorage.setItem(`boss_farm_${boss.id}`, JSON.stringify({
              killCount: targetKills,
              killMode: mode,
              comboMode: comboMode,
              doCombo: doCombo,
              comboText: doCombo ? textarea.value.trim() : '',
              comboDelay: comboDelayInput?.value || 1500,
              buyKeys: buyKeys,
              needle: needleSelect?.value || 'no',
              surrender: block.querySelector('.boss-surrender')?.value || 'no',
            }));
          }

          resetButton();
          let successfulStarts = 0;
          btn.disabled = true;
          stopAttacking = false;

          const buyOneKey = async () => {
            await sleep(6500 + Math.random() * 2000);
            try {
              const res = await fetch('https://oldprison-prod.luckygem.online/api/boss/buy-keys', {
                method: 'POST',
                headers: { 'authorization': getAuthToken(), 'content-type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify({ bossId: boss.id })
              });
              const data = await res.json();

              if (data.success) return true;

              let errorMsg = 'Не удалось купить ключ';
              if (data.message?.includes('paper')) errorMsg = 'НЕ ХВАТАЕТ БУМАГИ!';
              else if (data.message?.includes('рубл') || data.message?.includes('rubles')) errorMsg = 'НЕ ХВАТАЕТ РУБЛЕЙ!';
              else if (data.message) errorMsg = data.message.toUpperCase();

              rewardDiv.innerHTML = errorMsg;
              rewardDiv.style.background = '#7f1d1d';
              rewardDiv.style.display = 'block';
              stopAttacking = true;
              setTimeout(resetButton, 12000);
              return false;
            } catch (err) {
              rewardDiv.innerHTML = 'ОШИБКА СЕТИ';
              rewardDiv.style.background = '#7f1d1d';
              rewardDiv.style.display = 'block';
              stopAttacking = true;
              setTimeout(resetButton, 12000);
              return false;
            }
          };

          let lastSuccessfulStartTime = 0;          // время последнего УСПЕШНОГО старта (или "уже в бою")
          let lastAttemptTime = 0;                 // чтобы не спамить при докупке ключей
          const DELAY_AFTER_SUCCESS = 60_000;     // 60 секунд — не трогаем start-attack, если бой уже идёт
          const DELAY_BETWEEN_ATTEMPTS = 13_000; // между попытками при докупке ключей
          const tryAttack = async () => {
            const now = Date.now();

            // ─────── 1. Если недавно уже успешно стартанули (или сессия уже идёт) — больше не трогаем ───────
            if (isSessionActive) {
              btn.textContent = `Ожидаем смерти ${currentKill + 1}/${targetKills}...`;
              btn.style.background = '#1e40af';
              if (!monitorInterval) startMonitoring();
              return true;
            }

            // 2. Не спамим попытки при докупке ключей
            if (now - lastAttemptTime < DELAY_BETWEEN_ATTEMPTS) {
              await new Promise(r => setTimeout(r, DELAY_BETWEEN_ATTEMPTS - (now - lastAttemptTime) + 500));
            }
            lastAttemptTime = Date.now();

            const payload = { bossId: boss.id, mode };
            if (comboMode) payload.comboMode = comboMode;

            const res = await fetch('https://oldprison-prod.luckygem.online/api/boss/start-attack', {
              method: 'POST',
              headers: { 'authorization': getAuthToken(), 'content-type': 'application/json' },
              credentials: 'include',
              body: JSON.stringify(payload)
            });

            if (res.status === 429) {
              let consecutive429 = consecutive429 || 0;
              consecutive429++;

              if (consecutive429 > 4) {
                rewardDiv.innerHTML = `429 ×4 — не удаётся запустить бой, пропускаем`;
                rewardDiv.style.background = '#7f1d1d';
                rewardDiv.style.display = 'block';
                return false;
              }

              const wait = 3000 + consecutive429 * 2000; // 5 → 7 → 9 → 11 сек
              btn.textContent = `429 (${consecutive429}/4) — ждём ${Math.round(wait/1000)} сек`;
              btn.style.background = '#7c2d12';

              await new Promise(r => setTimeout(r, wait));
              return await tryAttack();
            } else {
              consecutive429 = 0;
            }

            if (res.status === 401 || res.status === 403) {
              console.log('%c401/403 на start-attack → принудительный релогин', 'color:#dc2626;background:#7f1d1d;padding:10px;border-radius:10px;font-weight:bold;');

              localStorage.removeItem('accessToken');
              localStorage.removeItem('refreshToken');

              const ok = await silentRelogin(true);
              if (!ok) return false;

              return await tryAttack(); // повторяем попытку
            }

            const data = await res.json();

            if (data.success) {
              lastSuccessfulStartTime = Date.now();
              currentSessionStart = Date.now();
              isSessionActive = true;
              successfulStarts++;
              await sleep(2000 + Math.random() * 1500); // даём сессии «устояться»
              if (!monitorInterval) startMonitoring();
              btn.textContent = `Идёт бой ${currentKill + 1}/${targetKills}...`;
              btn.style.background = '#ea580c';
              return true;
            }

            if (!data.success && (data.message || "").toLowerCase().includes('reward not claimed')) {
              console.log('%c"Reward not claimed" — пробуем заклеймить один раз', 'color:#fbbf24');
              const claimed = await claimBossReward();

              if (claimed) {
                console.log('%cClaim прошёл — повторяем атаку один раз', 'color:#86efac');
                await sleep(1500);
                return await tryAttack(); // только ОДИН повтор после успеха
              } else {
                // Не удалось заклеймить → пропускаем босса и идём дальше
                console.warn('%cНе удалось заклеймить награду — пропускаем босса', 'color:#ef4444');
                rewardDiv.innerHTML = 'НЕВОЗМОЖНО ЗАКЛЕЙМИТЬ — ПРОПУСК БОССА';
                rewardDiv.style.background = '#7f1d1d';
                rewardDiv.style.display = 'block';

                // Если это очередь — снимаем задачу, чтобы не висела
                if (isFromQueue) {
                  localStorage.removeItem(`boss_queue_active_${boss.id}`);
                }

                setTimeout(resetButton, 5000);
                return false; // выходим, бот перейдёт к следующему
              }
            }

            const msg = (data.message || "").toLowerCase();

            if (res.status === 403) {
              const msg = (data.message || "").toLowerCase();

              if (msg.includes('session in progress') ||
                msg.includes('already active') ||
                msg.includes('уже') ||
                msg.includes('активн')) {
                isSessionActive = true;
                btn.textContent = `Ожидаем смерти ${currentKill + 1}/${targetKills}...`;
                btn.style.background = '#1e40af';
                if (!monitorInterval) startMonitoring();
                return true;
              }

                // Не сессия → возможно, временная рассинхронизация
              if (retry403Count < MAX_403_RETRIES) {
                retry403Count++;
                console.log(`%c403 Forbidden (не сессия) — попытка ${retry403Count}/${MAX_403_RETRIES}, ждём и повторяем`, 'color:#fb923c;background:#451a03;padding:8px;border-radius:8px;');
                await sleep(8000 + Math.random() * 5000);
                return await tryAttack();
              }

              // Если ретраи кончились — считаем, что токен мёртвый
              console.log('%c403 после нескольких ретраев → принудительный релогин', 'color:#dc2626;background:#7f1d1d;padding:8px;border-radius:8px;');
              retry403Count = 0; // сброс на следующий цикл
              const ok = await silentRelogin(true);
              if (!ok) return false;
              return await tryAttack();
            }

            // Нет ключей → докупаем
            if (msg.includes('ключей') || msg.includes('key')) {
              if (buyKeys !== 'yes') {
                rewardDiv.innerHTML = 'НЕТ КЛЮЧЕЙ — ПРОПУСК';
                rewardDiv.style.background = '#7f1d1d';
                rewardDiv.style.display = 'block';
                if (isFromQueue) localStorage.removeItem(`boss_queue_active_${boss.id}`);
                setTimeout(resetButton, 5000);
                return false;
              }

              btn.textContent = 'Покупаем ключ...';
              const bought = await buyOneKey();
              if (!bought) return false;

              return await tryAttack();
            }

            // Лимит атак / отъезд / другая ошибка
            const isLimitOrAway = msg.includes('лимит') || msg.includes('отъезде') || msg.includes('до приезда');
            const reason = isLimitOrAway ? (msg.includes('лимит') ? 'ЛИМИТ АТАК' : 'В ОТЪЕЗДЕ') : 'ОШИБКА';

            console.log(`%c[Босс] ${boss.title} — ${reason} → пропускаем`, 'color:#ef4444;background:#450a0a;padding:8px 14px;border-radius:10px;font-weight:bold;');
            rewardDiv.innerHTML = `${reason} — ПРОПУСК`;
            rewardDiv.style.background = '#7f1d1d';
            rewardDiv.style.display = 'block';

            if (isFromQueue) localStorage.removeItem(`boss_queue_active_${boss.id}`);
            setTimeout(resetButton, 5000);
            return false;
          };

          const DELAY_BETWEEN_KILLS = 17500 + Math.floor(Math.random() * 3000);
          const CHECK_INTERVAL = 24000 + Math.floor(Math.random() * 8000);

          const startMonitoring = () => {
            if (monitorInterval) clearInterval(monitorInterval);

            monitorInterval = setInterval(async () => {
              if (stopAttacking || Date.now() < reloginCooldownUntil) return;

              let attempts = 0;
              let data = null;

              // Делаем до 4 попыток с релогином, если токен мёртвый
              while (attempts < 4) {
                try {
                  const rew = await fetch('https://oldprison-prod.luckygem.online/api/boss/rewards', {
                    headers: {
                      'authorization': getAuthToken(),
                      'content-type': 'application/json'
                    },
                    credentials: 'include'
                  });

                  if (rew.status === 401 || rew.status === 403) {
                    console.log('%cНаграда: 401/403 → принудительный релогин', 'color:#fb923c;background:#451a03;padding:8px;border-radius:8px;');
                    const ok = await silentRelogin(true);
                    if (!ok) await sleep(8000);
                    attempts++;
                    continue;
                  }

                  data = await rew.json();
                  break;
                } catch (e) {
                  attempts++;
                  await sleep(5000);
                }
              }

              if (!data?.success) {
                isSessionActive = false;
                return;
              }

              if (!data.rewards) return;

              const r = data.rewards;
              const isFromQueueTask = !!localStorage.getItem(`boss_queue_active_${boss.id}`);
              if (r.startedAt && currentSessionStart > 0) {
                let rewardStartMs;
                try {
                  let startedStr = String(r.startedAt).trim();
                  if (startedStr.endsWith('Z') || startedStr.includes('+') || startedStr.includes('-')) {
                    rewardStartMs = new Date(startedStr).getTime();
                  } else {
                    rewardStartMs = new Date(startedStr + 'Z').getTime();
                  }
                  if (isNaN(rewardStartMs) || rewardStartMs <= 0) {
                    console.warn('Невалидный startedAt:', r.startedAt);
                    return;
                  }
                  const timeDiffMs = rewardStartMs - currentSessionStart;
                  const diffSec = timeDiffMs / 1000;

                  // Ассиметричный буфер: -30 сек для ранних (старые сессии), +300 сек для поздних (лаги)
                  if (timeDiffMs < -30000 || timeDiffMs > 300000) {
                    console.log(
                      `%c[IGNORED SESSION MISMATCH] Разница слишком большая: ${diffSec.toFixed(1)} сек ` +
                      `(награда: ${new Date(rewardStartMs).toISOString()} | сессия: ${new Date(currentSessionStart).toISOString()})`,
                      'color:#fbbf24; background:#451a03; padding:6px 12px; border-radius:6px; font-size:12px;'
                    );
                    return;
                  }

                  // Лог для нормальных случаев
                  console.log(`[OK] Награда подходит, разница: ${diffSec.toFixed(1)} сек`);

                } catch (err) {
                  console.error('Ошибка парсинга startedAt:', err, r.startedAt);
                  return;
                }
              }

              if (!isFromQueueTask && r.bossId != null && r.bossId !== boss.id) return;

              currentKill++;

              if (localStorage.getItem(`boss_queue_active_${boss.id}`)) {
                const qs = JSON.parse(localStorage.getItem(`boss_queue_active_${boss.id}`) || '{}');
                qs.currentKill = currentKill;
                localStorage.setItem(`boss_queue_active_${boss.id}`, JSON.stringify(qs));
              }

              printVictoryToConsole(r, boss.title, currentKill, targetKills);
              invalidateWeaponCache();

              isSessionActive = false;
              lastSuccessfulStartTime = 0;

              let drop = '';
              if (r.globalReward) {
                const cigs = r.globalReward.currencies?.find(c => c.type === 'cigarettes')?.amount || 0;
                const sugar = r.globalReward.currencies?.find(c => c.type === 'sugar')?.amount || 0;
                const keys = r.globalReward.keys || 0;
                const auth = r.globalReward.authority || 0;
                drop = `${cigs ? '+' + cigs.toLocaleString() + ' сиги' : ''}${sugar ? ', +' + sugar.toLocaleString() + ' сахар' : ''}${keys ? ', +' + keys + ' ключей' : ''}${auth ? ', +' + auth + ' авт.' : ''}`.replace(/^, /, '');
                if (drop) drop = '<br>' + drop;
              }

              rewardDiv.innerHTML = `<strong>УБИТ! ${currentKill}/${targetKills}</strong>${drop}`;
              rewardDiv.style.background = '#166534';
              rewardDiv.style.display = 'block';

              btn.textContent = `Убит ${currentKill}/${targetKills}`;
              btn.style.background = '#16a34a';

              if (currentKill < targetKills) {
                setTimeout(() => launchNextCycle(), 3000 + Math.random() * 3000);
              } else {
                localStorage.removeItem(`boss_farm_${boss.id}`);
                if (isFromQueue) localStorage.removeItem(`boss_queue_active_${boss.id}`);
                rewardDiv.innerHTML = `<strong>ГОТОВО! Убито: ${currentKill}</strong>`;
                btn.textContent = 'ГОТОВО';
                btn.style.background = '#166534';
                currentSessionStart = 0;
                clearInterval(monitorInterval);
                monitorInterval = null;
                setTimeout(() => {
                  resetButton();
                  activeBossAttacks--;
                }, 8000);
              }
            }, CHECK_INTERVAL);
          };

          const launchNextCycle = async () => {
            currentSessionStart = 0;
            if (stopAttacking || currentKill >= targetKills) {
              if (currentKill >= targetKills) {
                localStorage.removeItem(`boss_farm_${boss.id}`);
                if (isFromQueue) localStorage.removeItem(`boss_queue_active_${boss.id}`);
                rewardDiv.innerHTML = `<strong>ГОТОВО! Убито: ${currentKill}</strong>`;
                btn.textContent = 'ГОТОВО';
                btn.style.background = '#166534';
                clearInterval(monitorInterval);
                monitorInterval = null;
                setTimeout(resetButton, 8000);
              }
              return;
            }

            if (currentKill > 0 && currentKill % 3 === 0) { // каждые 3 убийства
              const ok = await forceReloginBeforeAttack();
              if (!ok) return;
              await new Promise(r => setTimeout(r, 1200));
            }


            // Даём серверу время закрыть сессию после получения награды
            btn.textContent = `Ждём завершения сессии... (${currentKill + 1}/${targetKills})`;
            btn.style.background = '#1e40af';

            // Ждём минимум 10-13 секунд после убийства
            await sleep(10000 + Math.random() * 4000);


            btn.textContent = `Атака ${currentKill + 1}/${targetKills}...`;
            btn.style.background = '#ea580c';

            const attackOk = await tryAttack();
            if (!attackOk) return;

            if (!monitorInterval) {
              startMonitoring();
            }

            if (doCombo) {
              btn.textContent = `Комбо ${currentKill + 1}/${targetKills}...`;
              btn.style.background = '#7c2d12';

              const result = await executeBossCombo(currentKill + 1);

              if (result.bossDiedEarly || result.interrupted) {
                btn.textContent = `Ожидаем награду ${currentKill + 1}/${targetKills}...`;
                btn.style.background = '#1e40af';
                return;
              }

              if (result.completed) {
                btn.textContent = `Ожидаем смерть ${currentKill + 1}/${targetKills}...`;
                btn.style.background = '#1e40af';
                return;
              }

              rewardDiv.innerHTML = 'Комбо прервано';
              rewardDiv.style.background = '#7f1d1d';
              stopAttacking = true;
              setTimeout(resetButton, 6000);
              return;
            }

            btn.textContent = `Ожидаем смерть ${currentKill + 1}/${targetKills}...`;
            btn.style.background = '#1e40af';
          };

          launchNextCycle();
        };

        btn.ondblclick = e => {
          e.preventDefault();
          stopAttacking = true;
          clearInterval(monitorInterval);
          localStorage.removeItem(`boss_farm_${boss.id}`);
          rewardDiv.innerHTML = 'ОСТАНОВЛЕНО';
          rewardDiv.style.background = '#7f1d1d';
          rewardDiv.style.display = 'block';
          setTimeout(() => {
            resetButton();
            activeBossAttacks--;
          }, 5000);
        };
      });

    } catch (err) {
      container.innerHTML = `<div style="text-align:center;color:#f87171;padding:140px;">Ошибка: ${err.message}</div>`;
    }
  }

  function renderQueuePanel() {
    const container = document.querySelector('#tp-bosses-panel #bosses-panel-content');
    if (!container) return;

    container.innerHTML = `
    <div style="padding:30px 20px; color:#e2e8f0; min-height:600px;">
      <h2 style="text-align:center; margin-bottom:30px; font-size:28px; font-weight:900; color:#86efac;">
        Очередь атаки боссов
      </h2>
      
      <div id="queue-list" style="display:flex; flex-direction:column; gap:22px; margin-bottom:40px;">
        ${bossQueue.length === 0
      ? '<div style="text-align:center; padding:140px 20px; color:#64748b; font-size:22px; font-weight:600;">Очередь пуста<br><small style="color:#475569;">Добавляйте боссов из вкладок «Беспредельщики» / «Вертухаи»</small></div>'
      : ''
    }
      </div>

      <div style="text-align:center; display:flex; gap:18px; justify-content:center; flex-wrap:wrap;">
        <button id="queue-start-all" style="padding:20px 70px; background:#22c55e; color:white; border:none; border-radius:16px; font-size:22px; font-weight:800; cursor:pointer; box-shadow:0 8px 25px rgba(34,197,94,0.4);">
          АТАКОВАТЬ ВСЕХ (${bossQueue.length})
        </button>
        <button id="queue-stop" style="display:none; padding:20px 50px; background:#dc2626; color:white; border:none; border-radius:16px; font-size:20px; font-weight:700; cursor:pointer;">
          ОСТАНОВИТЬ
        </button>
        <button id="queue-clear" style="padding:18px 45px; background:#475569; color:white; border:none; border-radius:16px; font-size:18px; cursor:pointer;">
          Очистить очередь
        </button>
      </div>
    </div>
  `;

    renderQueueList();
    setupQueueButtons();
  }

  function renderQueueList() {
    const list = document.getElementById('queue-list');
    if (!list || bossQueue.length === 0) return;

    const modeNames = {
      pacansky: 'Пацанский', blotnoy: 'Блатной',
      avtoritetny: 'Авторитетный', odin: 'В одного',
      silovik: 'Силовик', vor: 'Вор', bandit: 'Бандит', muzhik: 'Мужик'
    };

    list.innerHTML = bossQueue.map((item, index) => {
      const b = item.boss;
      const s = item.settings;

      const killMode = modeNames[s.killMode] || s.killMode || '—';
      const comboMode = s.comboMode ? (modeNames[s.comboMode] || s.comboMode) : '—';
      const comboText = s.doCombo && s.comboText ? `${s.comboText.substring(0, 35)}${s.comboText.length > 35 ? '…' : ''}` : '—';
      const buyKeys = s.buyKeys === 'yes' ? 'Да' : 'Нет';

      return `
      <div style="background:#1e293b; border-radius:16px; padding:20px; border:2px solid #334155; position:relative;">
        <div style="position:absolute; top:12px; right:16px; color:#64748b; font-size:14px; font-weight:600;">
          #${index + 1}
        </div>

        <div style="display:flex; align-items:center; gap:16px; margin-bottom:16px;">
          <div style="font-size:24px; font-weight:900; color:#e2e8f0;">${b.title}</div>
          <div style="color:#94a3b8; font-size:14px; margin-left:auto;">
            ${b.cat === 1 ? 'Беспредельщики' : 'Вертухаи'}
          </div>
        </div>

        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(210px, 1fr)); gap:16px; font-size:15px;">
          <div><div style="color:#64748b; margin-bottom:4px;">Убить раз</div>
              <div style="color:#86efac; font-weight:800; font-size:18px;">${s.killCount}</div></div>
          <div><div style="color:#64748b; margin-bottom:4px;">Режим убийства</div>
              <div style="color:#60a5fa; font-weight:700;">${killMode}</div></div>
          <div><div style="color:#64748b; margin-bottom:4px;">Комбо</div>
              <div style="color:${s.doCombo ? '#86efac' : '#64748b'}; font-weight:700;">${s.doCombo ? 'Да' : 'Нет'}</div></div>
          ${s.comboMode ? `<div><div style="color:#64748b; margin-bottom:4px;">Режим комбо</div>
              <div style="color:#f59e0b; font-weight:700;">${comboMode}</div></div>` : ''}
          <div><div style="color:#64748b; margin-bottom:4px;">Докупать ключи</div>
              <div style="color:${s.buyKeys === 'yes' ? '#86efac' : '#fb923c'}; font-weight:700;">${buyKeys}</div></div>
                        ${['Сизый', 'Махно', 'Палыч', 'Лютый', 'Циклоп', 'Бес'].some(name => b.title.includes(name)) ? `
          <div><div style="color:#64748b; margin-bottom:4px;">Добивать Иглой?</div>
              <div style="color:${s.needle === 'yes' ? '#86efac' : '#fb923c'}; font-weight:700;">${s.needle === 'yes' ? 'Да' : 'Нет'}</div></div>
              
          ` : ''}
                    <div><div style="color:#64748b; margin-bottom:4px;">Выйти за мыло после комбо?</div>
              <div style="color:${s.surrender === 'yes' ? '#86efac' : '#fb923c'}; font-weight:700;">${s.surrender === 'yes' ? 'Да' : 'Нет'}</div></div>              
                        
          
          ${s.doCombo && s.comboText ? `
<div style="grid-column:1/-1; margin-top:12px;">
  <div style="color:#64748b; margin-bottom:8px; font-size:14px;">Текст комбо</div>
  <div style="background:#334155; padding:14px; border-radius:12px; border:1px solid #475569; 
              max-height:180px; overflow-y:auto; font-family:monospace; font-size:13px; 
              color:#e2e8f0; line-height:1.5; white-space:pre-wrap; word-break:break-all;">
    ${s.comboText.replace(/</g, '&lt;').replace(/>/g, '&gt;')}
  </div>
</div>` : ''}
        </div>

        <button class="queue-remove-btn" data-index="${index}" style="margin-top:16px; padding:8px 20px; background:#7f1d1d; color:white; border:none; border-radius:10px; font-size:14px; cursor:pointer;">
          Удалить из очереди
        </button>
      </div>
    `;
    }).join('');

    // Кнопка удаления
    document.querySelectorAll('.queue-remove-btn').forEach(btn => {
      btn.onclick = () => {
        const idx = parseInt(btn.dataset.index);
        bossQueue.splice(idx, 1);
        localStorage.setItem('boss_queue_v6', JSON.stringify(bossQueue));
        renderQueuePanel();
        // showSuccess?.('Очередь', 'Босс удалён');
      };
    });
  }

  function createComboInputBlock() {
    const wrapper = document.createElement('div');
    wrapper.className = 'boss-combo-wrapper';
    wrapper.style.cssText = `
    margin-top:12px; padding:14px; background:rgba(30,41,59,0.7);
    border-radius:12px; border:1px solid #475569; display:none; flex-direction:column; gap:10px;
  `;

    wrapper.innerHTML = `
    <textarea class="boss-combo-textarea" placeholder="Вставьте комбо (Ухо → Пах → Глаза...)" 
              style="width:100%; height:80px; padding:10px; background:#334155; color:white; border:1px solid #475569; border-radius:8px; resize:vertical; font-size:13px;"></textarea>

    <div style="display:flex; gap:8px; align-items:center;">
      <label style="color:#94a3b8; font-size:13px; white-space:nowrap;">Задержка (мс):</label>
      <input type="number" class="boss-combo-delay" value="1500" min="800" 
             style="width:80px; padding:6px; background:#334155; color:white; border:1px solid #475569; border-radius:8px;">
    </div>

    <div class="boss-combo-preview" style="padding:10px; background:rgba(15,23,42,0.8); border-radius:10px; font-size:12px; color:#e2e8f0;">
      <div><strong>Всего:</strong> <span id="bc-total">0</span> | 
           <strong>Беспл.:</strong> <span id="bc-free">0</span> | 
           <strong>Платно:</strong> <span id="bc-paid">0</span></div>
      <div style="margin-top:6px;" id="bc-details"></div>
    </div>
  `;

    return wrapper;
  }

  const weaponConfig = [
    { keys: ["ухо","колено","по уху","в ухо"], weapon: "kneeEar",    restore: "KneeEar",    name: "Ухо/Колено",    freeFirst: true,  cost: 3 },
    { keys: ["пах","по яйцам","в пах","яйца"], weapon: "kickBalls",  restore: "KickBalls",  name: "Пах",           freeFirst: true,  cost: 3 },
    { keys: ["глаза","глаз","палец в глаз","по глазу","в глаз","тык в глаз"], weapon: "pokeEyes", restore: "PokeEyes", name: "Глаза", freeFirst: true, cost: 3 },
    { keys: ["грудь","удар в грудь","по груди","в грудь","кулаком в грудь"], weapon: "punchChest", restore: "PunchChest", name: "Грудь", freeFirst: true, cost: 3 },
    { keys: ["яд","отравить","ядом"], weapon: "poison", restore: null, name: "Яд", freeFirst: false, cost: 18 },
    { keys: ["финка","фин","нож","ножом","финкой"], weapon: "knife", restore: null, name: "Финка", freeFirst: false, cost: 4 },
    { keys: ["самопал","пал","выстрел","стрелять","пистолет"], weapon: "gunshot", restore: null, name: "Самопал", freeFirst: false, cost: 5 }
  ];

  const weaponsDict = {};
  weaponConfig.forEach(c => c.keys.forEach(k => weaponsDict[k.toLowerCase()] = {weapon:c.weapon, restore:c.restore, freeFirst:c.freeFirst, cost:c.cost, name:c.name}));

  function parseAndAnalyzeCombo(text, previewEl) {
    if (!text.trim()) {
      previewEl.querySelector('#bc-total').textContent = '0';
      previewEl.querySelector('#bc-free').textContent = '0';
      previewEl.querySelector('#bc-paid').textContent = '0';
      previewEl.querySelector('#bc-details').innerHTML = '';
      return [];
    }

    const lines = text.split('\n').map(l => l.replace(/^\d+[\.\)\-\–\—\_\•\*]\s*/g,'').trim());
    const moves = [];
    lines.forEach(l => {
      const words = l.split(/[\s,.;:!?()[\]{}—–\-_+/\\|]+/);
      words.forEach(w => {
        let clean = w.replace(/[^а-яА-ЯёЁ]/g,'').toLowerCase();
        if (clean && weaponsDict[clean]) moves.push(clean);
      });
    });

    const usage = {};
    moves.forEach(m => { const w = weaponsDict[m]; if (w) usage[w.weapon] = (usage[w.weapon]||0)+1; });

    let free = 0, paid = 0;
    const details = [];

    Object.entries(usage).forEach(([weapon, cnt]) => {
      const cfg = weaponConfig.find(c=>c.weapon===weapon);
      if (!cfg) return;
      if (cfg.freeFirst) { free++; if (cnt>1) { paid += cnt-1; } }
      else { paid += cnt; }
      const paidPart = cfg.freeFirst ? (cnt>1 ? cnt-1 : 0) : cnt;
      const suffix = paidPart ? ` <small style="color:#f59e0b">(${paidPart}×${cfg.cost}₽)</small>` : cfg.freeFirst ? ` <small style="color:#34d399">(беспл.)</small>` : '';
      details.push(`${cfg.name} ×${cnt}${suffix}`);
    });

    previewEl.querySelector('#bc-total').textContent = moves.length;
    previewEl.querySelector('#bc-free').textContent = free;
    previewEl.querySelector('#bc-paid').textContent = paid;
    previewEl.querySelector('#bc-details').innerHTML = details.join(' • ') || '<span style="color:#94a3b8">Только бесплатные</span>';

    return moves;
  }

  let bossQueue = JSON.parse(localStorage.getItem('boss_queue_v6') || '[]');
  let isQueueRunning = false;
  let queueStopRequested = false;

  function setupQueueButtons() {
    const startBtn = document.getElementById('queue-start-all');
    const stopBtn  = document.getElementById('queue-stop');
    const clearBtn = document.getElementById('queue-clear');

    if (startBtn) {
      startBtn.onclick = () => {
        if (bossQueue.length === 0) {
          showError?.('Очередь', 'Очередь пуста');
          return;
        }
        startQueueAttack();
      };
    }

    if (stopBtn) {
      stopBtn.onclick = () => {
        queueStopRequested = true;
        showSuccess?.('Очередь', 'Остановка после текущего босса...');
      };
    }

    if (clearBtn) {
      clearBtn.onclick = () => {
        // Красивое модальное окно вместо alert
        showModal?.({
          title: 'Очистить очередь?',
          content: `<div style="text-align:center;padding:20px 10px;font-size:18px;color:#e2e8f0;">
                    В очереди <b>${bossQueue.length}</b> боссов<br><br>
                    Вы уверены, что хотите всё удалить?
                  </div>`,
          buttons: [
            {
              label: 'Отмена',
              style: 'background:#475569;',
              action: () => {}
            },
            {
              label: 'Да, очистить',
              style: 'background:#dc2626; margin-left:12px;',
              action: () => {
                bossQueue = [];
                localStorage.removeItem('boss_queue_v6');
                renderQueuePanel();
                // showSuccess?.('Очередь', 'Очередь очищена');
              }
            }
          ]
        });
      };
    }
  }

  async function startQueueAttack() {
    if (isQueueRunning || bossQueue.length === 0) return;
    await claimBossReward();
    await sleep(1200);


    // Защита от зависших задач из прошлых запусков
    Object.keys(localStorage)
      .filter(k => k.startsWith('boss_queue_active_'))
      .forEach(k => {
        try {
          const task = JSON.parse(localStorage.getItem(k) || '{}');
          if (!task.isQueueTask) return;
          console.log('%cОчистка зависшей задачи:', k);
          localStorage.removeItem(k);
        } catch {}
      });

    isQueueRunning = true;
    queueStopRequested = false;

    const startBtn = document.getElementById('queue-start-all');
    const stopBtn = document.getElementById('queue-stop');
    if (startBtn) startBtn.style.display = 'none';
    if (stopBtn) stopBtn.style.display = 'inline-block';

    showSuccess?.('Очередь', `Запуск: ${bossQueue.length} боссов`);

    for (let i = 0; i < bossQueue.length; i++) {
      if (queueStopRequested) break;

      const { id, title, cat } = bossQueue[i].boss;
      const settings = bossQueue[i].settings;

      showSuccess?.('Очередь', `${i + 1}/${bossQueue.length} → ${title}`);

      console.log('%c[ОЧЕРЕДЬ] Принудительный claim перед новым боссом', 'color:#fbbf24');
      await claimBossReward();
      await sleep(1500);

      // === Поиск босса в очереди ===
      let bossBlock = null;
      let attempts = 0;
      const MAX_ATTEMPTS = 80;

      const catBtn = document.querySelector(`.boss-tab-btn[data-cat="${cat}"]`);

      // Один раз переключаемся на нужную вкладку (если ещё не на ней)
      if (catBtn && !catBtn.classList.contains('active')) {
        catBtn.click();
        await sleep(1800);
      }

      while (!bossBlock && attempts < MAX_ATTEMPTS && !queueStopRequested) {
        attempts++;

        if (!document.getElementById('tp-bosses-panel')) {
          console.warn('%c[ОЧЕРЕДЬ] Панель закрыта — прерываем очередь', 'color:#dc2626;font-weight:bold;');
          queueStopRequested = true;
          break;
        }

        bossBlock = Array.from(document.querySelectorAll('#bosses-panel-content > div'))
          .find(div => {
            // Ищем заголовок босса
            const header = div.querySelector('div[style*="font-size:22px"][style*="font-weight:800"]')
              || div.querySelector('div[style*="font-size: 22px"]')
              || div.querySelector('div[style*="font-weight:800"]')
              || div.querySelector('div[style*="font-weight: 900"]');

            if (!header) return false;

            const bossTitle = header.textContent.trim();

            // Точное совпадение по названию
            return bossTitle === title && div.querySelector('.boss-attack-btn');
          });

        if (!bossBlock) {
          // Только раз в ~15 секунд мягко обновляем вкладку
          if (attempts % 10 === 0 && catBtn) {
            catBtn.click();
            await sleep(1600);
          }
          await sleep(1500 + Math.random() * 1000);
        }
      }

      if (!bossBlock) {
        showError?.('Очередь', `Не найден: ${title}<br><br>Проверь вкладку вручную`);
        continue;
      }

      const attackBtn = bossBlock.querySelector('.boss-attack-btn');
      if (!attackBtn || attackBtn.disabled || !attackBtn.textContent.includes('АТАКОВАТЬ')) {
        showError?.('Очередь', `Кнопка неактивна: ${title}<br><br>Возможно лимит или отъезд`);
        continue;
      }

      // 3. Восстанавливаем настройки в форму + сохраняем как активную задачу
      localStorage.setItem(`boss_queue_active_${id}`, JSON.stringify({
        ...settings,
        currentKill: 0,
        isQueueTask: true,
        fromQueue: true
      }));

      const fillForm = () => {
        try {
          const killCount    = bossBlock.querySelector('.boss-kill-count');
          const killMode     = bossBlock.querySelector('.boss-kill-mode');
          const comboMode    = bossBlock.querySelector('.boss-combo-mode');
          const doComboSel   = bossBlock.querySelector('.boss-do-combo');
          const textarea     = bossBlock.querySelector('.boss-combo-textarea');
          const delay        = bossBlock.querySelector('.boss-combo-delay');
          const buyKeys      = bossBlock.querySelector('.boss-buy-keys');
          const needle       = bossBlock.querySelector('.boss-needle');
          const comboWrapper = bossBlock.querySelector('.boss-combo-wrapper');

          if (killCount)    killCount.value    = settings.killCount || 1;
          if (killMode)     killMode.value     = settings.killMode  || 'pacansky';
          if (comboMode && settings.comboMode) comboMode.value = settings.comboMode;

          if (doComboSel)   doComboSel.value   = settings.doCombo ? 'yes' : 'no';
          if (comboWrapper) comboWrapper.style.display = settings.doCombo ? 'flex' : 'none';

          if (textarea && settings.doCombo && settings.comboText) {
            textarea.value = settings.comboText;
            const preview = bossBlock.querySelector('.boss-combo-preview');
            if (preview) parseAndAnalyzeCombo(settings.comboText, preview);
          }
          if (delay && settings.comboDelay) delay.value = settings.comboDelay;

          if (buyKeys && settings.buyKeys !== undefined) {
            buyKeys.value = settings.buyKeys;
          }
          if (needle && settings.needle !== undefined) {
            needle.value = settings.needle;
          }
          const surrenderSel = bossBlock.querySelector('.boss-surrender');
          if (surrenderSel && settings.surrender !== undefined) {
            surrenderSel.value = settings.surrender;
          }

        } catch (err) {
          console.error('Ошибка fillForm в очереди:', err);
        }
      };

      setTimeout(fillForm, 400);

      setTimeout(fillForm, 300);

      attackBtn.scrollIntoView({ behavior: "smooth", block: "center" });
      await sleep(1000);
      attackBtn.click();

      console.log('%cОЧЕРЕДЬ → Принудительный релогин перед стартом атаки босса', 'color:#fbbf24;background:#451a03;padding:10px 20px;border-radius:12px;font-weight:bold;');
      localStorage.removeItem('accessToken');
      localStorage.removeItem('refreshToken');
      const reloginOk = await silentRelogin(true);
      if (!reloginOk) {
        showError('Очередь', 'Не удалось обновить токен перед атакой — босс пропущен');
        continue;
      }
      await sleep(800 + Math.random() * 700);


      attackBtn.click();
      await sleep(3000 + Math.random() * 2000);


      // 4. Ждём окончания фарма — пока кнопка не станет снова "АТАКОВАТЬ"
      let waitedSeconds = 0;
      const MAX_WAIT_SECONDS = 7200;

      console.log(`%c[ОЧЕРЕДЬ] Ожидание завершения: ${title}`, 'color:#f59e0b;font-weight:bold;');

      while (waitedSeconds < MAX_WAIT_SECONDS && !queueStopRequested) {
        await sleep(9000);
        waitedSeconds += 9;

        // Кулдаун 429 — просто ждём
        if (Date.now() < reloginCooldownUntil) {
          continue;
        }

        const btn = bossBlock.querySelector('.boss-attack-btn');
        const buttonReady = btn &&
          (btn.textContent.trim() === 'АТАКОВАТЬ' || btn.textContent.trim() === 'ГОТОВО') &&
          !btn.disabled;

        const hasActiveTask = localStorage.getItem(`boss_queue_active_${id}`);

        // Успешное завершение: кнопка готова + задача удалена
        if (buttonReady && !hasActiveTask) {
          console.log(`%c[ОЧЕРЕДЬ] ${title} — завершён идеально (кнопка + нет задачи)`, 'color:#16a34a;font-weight:bold;');
          localStorage.removeItem(`boss_queue_active_${id}`); // на всякий случай
          break;
        }

        // Каждые ~30 сек проверяем по API — вдруг добили иглой/общаком
        if (waitedSeconds % 30 < 9) {
          try {
            const res = await fetch(`https://oldprison-prod.luckygem.online/api/boss/list?categoryId=${cat}`, {
              headers: { authorization: getAuthToken() },
              credentials: 'include'
            });
            const data = await res.json();
            if (data.success && !data.bosses?.some(b => b.boss.id === id)) {
              console.log(`%c[ОЧЕРЕДЬ] ${title} — убит кем-то другим (по API)`, 'color:#fb923c;font-weight:bold;');
              localStorage.removeItem(`boss_queue_active_${id}`);
              showSuccess?.('Уже убит', `${title} добит кем-то — пропускаем`);
              break;
            }
          } catch (e) {
            // Игнорируем ошибки сети
          }
        }
      }

      // Таймаут — принудительно продолжаем
      if (waitedSeconds >= MAX_WAIT_SECONDS) {
        console.warn(`%c[ОЧЕРЕДЬ] ТАЙМАУТ 2ч: ${title} — принудительно продолжаем`, 'color:#dc2626;font-weight:bold;');
        localStorage.removeItem(`boss_queue_active_${id}`);
      }

      showSuccess?.('Очередь', `Готово: ${title}`);

      // Пауза перед следующим боссом
      if (i < bossQueue.length - 1) {
        await sleep(12000 + Math.random() * 10000);
      }
    }

    // Финал
    isQueueRunning = false;
    if (startBtn) startBtn.style.display = 'inline-block';
    if (stopBtn) stopBtn.style.display = 'none';

    renderQueuePanel();

    if (queueStopRequested) {
      showSuccess?.('Очередь', 'Остановлено');
    } else {
      showSuccess?.('ГОТОВО!', 'Все боссы из очереди атакованы');
    }
  }

  function sleep(ms) {
    return new Promise(r => setTimeout(r, ms));
  }

    async function claimBossReward() {
      try {
        const res = await fetch('https://oldprison-prod.luckygem.online/api/boss/claim', {
          method: 'POST',
          headers: {
            'authorization': getAuthToken(),
            'content-type': 'application/json'
          },
          credentials: 'include',
          body: JSON.stringify({})
        });

        if (res.status === 429) {
          console.warn('429 на claim — ждём 10 сек и пропускаем');
          await sleep(10000);
          return false;
        }

        if (res.status === 401 || res.status === 403) {
          console.log('%c401/403 на claim — релогин один раз', 'color:#fbbf24');
          localStorage.removeItem('accessToken');
          localStorage.removeItem('refreshToken');
          const ok = await silentRelogin(true);
          if (ok) {
            // Повтор 1: после релогина
            const retryRes1 = await fetch('https://oldprison-prod.luckygem.online/api/boss/claim', {
              method: 'POST',
              headers: {
                'authorization': getAuthToken(),
                'content-type': 'application/json'
              },
              credentials: 'include',
              body: JSON.stringify({})
            });

            if (retryRes1.ok) {
              const data = await retryRes1.json();
              if (data.success && data.status === "claimed") {
                console.log('%cЗаклеймлено после 1 релогина', 'color:#86efac');
                return true;
              }
            }

            // Если не прошло — ещё один релогин и повтор 2
            console.log('%cПовторный релогин для claim', 'color:#fbbf24');
            localStorage.removeItem('accessToken');
            localStorage.removeItem('refreshToken');
            const ok2 = await silentRelogin(true);
            if (ok2) {
              const retryRes2 = await fetch('https://oldprison-prod.luckygem.online/api/boss/claim', {
                method: 'POST',
                headers: {
                  'authorization': getAuthToken(),
                  'content-type': 'application/json'
                },
                credentials: 'include',
                body: JSON.stringify({})
              });

              if (retryRes2.ok) {
                const data = await retryRes2.json();
                if (data.success && data.status === "claimed") {
                  console.log('%cЗаклеймлено после 2 релогина', 'color:#86efac');
                  return true;
                }
              }
            }
          }
          console.warn('Релогины не помогли — claim провален');
          return false;
        }

        if (!res.ok) {
          const txt = await res.text();
          console.warn('Claim failed:', res.status, txt);
          return false;
        }

        const data = await res.json();
        if (data.success && data.status === "claimed") {
          console.log('%cНаграда успешно заклеймлена', 'color:#86efac');
          return true;
        }

        console.warn('Claim не success:', data);
        return false;

      } catch (err) {
        console.error('Ошибка сети при claim:', err);
        return false;
      }
    }

  let vpiCache = null;
  let vpiCacheTime = 0;
  const VPI_CACHE_TTL = 60_000;

  async function fetchVPIState() {
    const now = Date.now();
    if (vpiCache && (now - vpiCacheTime) < VPI_CACHE_TTL) {
      return vpiCache;
    }

    try {
      const token = getAuthToken();
      if (!token) return null;

      const res = await fetch('https://oldprison-prod.luckygem.online/api/vpi/state', {
        method: 'GET',
        headers: { 'authorization': token },
        credentials: 'include'
      });

      if (!res.ok) throw new Error('HTTP ' + res.status);
      const data = await res.json();

      vpiCache = data;
      vpiCacheTime = now;
      return data;
    } catch (e) {
      console.warn('Не удалось получить состояние Общака:', e);
      return null;
    }
  }


  let isVpiRendering = false;
  function renderVPIInfo(forceRefresh = false) {
    if (isVpiRendering) return;
    isVpiRendering = true;

    document.querySelectorAll('#tp-vpi-info').forEach(el => el.remove());

    const queueBtn = document.querySelector('.boss-tab-btn[data-cat="queue"]');
    if (!queueBtn || !queueBtn.classList.contains('active')) return;

    // Принудительно сбрасываем кэш
    if (forceRefresh) {
      vpiCache = null;
      vpiCacheTime = 0;
    }

    fetchVPIState().then(state => {

      const container = document.querySelector('#bosses-panel-content');
      if (!container) {
        isVpiRendering = false;
        return;
      }

      if (!state || !state.active) {
        const noVpi = document.createElement('div');
        noVpi.id = 'tp-vpi-info';
        noVpi.style.cssText = `margin:20px 30px 0;padding:18px 24px;background:linear-gradient(135deg,#1e293b,#111827);border:2px solid #475569;border-radius:20px;text-align:center;color:#cbd5e1;font-size:18px;font-weight:700;box-shadow:0 8px 32px rgba(0,0,0,0.4);`;
        noVpi.innerHTML = `Общак не активирован`;
        document.querySelector('#bosses-panel-content')?.prepend(noVpi);
        return;
      }

      const tierInfo = {
        pacansky:    { title: "Пацанский",    color: "#60a5fa" },
        blotnoy:     { title: "Блатной",      color: "#f59e0b" },
        avtoritetny: { title: "Авторитетный", color: "#10b981" },
        vorovskoy:   { title: "Воровской",    color: "#a78bfa" }
      };

      const info = tierInfo[state.tier] || { title: state.tier, color: "#94a3b8" };
      const damageLeft = (state.damageLeft || 0).toLocaleString('ru-RU');
      const maxDamage = state.nextDailyPreview?.damage ||
        (state.offer?.tiers || []).find(t => t.id === state.tier)?.dailyDamage || 0;
      const percent = maxDamage > 0 ? Math.round((state.damageLeft || 0) / maxDamage * 100) : 0;

      const panel = document.createElement('div');
      panel.id = 'tp-vpi-info';
      panel.style.cssText = `margin:20px 30px 0;padding:20px 28px;background:linear-gradient(135deg,#1e293b,#111827);border:3px solid ${info.color};border-radius:24px;color:#e2e8f0;font-family:system-ui;box-shadow:0 12px 40px rgba(0,0,0,0.6);position:relative;overflow:hidden;`;

      panel.innerHTML = `
      <div style="position:absolute;top:0;left:0;right:0;height:6px;background:rgba(255,255,255,0.1);">
        <div style="width:${percent}%;height:100%;background:${info.color};transition:width 0.8s ease;"></div>
      </div>
      <div style="display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:16px;">
        <div style="text-align:left;">
          <div style="font-size:15px;color:#94a3b8;margin-bottom:6px;">Активный Общак</div>
          <div style="font-size:28px;font-weight:900;color:${info.color};">${info.title}</div>
        </div>
        <div style="text-align:right;">
          <div style="font-size:15px;color:#94a3b8;margin-bottom:6px;">Остаток урона от Иглы (сегодня)</div>
          <div style="font-size:26px;font-weight:800;color:#86efac;">
            ${damageLeft} <span style="font-size:18px;color:#64748b;">/ ${maxDamage.toLocaleString('ru-RU')}</span>
          </div>
          <div style="margin-top:6px;font-size:14px;color:#cbd5e1;">${percent}% от дневного лимита</div>
        </div>
      </div>
      ${percent <= 20 ? `<div style="margin-top:20px;padding:12px;background:rgba(239,68,68,0.2);border:1px solid #ef4444;border-radius:12px;color:#fca5a5;font-weight:700;text-align:center;">
        ВНИМАНИЕ! Осталось мало урона — скоро общак закончится!
      </div>` : ''}
    `;

      container.prepend(panel);
      // Снимаем флаг — можно рисовать снова
      isVpiRendering = false;
    }).catch(() => {
      isVpiRendering = false;
    });
  }

  // Перехватываем рендер очереди
  const originalRenderQueuePanel = renderQueuePanel;
  renderQueuePanel = function() {
    originalRenderQueuePanel.apply(this, arguments);
    setTimeout(() => renderVPIInfo(true), 350);
  };

  // Перехватываем клики по вкладкам (включая программные)
  document.addEventListener('click', e => {
    if (e.target.closest('.boss-tab-btn[data-cat="queue"]')) {
      setTimeout(() => renderVPIInfo(true), 350);
    }
  });

  // Автообновление каждые 5 минут
  setInterval(() => {
    const queueBtn = document.querySelector('.boss-tab-btn[data-cat="queue"]');
    if (queueBtn && queueBtn.classList.contains('active')) {
      renderVPIInfo(true);
    }
  }, 5 * 60 * 1000);


  /** Катала **/
  function createCatalaContent() {
    const div = document.createElement('div');
    div.className = 'tab-content';
    div.id = 'catala-content';

    div.innerHTML = `
    <div class="center-wrapper">

      <div style="font-size:14px; color:#94a3b8; margin-bottom:8px; text-align:center;">
        Введите число необходимых игр
      </div>

      <div style="display:flex; gap:12px; align-items:center; margin-bottom:20px; width:100%; max-width:340px;">
        <input id="catala-games-count" type="number" min="1" max="1000" value="1" 
               style="flex:1; padding:12px; border-radius:12px; border:1px solid #475569; background:#1e293b; color:white; font-size:15px; text-align:center;"
               placeholder="Например: 10">
      </div>

      <div style="font-size:14px; color:#fbbf24; margin-bottom:16px; text-align:center;">
        Стоимость: <strong id="catala-total-cost">1 Рубль</strong>
      </div>

      <button id="catala-play-btn" class="load-btn" style="width:100%; max-width:340px; background:linear-gradient(135deg,#f59e0b,#d97706); font-size:16px; padding:16px;">
        ИГРАТЬ В КАТАЛУ
      </button>

      <div id="catala-game-area" style="margin-top:24px; display:none; text-align:center;">
        <div style="font-size:15px; color:#94a3b8; margin-bottom:16px;">Текущая игра:</div>
        <div style="font-size:18px; color:#60a5fa; font-weight:700; margin-bottom:16px;">
          <span id="catala-current-game">1</span> / <span id="catala-total-games">1</span>
        </div>
        <div id="catala-cards" style="display:flex; justify-content:center; gap:50px; margin:30px 0;"></div>
        <div id="catala-status" style="color:#60a5fa; font-weight:600; font-size:16px; min-height:28px; margin-top:10px;"></div>
      </div>

      <div id="catala-stats" style="margin-top:20px; padding:16px; background:rgba(109,40,217,0.15); border-radius:16px; border:1px solid rgba(139,92,246,0.4); font-size:13px; color:#e2e8f0;">
        Уровень: <strong id="catala-my-level">-</strong> | 
        Рероллов: <strong id="catala-rerolls">-</strong> | 
        Игр сыграно: <strong id="catala-my-games">-</strong>
      </div>
    </div>
  `;

    const playBtn = div.querySelector('#catala-play-btn');
    const gamesInput = div.querySelector('#catala-games-count');
    const totalCostEl = div.querySelector('#catala-total-cost');
    const gameArea = div.querySelector('#catala-game-area');
    const cardsContainer = div.querySelector('#catala-cards');
    const statusEl = div.querySelector('#catala-status');
    const currentGameEl = div.querySelector('#catala-current-game');
    const totalGamesEl = div.querySelector('#catala-total-games');

    let gameResults = [];
    let currentGameIndex = 0;
    let totalGamesToPlay = 1;
    let stopRequested = false;

    const RANK_VALUE = { '2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9,'10':10,'J':11,'Q':12,'K':13,'A':14 };
    const getRank = card => card?.split('_')[0] || '';
    const getValue = card => RANK_VALUE[getRank(card)] || 0;

    function createCardElement(cardKey, highlight = false) {
      const rank = getRank(cardKey);
      const suit = cardKey?.split('_')[1] || 'hearts';
      const displayRank = rank || '?';
      const displaySuit = { hearts:'♥', diamonds:'♦', clubs:'♣', spades:'♠' }[suit] || '?';
      const color = ['hearts','diamonds'].includes(suit) ? '#dc2626' : '#1e293b';

      const card = document.createElement('div');
      card.style.cssText = `
      width:110px;height:160px;border-radius:16px;background:white;
      box-shadow:${highlight ? '0 0 40px #f59e0b,inset 0 0 20px #f59e0b40' : '0 10px 30px rgba(0,0,0,0.6)'};
      border:${highlight ? '7px solid #f59e0b' : '4px solid #475569'};
      display:flex;flex-direction:column;justify-content:space-between;
      padding:14px;font-family:system-ui;font-weight:900;color:${color};
      transition:all 0.5s ease;transform:scale(0.9);opacity:0;
    `;

      const top = Object.assign(document.createElement('div'), {textContent: displayRank, style:'font-size:36px;'});
      const center = Object.assign(document.createElement('div'), {textContent: displaySuit, style:'font-size:68px;margin:auto;'});
      //const bottom = Object.assign(document.createElement('div'), {textContent: displayRank, style:'font-size:36px;transform:rotate(180deg);'});

      card.append(top, center);
      setTimeout(() => { card.style.transform = 'scale(1)'; card.style.opacity = '1'; }, 50);
      return card;
    }

    const delay = ms => new Promise(r => setTimeout(r, ms));

    // === КНОПКА ОСТАНОВКИ ===
    const stopBtn = document.createElement('button');
    stopBtn.textContent = 'ОСТАНОВИТЬ ИГРЫ';
    stopBtn.style.cssText = `
    margin-top: 16px; width: 100%; max-width: 340px; padding: 16px;
    background: linear-gradient(135deg, #ef4444, #dc2626); color: white; border: none;
    border-radius: 16px; font-weight: 700; font-size: 15px; cursor: pointer;
    opacity: 0; pointer-events: none; transform: translateY(10px);
    transition: all 0.4s ease; box-shadow: 0 4px 20px rgba(239,68,68,0.4);
  `;
    stopBtn.onmouseover = () => { if (!stopBtn.disabled) stopBtn.style.transform = 'translateY(-2px)'; };
    stopBtn.onmouseout = () => { if (!stopBtn.disabled) stopBtn.style.transform = 'translateY(0)'; };
    stopBtn.onclick = () => {
      stopRequested = true;
      stopBtn.textContent = 'ОСТАНАВЛИВАЕМ...';
      stopBtn.disabled = true;
      stopBtn.style.background = 'linear-gradient(135deg, #991b1b, #7f1d1d)';
      statusEl.textContent = 'Доиграем текущую игру и остановим...';
    };

    playBtn.parentNode.insertBefore(stopBtn, playBtn.nextSibling);
    playBtn.parentNode.insertBefore(document.createElement('div'), stopBtn); // отступ

    // Обновление стоимости
    gamesInput.addEventListener('input', () => {
      const count = parseInt(gamesInput.value) || 1;
      totalCostEl.textContent = `${count.toLocaleString()} Рубл${count % 10 === 1 && count % 100 !== 11 ? 'ь' : 'ей'}`;
    });

    async function playOneGame() {
      let card1 = null, card2 = null;
      let resultData = null;

      try {
        const token = getAuthToken();
        const res = await fetch('https://oldprison-prod.luckygem.online/api/card/start', {
          method: 'POST',
          headers: { 'authorization': token, 'content-type': 'application/json' }
        });

        if (!res.ok) {
          if (res.status === 402) throw new Error('Недостаточно рублей');
          throw new Error(`Ошибка: ${res.status}`);
        }

        const data = await res.json();
        card1 = data.card1;
        card2 = data.card2;
        const level = data.level;
        const maxRerolls = level >= 50 ? 2 : (level >= 20 ? 1 : 0);
        let usedRerolls = 0;

        cardsContainer.innerHTML = '';
        cardsContainer.appendChild(createCardElement(card1));
        cardsContainer.appendChild(createCardElement(card2));
        statusEl.textContent = 'Анализируем...';
        await delay(800);

        while (usedRerolls < maxRerolls) {
          const v1 = getValue(card1);
          const v2 = getValue(card2);
          const r1 = getRank(card1);
          const r2 = getRank(card2);

          if (r1 === r2 && v1 >= 7) {
            statusEl.textContent = `Победа! Пара ${r1}-${r1}! Фиксируем!`;
            await delay(600);
            break;
          }

          const rerollIndex = v1 < v2 ? 0 : 1;
          const keepRank = rerollIndex === 0 ? r2 : r1;

          statusEl.textContent = `Реролл: держим ${keepRank}... (${maxRerolls - usedRerolls} осталось)`;
          await delay(600);

          try {
            const rerollRes = await fetch('https://oldprison-prod.luckygem.online/api/card/reroll', {
              method: 'POST',
              headers: { 'authorization': token, 'content-type': 'application/json' },
              body: JSON.stringify({ cardIndex: rerollIndex })
            });

            if (!rerollRes.ok) break;

            const rerollData = await rerollRes.json();
            if (rerollData.card1) card1 = rerollData.card1;
            if (rerollData.card2) card2 = rerollData.card2;

            cardsContainer.innerHTML = '';
            cardsContainer.appendChild(createCardElement(card1, rerollIndex === 0));
            cardsContainer.appendChild(createCardElement(card2, rerollIndex === 1));

            usedRerolls++;
            await delay(600);
          } catch { break; }
        }

        statusEl.textContent = 'Финализируем...';
        await delay(600);

        const finishRes = await fetch('https://oldprison-prod.luckygem.online/api/card/finish', {
          method: 'POST',
          headers: { 'authorization': token, 'content-type': 'application/json' }
        });

        if (finishRes.ok) {
          resultData = (await finishRes.json()).result;
        }

      } catch (err) {
        showError('Ошибка', err.message);
        throw err;
      }

      const pair = resultData?.pair || (getRank(card1) === getRank(card2) ? getRank(card1).repeat(2) : '--');
      const isJackpot = !!resultData?.isJackpot;

      let rewardText = '—';
      const items = [];
      if (resultData?.reward) {
        if (resultData.reward.cigarettes) items.push(`${resultData.reward.cigarettes} сиг.`);
        if (resultData.reward.authority) items.push(`${resultData.reward.authority} авт.`);
        if (resultData.reward.money) items.push(`${resultData.reward.money.toLocaleString()}₽`);
        if (resultData.reward.exp) items.push(`${resultData.reward.exp} XP`);
        if (resultData.reward.clothingId) items.push(`Татуировка #${resultData.reward.clothingId}`);
      }
      if (items.length) rewardText = items.join(' + ');

      // === Правильное сохранение татуировки с частью ===
      const drop = resultData?.rewardDrop;
      const tattoo = drop ? {
        setName: drop.setName || 'Неизвестный комплект',
        partName: drop.partName || 'Количество',
        partNumber: drop.partNumber || 1
      } : null;

      gameResults.push({
        game: currentGameIndex,
        pair,
        reward: rewardText,
        isJackpot,
        tattoo: tattoo
      });

      return true;
    }

    async function startMassPlay() {
      if (playBtn.disabled) return;

      totalGamesToPlay = Math.max(1, Math.min(1000, parseInt(gamesInput.value) || 1));
      if (totalGamesToPlay < 1) return showError('Ошибка', 'Введите число от 1');

      stopRequested = false;
      gameResults = [];
      currentGameIndex = 0;

      playBtn.disabled = true;
      playBtn.textContent = 'Играем...';

      // Показываем кнопку остановки
      stopBtn.style.opacity = '1';
      stopBtn.style.pointerEvents = 'auto';
      stopBtn.style.transform = 'translateY(0)';
      stopBtn.textContent = 'ОСТАНОВИТЬ ИГРЫ';
      stopBtn.disabled = false;
      stopBtn.style.background = 'linear-gradient(135deg, #ef4444, #dc2626)';

      gameArea.style.display = 'block';
      totalGamesEl.textContent = totalGamesToPlay;

      try {
        for (let i = 1; i <= totalGamesToPlay; i++) {
          if (stopRequested) {
            statusEl.textContent = 'Остановлено пользователем';
            await delay(600);
            break;
          }

          currentGameIndex = i;
          currentGameEl.textContent = i;
          statusEl.textContent = `Игра ${i} из ${totalGamesToPlay}...`;

          await playOneGame();

          if (i < totalGamesToPlay && !stopRequested) {
            await delay(600);
          }
        }

        showResultsModal();

      } catch (err) {
        // Ошибки уже показаны
      } finally {
        playBtn.disabled = false;
        playBtn.textContent = 'ИГРАТЬ В КАТАЛУ';

        stopBtn.style.opacity = '0';
        stopBtn.style.pointerEvents = 'none';
        stopBtn.style.transform = 'translateY(10px)';

        gameArea.style.display = 'none';
        updateStats();
      }
    }

    function showResultsModal() {
      const resultsHTML = gameResults.map(g => {
        const jackpotBadge = g.isJackpot
          ? `<span style="background:#f97316;color:white;padding:4px 12px;border-radius:999px;font-weight:900;font-size:12px;margin-left:8px;box-shadow:0 2px 8px rgba(249,115,22,0.4);">JACKPOT!</span>`
          : '';

        const tattooLine = g.tattoo
          ? `<div style="margin-top:10px;padding-top:10px;border-top:1px solid #475569;color:#fbbf24;font-size:14px;">
           <strong>Сет: ${g.tattoo.setName}</strong><br>
           <span style="color:#fcd34d;font-size:13px;">▸ ${g.tattoo.partName} — ${g.tattoo.partNumber} шт.</span>
         </div>`
          : '';

        return `
      <div style="background:#0f172a;border:1px solid #334155;border-radius:16px;padding:14px;margin-bottom:12px;box-shadow:0 4px 20px rgba(0,0,0,0.3);">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <div style="color:#60a5fa;font-weight:900;font-size:16px;">
            Игра #${g.game}${jackpotBadge}
          </div>
          <div style="color:#86efac;font-weight:700;font-size:16px;">
            Пара: ${g.pair}
          </div>
        </div>

        <div style="margin-top:10px;color:#bbf7d0;font-size:15px;text-align:center;">
          ${g.reward === '—' ? '<span style="color:#64748b;">—</span>' : g.reward}
        </div>

        ${tattooLine}
      </div>
    `;
      }).join('');

      showModal({
        title: `Результаты каталы ×${gameResults.length}`,
        content: `
      <div style="max-height:70vh;overflow-y:auto;padding-right:8px;">
        ${resultsHTML || '<div style="text-align:center;color:#64748b;padding:50px;font-size:15px;">Нет результатов</div>'}
      </div>

      <div style="margin-top:16px;padding:14px;background:rgba(34,197,94,0.15);border-radius:12px;text-align:center;font-size:14px;">
        <strong style="color:#86efac;">Сыграно: ${gameResults.length}</strong>
        ${gameResults.filter(g => g.isJackpot).length ? ` • <strong style="color:#f97316;">Джекпотов: ${gameResults.filter(g => g.isJackpot).length}</strong>` : ''}
        ${gameResults.filter(g => g.tattoo).length ? ` • <strong style="color:#fbbf24;">Тату: ${gameResults.filter(g => g.tattoo).length}</strong>` : ''}
      </div>
    `,
        buttons: [{ label: 'Готово', action: () => {} }]
      });
    }

    async function updateStats() {
      try {
        const token = getAuthToken();
        const res = await fetch(`https://oldprison-prod.luckygem.online/api/card/state?userId=${currentUserId}`, { headers: { authorization: token } });
        if (res.ok) {
          const d = await res.json();
          div.querySelector('#catala-my-level').textContent = d.level || 0;
          const rerolls = d.level >= 50 ? 2 : (d.level >= 20 ? 1 : 0);
          div.querySelector('#catala-rerolls').textContent = rerolls;
          div.querySelector('#catala-my-games').textContent = (d.totalPlays || 0) + gameResults.length;
        }
      } catch {}
    }

    playBtn.onclick = startMassPlay;

    setTimeout(updateStats, 400);

    return div;
  }

    /** Покер **/
    function createPokerContent() {
      const SOAP_DAILY_LIMIT = 25; // Дневной лимит игр за мыло

      const div = document.createElement('div');
      div.className = 'tab-content';
      div.id = 'poker-content';

      div.innerHTML = `
<div class="center-wrapper" style="padding: 16px;">

  <div style="font-size:14px; color:#94a3b8; margin-bottom:8px; text-align:center;">
    Количество игр
  </div>

  <div style="display:flex; gap:12px; align-items:center; justify-content:center; margin-bottom:24px;">
    <input id="poker-count" type="number" min="1" max="100" value="1"
           style="width:140px; padding:14px; border-radius:12px; border:1px solid #475569;
                  background:#1e293b; color:white; font-size:20px; text-align:center;"/>
  </div>

  <div style="margin:16px 0; text-align:center; color:#94a3b8; font-size:13px;">
    Режим:
    <select id="poker-mode" style="background:#1e293b; color:white; border:1px solid #475569; 
             padding:8px 12px; border-radius:8px; margin-left:10px; font-size:14px;">
      <option value="chips">За фишки (chips)</option>
      <option value="soap">За мыло (soap)</option>
    </select>
  </div>

  <button id="poker-start-btn" class="load-btn" style="width:100%; max-width:340px; 
         background:linear-gradient(135deg,#8b5cf6,#6d28d9); padding:16px; font-size:16px; 
         margin-top:20px; border:none; border-radius:12px; color:white; font-weight:700; cursor:pointer;">
    ИГРАТЬ В ПОКЕР
  </button>

  <div id="poker-game-block" style="display:none; margin-top:32px; text-align:center;">
    <div style="font-size:15px; color:#94a3b8; margin-bottom:12px;">Текущая игра</div>
    <div style="font-size:18px; color:#c084fc; font-weight:700; margin-bottom:20px;">
      <span id="poker-current-game">1</span> / <span id="poker-total-games">1</span>
    </div>

    <div id="poker-hand" style="display:flex; flex-wrap:wrap; justify-content:center; gap:16px; margin:24px 0;"></div>

    <div style="margin:24px 0; color:#fbbf24; font-size:15px; font-weight:500;">
      Осталось шульмовок: <span id="poker-rerolls-left">—</span>
    </div>

    <button id="poker-finish-btn" style="margin-top:24px; padding:14px 48px; 
           background:linear-gradient(135deg,#f59e0b,#d97706); color:white; border:none; 
           border-radius:12px; font-size:16px; font-weight:700; cursor:pointer; display:none;">
      ВСКРЫТЬСЯ
    </button>

    <div id="poker-progress" style="color:#c084fc; font-weight:600; font-size:15px; 
         min-height:48px; margin-top:24px; line-height:1.4;"></div>
  </div>

  <button id="poker-stop-btn" style="margin-top:28px; width:100%; max-width:340px; padding:16px;
         background:linear-gradient(135deg,#ef4444,#b91c1c); color:white; border:none; 
         border-radius:12px; font-size:16px; font-weight:700; display:none; cursor:pointer;">
    ОСТАНОВИТЬ ИГРЫ
  </button>

  <div style="margin-top:32px; padding:18px; background:rgba(139,92,246,0.15); border-radius:16px; 
     border:1px solid rgba(139,92,246,0.35); font-size:14px; color:#e2e8f0; text-align:left; line-height:1.7;">
  <div>Уровень Покера: <strong id="poker-level">-</strong></div>
  <div>Шульмовки: <strong id="poker-reroll-max">-</strong></div>
  <div>Сыграно всего: <strong id="poker-total-hands">-</strong></div>
  <div>Доступно за фишки: <strong id="poker-chips-available">-</strong></div>
  <div>Доступно за мыло: <strong id="poker-soap-available">-</strong></div>
</div>
</div>
`;

      const countInput          = div.querySelector('#poker-count');
      const modeSelect          = div.querySelector('#poker-mode');
      const startBtn            = div.querySelector('#poker-start-btn');
      const stopBtn             = div.querySelector('#poker-stop-btn');
      const gameBlock           = div.querySelector('#poker-game-block');
      const handContainer       = div.querySelector('#poker-hand');
      const progressText        = div.querySelector('#poker-progress');
      const rerollsLeftEl       = div.querySelector('#poker-rerolls-left');
      const finishBtn           = div.querySelector('#poker-finish-btn');
      const currentGameEl       = div.querySelector('#poker-current-game');
      const totalGamesEl        = div.querySelector('#poker-total-games');

      const statsLevel          = div.querySelector('#poker-level');
      const statsRerollMax      = div.querySelector('#poker-reroll-max');
      const statsTotalHands     = div.querySelector('#poker-total-hands');
      const statsChipsAvailable = div.querySelector('#poker-chips-available');
      const statsSoapAvailable  = div.querySelector('#poker-soap-available');

      let currentSession = {
        totalToPlay: 1,
        currentIndex: 0,
        stopRequested: false,
        mode: "chips"
      };

      let gameState = {
        token: null,
        mode: null,
        currentCards: [],
        rerollsUsed: 0,
        rerollsMax: 0,
        gameActive: false,
        chips: 0,
        soapUsedToday: 0
      };

      let gameResults = [];
      let currentGameIndex = 0;

      const delay = ms => new Promise(r => setTimeout(r, ms));

      function createCardElement(key, index) {
        const [rank, suit] = key.split('_');
        const rankText = rank === 'T' ? '10' : rank;
        const suitSymbols = { hearts:'♥', diamonds:'♦', clubs:'♣', spades:'♠' };
        const suitSym = suitSymbols[suit] || suit[0].toUpperCase();
        const color = ['hearts','diamonds'].includes(suit) ? '#ef4444' : '#111827';

        const card = document.createElement('div');
        card.dataset.key = key;
        card.dataset.index = index;
        card.style.cssText = `
      width:110px; height:160px; border-radius:16px; background:white;
      box-shadow: 0 10px 30px rgba(0,0,0,0.6);
      border:4px solid #475569;
      display:flex; flex-direction:column; justify-content:space-between;
      padding:14px; font-family:system-ui; font-weight:900; color:${color};
      transition:all 0.5s ease; transform:scale(0.9); opacity:0;
    `;

        const top = document.createElement('div');
        top.textContent = rankText;
        top.style.cssText = 'font-size:36px;';

        const center = document.createElement('div');
        center.textContent = suitSym;
        center.style.cssText = 'font-size:68px; margin:auto;';

        card.append(top, center);

        setTimeout(() => { card.style.transform = 'scale(1)'; card.style.opacity = '1'; }, 50);

        card.onclick = async () => {
          if (!gameState.gameActive) return;

          handContainer.querySelectorAll('div').forEach(el => {
            el.style.borderColor = '#4b5563';
            el.style.transform = 'scale(1)';
          });
          card.style.borderColor = '#ef4444';
          card.style.transform = 'scale(1.06)';

          progressText.textContent = `Заменяем карту #${index}...`;

          await delay(300);

          await performDraw(index);
        };

        return card;
      }

      async function performDraw(replaceIndex) {
        if (gameState.rerollsUsed >= gameState.rerollsMax) {
          progressText.textContent = 'Шульмовки закончились';
          finishBtn.style.display = 'inline-block';
          return;
        }

        try {
          const res = await fetch('https://oldprison-prod.luckygem.online/api/poker/draw', {
            method: 'POST',
            headers: {
              'authorization': gameState.token,
              'content-type': 'application/json'
            },
            body: JSON.stringify({ replaceIndexes: [replaceIndex] })
          });

          if (!res.ok) {
            const errorText = await res.text();
            throw new Error(`draw ${res.status} — ${errorText}`);
          }

          const data = await res.json();

          gameState.currentCards = data.cards || gameState.currentCards;
          gameState.rerollsUsed  = data.rerollsUsed  || gameState.rerollsUsed;

          const left = Math.max(0, gameState.rerollsMax - gameState.rerollsUsed);
          rerollsLeftEl.textContent = left;

          handContainer.innerHTML = '';
          gameState.currentCards.forEach((key, idx) => {
            handContainer.appendChild(createCardElement(key, idx));
          });

          progressText.textContent = left > 0
            ? `Осталось шульмовок: ${left} (клик по карте для замены)`
            : 'Шульмовки закончились — можно вскрываться';

          if (left === 0) finishBtn.style.display = 'inline-block';

        } catch (err) {
          progressText.textContent = 'Ошибка замены карты: ' + err.message;
          console.error("Ошибка draw:", err);
        }
      }

      async function finishGame() {
        progressText.textContent = 'Вскрываем руку...';
        finishBtn.disabled = true;
        finishBtn.style.opacity = '0.6';

        try {
          const res = await fetch('https://oldprison-prod.luckygem.online/api/poker/finish', {
            method: 'POST',
            headers: {
              'authorization': gameState.token,
              'content-type': 'application/json'
            },
            body: '{}'
          });

          if (!res.ok) throw new Error(`finish ${res.status}`);

          const result = await res.json();

          const finalCards = result.cards || [];
          const cardDisplay = finalCards.map(card => {
            const [rank] = card.split('_');
            return rank === 'T' ? '10' : rank;
          }).join('-') || '—';

          const r = result.reward || {};
          const rewards = [];
          if (r.rubles)     rewards.push(`${r.rubles.toLocaleString('ru-RU')} ₽`);
          if (r.authority)  rewards.push(`${r.authority.toLocaleString('ru-RU')} авторитета`);
          if (r.cigarettes) rewards.push(`${r.cigarettes.toLocaleString('ru-RU')} сигарет`);
          if (r.hides)      rewards.push(`${r.hides} нычек`);

          const rewardText = rewards.length ? rewards.join('<br>') : 'Награды отсутствуют';

          showModal({
            title: 'Результат покера',
            content: `
        <div style="text-align:center; padding:20px;">
            <div style="font-size:36px; color:#fbbf24; margin:24px 0; font-weight:900; letter-spacing:3px;">
                ${cardDisplay}
            </div>
            <div style="font-size:19px; color:#86efac; margin:32px 0 16px;">
                Получено:
            </div>
            <div style="font-size:17px; line-height:1.7; color:#e2e8f0;">
                ${rewardText}
            </div>
        </div>
      `,
            buttons: [{ label: 'Закрыть', action: () => {} }],
            closable: true,
            allowOutsideClick: true
          });

          progressText.textContent = 'Игра завершена';

        } catch (err) {
          progressText.textContent = 'Ошибка вскрытия';
          showError('Ошибка', err.message || 'Не удалось завершить игру');
        } finally {
          gameState.gameActive = false;
          finishBtn.style.display = 'none';
          finishBtn.disabled = false;
          finishBtn.style.opacity = '1';
        }
      }

      async function autoReplaceCards() {
        const ranks = { '2':2, '3':3, '4':4, '5':5, '6':6, '7':7, '8':8, '9':9, 'T':10, 'J':11, 'Q':12, 'K':13, 'A':14 };

        function getHandRank(cards) {
          const rankCounts = {};
          const suitCounts = {};
          cards.forEach(card => {
            const [r, s] = card.split('_');
            rankCounts[r] = (rankCounts[r] || 0) + 1;
            suitCounts[s] = (suitCounts[s] || 0) + 1;
          });

          const counts = Object.values(rankCounts).sort((a,b)=>b-a);
          const maxSuit = Math.max(...Object.values(suitCounts));

          const sortedRanks = Object.keys(rankCounts)
            .map(r => ranks[r])
            .sort((a,b)=>a-b);

          const isFlush = maxSuit === 5;
          const isStraight = sortedRanks.length === 5 && sortedRanks[4] - sortedRanks[0] === 4;

          if (isFlush && isStraight && sortedRanks[0] === 10) return 1; // Royal Flush
          if (isFlush && isStraight) return 2;                          // Straight Flush
          if (counts[0] === 4) return 3;                                // Каре
          if (counts[0] === 3 && counts[1] === 2) return 4;             // Full House
          if (isFlush) return 5;                                        // Флеш
          if (isStraight) return 6;                                     // Стрит
          if (counts[0] === 3) return 7;                                // Тройка
          if (counts[0] === 2 && counts[1] === 2) return 8;             // Две пары
          if (counts[0] === 2) return 9;                                // Пара
          return 10;                                                    // Старшая
        }

        // Проверка на дро к Royal Flush (4 карты из 10-J-Q-K-A одной масти)
        function hasRoyalFlushDraw(cards) {
          const suitCounts = {};
          const royalRanks = ['T', 'J', 'Q', 'K', 'A'];
          cards.forEach(card => {
            const [r, s] = card.split('_');
            if (royalRanks.includes(r)) {
              suitCounts[s] = (suitCounts[s] || 0) + 1;
            }
          });
          return Math.max(...Object.values(suitCounts)) >= 4;
        }

        // Находим масть для Royal-дро (если есть 4)
        function getRoyalFlushSuit(cards) {
          const suitCounts = {};
          const royalRanks = ['T', 'J', 'Q', 'K', 'A'];
          cards.forEach(card => {
            const [r, s] = card.split('_');
            if (royalRanks.includes(r)) {
              suitCounts[s] = (suitCounts[s] || 0) + 1;
            }
          });
          let bestSuit = null;
          let maxCount = 0;
          for (const [suit, count] of Object.entries(suitCounts)) {
            if (count > maxCount) {
              maxCount = count;
              bestSuit = suit;
            }
          }
          return maxCount >= 4 ? bestSuit : null;
        }

        while (gameState.rerollsUsed < gameState.rerollsMax) {
          const currentRank = getHandRank(gameState.currentCards);

          // Фиксация на Straight Flush / Каре / Flush
          if (currentRank === 2 || currentRank === 3 || currentRank === 5) {
            progressText.textContent = 'Straight Flush / Каре / Флеш — фиксируем и вскрываем!';
            return;
          }

          progressText.textContent = 'Пытаемся собрать Royal Flush или топ-комбо...';
          await delay(800);

          let targetIndex = -1;

          // Приоритет 1: Royal Flush дро
          const royalSuit = getRoyalFlushSuit(gameState.currentCards);
          if (royalSuit) {
            // Меняем карту, которая НЕ подходит к Royal (самую слабую среди не-рояльных)
            let minValue = Infinity;
            gameState.currentCards.forEach((card, idx) => {
              const [r, s] = card.split('_');
              if (s !== royalSuit || !['T','J','Q','K','A'].includes(r)) {
                const value = ranks[r];
                if (value < minValue) {
                  minValue = value;
                  targetIndex = idx;
                }
              }
            });
            if (targetIndex !== -1) {
              progressText.textContent = `Royal Flush дро по ${royalSuit} — добираем пятую карту...`;
            }
          }

          // Приоритет 2: Flush дро (4 карты одной масти)
          if (targetIndex === -1) {
            const suitCounts = {};
            gameState.currentCards.forEach(card => {
              const [, s] = card.split('_');
              suitCounts[s] = (suitCounts[s] || 0) + 1;
            });
            const maxSuit = Object.entries(suitCounts).reduce((a, b) => a[1] > b[1] ? a : b)[0];
            if (suitCounts[maxSuit] >= 4) {
              // Меняем карту не этой масти (самую слабую)
              let minValue = Infinity;
              gameState.currentCards.forEach((card, idx) => {
                const [, s] = card.split('_');
                if (s !== maxSuit) {
                  const value = ranks[card.split('_')[0]];
                  if (value < minValue) {
                    minValue = value;
                    targetIndex = idx;
                  }
                }
              });
              if (targetIndex !== -1) {
                progressText.textContent = `Флеш-дро по ${maxSuit} — добираем пятую...`;
              }
            }
          }

          // Приоритет 3: Если нет дро — меняем самую слабую карту (риск)
          if (targetIndex === -1) {
            let weakestValue = Infinity;
            targetIndex = 0;
            gameState.currentCards.forEach((card, idx) => {
              const value = ranks[card.split('_')[0]] || 2;
              if (value < weakestValue) {
                weakestValue = value;
                targetIndex = idx;
              }
            });
            progressText.textContent = `Нет дро — меняем слабую карту (#${targetIndex + 1})...`;
          }

          await delay(800);
          await performDraw(targetIndex);

          // Проверка после каждой замены
          const newRank = getHandRank(gameState.currentCards);
          if (newRank === 2 || newRank === 3 || newRank === 5) {
            progressText.textContent = 'Собрали топ-комбо — фиксируем и вскрываем!';
            return;
          } else if (newRank < currentRank) {
            progressText.textContent = 'Улучшили руку! Продолжаем...';
          } else {
            progressText.textContent = 'Не улучшилось... рискуем дальше';
          }
        }

        progressText.textContent = 'Шульмовки закончились — вскрываем что есть';
      }

      async function playOneGameAuto() {
        let resultData = null;

        try {
          gameState.token = getAuthToken();
          gameState.mode = currentSession.mode;
          gameState.rerollsUsed = 0;
          gameState.gameActive = true;

          const startRes = await fetch(`https://oldprison-prod.luckygem.online/api/poker/start?mode=${gameState.mode}`, {
            method: 'POST',
            headers: { 'authorization': gameState.token, 'content-type': 'application/json' },
            body: '{}'
          });

          if (!startRes.ok) throw new Error(`start ${startRes.status}`);

          const data = await startRes.json();
          gameState.currentCards = data.cards || [];

          const level = data.level || 0;
          gameState.rerollsMax = level >= 80 ? 3 : level >= 50 ? 2 : level >= 20 ? 1 : 0;

          handContainer.innerHTML = '';
          gameState.currentCards.forEach(key => {
            handContainer.appendChild(createCardElement(key));
          });

          progressText.textContent = 'Автоматическая игра...';

          await autoReplaceCards();

          progressText.textContent = 'Вскрываем...';
          await delay(800);

          const finishRes = await fetch('https://oldprison-prod.luckygem.online/api/poker/finish', {
            method: 'POST',
            headers: { 'authorization': gameState.token, 'content-type': 'application/json' },
            body: '{}'
          });

          if (finishRes.ok) {
            resultData = await finishRes.json();
          } else {
            throw new Error(`finish ${finishRes.status}`);
          }

        } catch (err) {
          progressText.textContent = 'Ошибка игры: ' + err.message;
          console.error(err);
        } finally {
          gameState.gameActive = false;
          progressText.textContent = 'Игра завершена';
        }

        // Сохраняем результат для модального окна
        const finalCards = resultData?.cards || gameState.currentCards || [];
        const cardDisplay = finalCards.map(card => {
          const [rank] = card.split('_');
          return rank === 'T' ? '10' : rank;
        }).join('-') || '—';

        const r = resultData?.reward || {};
        const rewards = [];
        if (r.rubles)     rewards.push(`${r.rubles.toLocaleString('ru-RU')} ₽`);
        if (r.authority)  rewards.push(`${r.authority.toLocaleString('ru-RU')} авт.`);
        if (r.cigarettes) rewards.push(`${r.cigarettes.toLocaleString('ru-RU')} сиги`);
        if (r.hides)      rewards.push(`${r.hides} нычек`);

        const rewardText = rewards.length ? rewards.join(' + ') : '—';

        gameResults.push({
          game: currentGameIndex,
          cards: cardDisplay,
          reward: rewardText
        });
      }

      async function runSession() {
        if (startBtn.disabled) return;

        await loadPokerStats();

        const neededGames = Math.max(1, parseInt(countInput.value) || 1);

        if (currentSession.mode === "chips" && gameState.chips < neededGames) {
          showModal({
            title: 'Недостаточно фишек',
            content: `Для ${neededGames} игр(ы) необходимо ${neededGames} фишка(ек), у вас их ${gameState.chips}.`,
            buttons: [{ label: 'Закрыть', action: () => {} }],
            closable: true
          });
          return;
        }

        if (currentSession.mode === "soap") {
          const soapAvailable = SOAP_DAILY_LIMIT - gameState.soapUsedToday;
          if (soapAvailable < neededGames) {
            showModal({
              title: 'Лимит за мыло исчерпан',
              content: `Сегодня осталось ${soapAvailable} игр за мыло (лимит ${SOAP_DAILY_LIMIT}), а вы хотите ${neededGames}.`,
              buttons: [{ label: 'Закрыть', action: () => {} }],
              closable: true
            });
            return;
          }
        }

        currentSession = {
          totalToPlay: neededGames,
          currentIndex: 0,
          stopRequested: false,
          mode: modeSelect.value
        };

        startBtn.disabled = true;
        startBtn.textContent = 'ИДЁТ ИГРА...';
        stopBtn.style.display = 'block';
        gameBlock.style.display = 'block';
        totalGamesEl.textContent = currentSession.totalToPlay;

        gameResults = [];
        currentGameIndex = 0;

        for (let i = 1; i <= currentSession.totalToPlay; i++) {
          if (currentSession.stopRequested) {
            progressText.textContent = 'Остановка по запросу...';
            break;
          }

          currentGameIndex = i;
          currentGameEl.textContent = i;
          progressText.textContent = `Игра ${i} / ${currentSession.totalToPlay}`;

          await playOneGameAuto();

          await delay(1200 + Math.random() * 800);
        }

        progressText.textContent = 'Сессия завершена';

        if (gameResults.length > 0) {
          const resultsHTML = gameResults.map(g => `
      <div style="background:#0f172a; border:1px solid #334155; border-radius:16px; padding:16px; margin-bottom:14px;">
        <div style="color:#c084fc; font-weight:900; font-size:17px; text-align:center;">
          Игра #${g.game}
        </div>
        <div style="margin:16px 0; color:#fbbf24; font-size:28px; text-align:center; font-weight:900;">
          ${g.cards}
        </div>
        <div style="color:#86efac; font-size:16px; text-align:center;">
          ${g.reward === '—' ? '<span style="color:#64748b;">Награды нет</span>' : g.reward}
        </div>
      </div>
    `).join('');

          showModal({
            title: `Результаты ×${gameResults.length}`,
            content: `
        <div style="max-height:70vh; overflow-y:auto; padding-right:8px;">
          ${resultsHTML}
        </div>
      `,
            buttons: [{ label: 'Готово', action: () => {} }],
            closable: true
          });
        }

        startBtn.disabled = false;
        startBtn.textContent = 'ИГРАТЬ В ПОКЕР';
        stopBtn.style.display = 'none';
        gameBlock.style.display = 'none';

        await loadPokerStats();
      }

      async function loadPokerStats() {
        try {
          const res = await fetch('https://oldprison-prod.luckygem.online/api/poker/state', {
            headers: { 'authorization': getAuthToken() }
          });
          if (!res.ok) return;

          const data = await res.json();

          statsLevel.textContent      = data.level ?? '?';
          statsTotalHands.textContent = data.totalHands?.toLocaleString('ru-RU') ?? '0';

          const lvl = data.level || 0;
          statsRerollMax.textContent = (lvl >= 80 ? 3 : lvl >= 50 ? 2 : lvl >= 20 ? 1 : 0) + ' макс.';

          gameState.chips = data.chips ?? 0;
          gameState.soapUsedToday = data.soapPlaysUsedToday ?? 0;

          statsChipsAvailable.textContent = data.chips ?? '0';

          const soapAvailable = SOAP_DAILY_LIMIT - (data.soapPlaysUsedToday ?? 0);
          statsSoapAvailable.textContent = `${soapAvailable} из ${SOAP_DAILY_LIMIT}`;

        } catch (err) {
          console.warn('Не удалось загрузить статистику покера:', err);
        }
      }

      // Обработчики
      countInput.addEventListener('input', () => {
        let val = parseInt(countInput.value) || 1;
        if (val < 1) val = 1;
        if (val > 100) val = 100;
        countInput.value = val;
      });

      modeSelect.addEventListener('change', () => {
        currentSession.mode = modeSelect.value;
      });

      startBtn.onclick = runSession;

      stopBtn.onclick = () => {
        currentSession.stopRequested = true;
        stopBtn.textContent = 'ОСТАНАВЛИВАЕМ...';
        stopBtn.disabled = true;
      };

      finishBtn.onclick = finishGame;

      // Инициализация
      setTimeout(loadPokerStats, 600);

      return div;
    }

  // === loadTalents — сохраняем конфиг ===
  async function loadTalents() {
    const token = getAuthToken();
    if (!token) return showError('Ошибка', 'Токен не найден');

    const container = document.getElementById('talents-container');
    container.innerHTML = '<div style="text-align:center; color:#94a3b8; padding:20px;">Загрузка...</div>';

    try {
      const res = await fetch('https://oldprison-prod.luckygem.online/api/talent/status', {
        headers: { 'accept': 'application/json', 'authorization': token }
      });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const data = await res.json();

      currentTalentsConfig = data.config;
      displayTalents(data);
    } catch (e) {
      container.innerHTML = `<div class="text-error" style="text-align:center; padding:20px;">Ошибка: ${e.message}</div>`;
    }
  }

  // === displayTalents — добавляем data-talent-id на блок ===
  function displayTalents(data) {
    const container = document.getElementById('talents-container');
    const { state, config, biceps } = data;
    const levels = state.talentLevels || {};

    container.innerHTML = '';

    // Summary
    const summary = document.createElement('div');
    summary.className = 'talents-summary';
    summary.innerHTML = `
    <div><strong>Потрачено:</strong> ${state.spentPoints || 0}</div>
    <div><strong>Свободно:</strong> ${state.unspentPoints || 0}</div>
    <div><strong>Бицуха:</strong> ${biceps.toLocaleString('ru-RU')}</div>
    <div><strong>Урон:</strong> ${state.currentDamage || 0}</div>
  `;
    container.appendChild(summary);

    config.forEach(talent => {
      const level = levels[String(talent.id)] ?? levels[talent.id] ?? 0;
      const maxLevel = talent.maxLevel;
      const remaining = maxLevel - level;
      const freePoints = state.unspentPoints || 0;
      const maxCanUpgrade = Math.min(remaining, freePoints);

      const block = document.createElement('div');
      block.className = 'talent-block';
      block.dataset.talentId = talent.id;
      if (level > 0) block.classList.add('progressed');

      const value = calculateTalentValue(talent, level);
      const desc = talent.description.replace('{value}', `<strong>${value}</strong>`);

      block.innerHTML = `
      <div class="talent-icon">
        <img src="https://cdn.the-prison.ru/PrisonV3/talents/image/icon/${talent.icon}.webp" loading="lazy">
      </div>
      <div class="talent-info">
        <div class="talent-name">${talent.name}</div>
        <div class="talent-level">${level} / ${maxLevel}</div>
        <div class="talent-desc">${desc}</div>
      </div>
      <div class="talent-progress ${level > 0 ? 'progressed' : ''}">
        <div class="progress-fill" style="width: ${(level / maxLevel) * 100}%"></div>
      </div>

      ${maxCanUpgrade > 0 ? `
        <div class="upgrade-wrapper">
          <button class="upgrade-btn-multi" data-talent-id="${talent.id}">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
              <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
            </svg>
          </button>

          <div class="input-overlay" style="display:none;">
  <button class="confirm-btn">✓</button>
  <input type="number" min="1" max="${maxCanUpgrade}" value="1" class="multi-input">
</div>
        </div>
      ` : '<div style="width:44px;flex-shrink:0;"></div>'}
    `;

      container.appendChild(block);
    });

    // Навешиваем события ПОСЛЕ создания всех элементов ===
    // 1. Кнопка "+" — открывает поле ввода
    container.querySelectorAll('.upgrade-btn-multi').forEach(btn => {
      btn.onclick = openMultiInput;
    });

    // 2. Кнопка "✓" — подтверждает прокачку
    container.querySelectorAll('.confirm-btn').forEach(btn => {
      btn.onclick = confirmMultiUpgrade;
    });

    // 3. Enter / Escape в поле ввода
    container.querySelectorAll('.multi-input').forEach(input => {
      input.addEventListener('keydown', e => {
        if (e.key === 'Enter') {
          e.preventDefault();
          input.closest('.input-overlay').querySelector('.confirm-btn').click();
        }
        if (e.key === 'Escape') {
          closeAllInputs();
        }
      });
    });
  }

  function calculateTalentValue(talent, level) {
    const p = talent.params;
    if (!level) return '0';

    switch (talent.type) {
      case 'weapon_bonus':
        return p.flatBonusPerLevel ? (p.flatBonusPerLevel * level) : 0;
      case 'crit_bonus':
        return `${(p.critBonusPerLevel * level * 100).toFixed(1)}%`;
      case 'stat_bonus':
        return p.flatBonusPerLevel ? (p.flatBonusPerLevel * level) : 0;
      case 'cooldown_bonus':
        const minutes = Math.floor((p.cooldownSecondsPerLevel * level) / 60);
        return `${minutes} мин`;
      case 'boss_time_bonus':
        const secs = p.secondsPerLevel * level;
        return secs >= 60 ? `${secs / 60} мин` : `${secs} сек`;
      case 'boss_attack_limit_bonus':
        return p.limitPerLevel * level;
      case 'unlock_weapon':
        return 'Разблокировано';
      default:
        return level;
    }
  }

  async function resetAllTalents() {
    const token = getAuthToken();
    if (!token) return showError('Ошибка', 'Токен не найден');

    confirmAction(
      'Сбросить все таланты?',
      'Все прокачанные таланты будут сброшены.<br>Все очки вернутся.<br><strong>Стоимость: 3 рубля</strong>',
      async () => {
        let progressModal = null;

        progressModal = showModal({
          title: 'Сброс талантов...',
          content: `
          <div style="text-align:center; padding:20px 0;">
            <div style="font-size:14px; margin-bottom:16px; color:#94a3b8;">0/1</div>
            <div class="progress-bar">
              <div id="progress-fill" style="width:0%; background:linear-gradient(90deg,#3b82f6,#1d4ed8);"></div>
            </div>
          </div>
        `,
          buttons: [
            {
              label: 'Отмена',
              danger: true,
              action: () => {
                progressModal?.remove();
              }
            }
          ],
          onClose: () => {}
        });

        const fill = progressModal.querySelector('#progress-fill');
        setTimeout(() => fill.style.width = '80%', 100);

        try {
          const res = await fetch('https://oldprison-prod.luckygem.online/api/talent/reset', {
            method: 'POST',
            headers: {
              'authorization': token,
              'content-type': 'application/json'
            }
          });

          if (!res.ok) {
            const error = await res.text();
            throw new Error(`HTTP ${res.status}: ${error}`);
          }

          const result = await res.json();

          progressModal.remove();

          await loadTalents();

          showSuccess('Сброс успешен!', `
          Таланты полностью сброшены!<br><br>
          Потрачено очков: <strong>0</strong><br>
          Свободно очков: <strong>${result?.state?.unspentPoints || 'все'}</strong>
        `);

        } catch (e) {
          progressModal.remove();
          showError('Ошибка сброса', e.message || 'Неизвестная ошибка');
          console.error(e);
        }
      }
    );
  }

  async function upgradeTalent(talentId, count) {
    const token = getAuthToken();
    if (!token) {
      showError('Ошибка', 'Токен не найден');
      return false;
    }

    try {
      const res = await fetch('https://oldprison-prod.luckygem.online/api/talent/upgrade', {
        method: 'POST',
        headers: {
          'authorization': token,
          'content-type': 'application/json'
        },
        body: JSON.stringify({ talentId, count })
      });

      const data = await res.json();

      if (!data.success) {
        if (data.message === 'Невозможно прокачать талант') {
          showError('Талант недоступен', 'Талант еще не доступен, прокачай предыдущий');
        } else {
          showError('Ошибка прокачки', data.message || 'Неизвестная ошибка');
        }
        return false;
      }
      return true;

    } catch (err) {
      showError('Ошибка сети', 'Не удалось связаться с сервером');
      console.error(err);
      return false;
    }
  }

  function openMultiInput(e) {
    e.stopPropagation();
    closeAllInputs();

    const wrapper = this.parentElement;
    const overlay = wrapper.querySelector('.input-overlay');
    const input = overlay.querySelector('.multi-input');

    overlay.style.display = 'flex';
    input.focus();
    input.select();

    activeInput = overlay;

    // Закрытие по клику вне
    setTimeout(() => document.addEventListener('click', closeOnClickOutside), 100);
  }

  // Массовая прокачка
  async function upgradeTalentMultipleTimes(talentId, totalCount) {
    let successCount = 0;
    abortUpgrade = false; // Сбрасываем флаг перед началом

    const progressModal = showModal({
      title: 'Прокачка таланта...',
      content: `
      <div style="text-align:center; padding:20px;">
        <div style="margin-bottom:12px; color:#94a3b8;">
          Прогресс: <strong id="prog">0</strong> / ${totalCount}
        </div>
        <div class="progress-bar" style="height:8px; background:#374151; border-radius:4px; overflow:hidden;">
          <div id="progfill" style="width:0%; height:100%; background:linear-gradient(90deg,#10b981,#059669); transition: width 0.3s ease;"></div>
        </div>
        <div style="margin-top:12px; font-size:13px; color:#9ca3af;">Можно прервать в любой момент</div>
      </div>
    `,
      buttons: [{
        label: 'Отмена',
        danger: true,
        action: () => {
          abortUpgrade = true; // Активируем прерывание
          progressModal.remove();
        }
      }]
    });

    const progText = progressModal.querySelector('#prog');
    const progFill = progressModal.querySelector('#progfill');

    for (let i = 0; i < totalCount; i++) {
      // ПРОВЕРЯЕМ ФЛАГ ПРЕРЫВАНИЯ ПЕРЕД КАЖДЫМ ЗАПРОСОМ
      if (abortUpgrade) {
        progressModal.remove();
        await loadTalents(); // Обновляем, чтобы показать актуальное состояние
        showError('Прокачка прервана', `Вы остановили прокачку на <strong>${successCount}</strong>-м уровне из ${totalCount}`);
        return;
      }

      const success = await upgradeTalent(talentId, 1);

      if (!success) {
        progressModal.remove();
        return; // Ошибка уже показана в upgradeTalent
      }

      successCount++;
      progText.textContent = successCount;
      progFill.style.width = `${(successCount / totalCount) * 100}%`;

      // Задержка 200 мс (кроме последнего)
      if (i < totalCount - 1) {
        await new Promise(resolve => setTimeout(resolve, 200));
      }
    }

    // Успешное завершение
    progressModal.remove();
    await loadTalents();
    showSuccess('Готово!', `Талант прокачан на <strong>${successCount}</strong> уровней!`);
  }

  function closeOnClickOutside(e) {
    if (activeInput && !activeInput.closest('.upgrade-wrapper').contains(e.target)) {
      closeAllInputs();
      document.removeEventListener('click', closeOnClickOutside);
    }
  }

  function closeAllInputs() {
    if (!activeInput) return;
    activeInput.style.display = 'none';
    activeInput = null;
  }

  async function confirmMultiUpgrade(e) {
    e.stopPropagation();

    const btn = e.target;
    const overlay = btn.closest('.input-overlay');
    const input = overlay.querySelector('.multi-input');
    const talentId = overlay.closest('.upgrade-wrapper').querySelector('.upgrade-btn-multi').dataset.talentId;

    let count = parseInt(input.value, 10);

    if (isNaN(count) || count <= 0) {
      showError('Ошибка', 'Введите число больше 0');
      input.focus();
      return;
    }

    const max = parseInt(input.getAttribute('max'), 10);
    if (count > max) {
      count = max;
      input.value = count;
    }

    closeAllInputs();

    if (count === 1) {
      await upgradeTalent(talentId, 1);
    } else {
      confirmAction(
        'Массовая прокачка',
        `Прокачать талант <strong>${count}</strong> раз(а)?<br><small>Будет выполнено ${count} запросов</small>`,
        () => upgradeTalentMultipleTimes(talentId, count)
      );
    }
  }

  /** Working **/
  function createWorkerContent() {
    window.isWorkerRunning = false;
    window.workerStopRequested = false;
    window.chifirFailed = false;
    window.soapFailed = false;

    const div = document.createElement('div');
    div.className = 'tab-content';
    div.id = 'worker-content';

    const zoneNames = {1:'Бутырка',2:'Кр.Пресня',3:'Софийка',4:'Кресты',5:'В.Централ',
                        6:'Угольки',7:'М.Тишина',8:'Вол.Пятак', 9:'Лефортовка', 10:'Бел.Лебедь',
                        11:'Орл.Централ', 12:'Елец.Крытка', 13:'Чер.Дельфин', 14:'Грод.Крытка', 15:'А.Централ'};

    const masterNames = {1:'Петя',2:'Яша',3:'Илюша',4:'Нинка',5:'Ашот',6:'Шура',
                        7:'Макар',8:'Сева',9:'Жора',10:'Янка',11:'Ванька',12:'Пантелей',
                        13:'Кеша',14:'Саня',15:'Захар',16:'Паша'};

    div.innerHTML = `
<div class="worker-card">
  <h3 class="worker-title">Работяга</h3>

  <div class="worker-tabs">
    <button class="tab-btn active" data-tab="zones">Зоны</button>
    <button class="tab-btn" data-tab="masters">Мастера</button>
  </div>

  <!-- Зоны -->
  <div class="tab-panel active" id="zones-panel">
    <div class="form-group">
      <label class="form-label">Зоны</label>
      <div class="checkbox-grid">
  ${[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15].map(id => `
    <label class="custom-checkbox" title="${zoneNames[id]} (ID: ${id})">
      <input type="checkbox" class="zone-checkbox" value="${id}">
      <span class="checkmark"></span>
      <div class="label-text">
        <span>${zoneNames[id]}</span>
      </div>
    </label>
  `).join('')}
</div>
    </div>

    <div class="form-row">
      <div class="form-group">
        <label class="form-label">Режим</label>
        <select id="modeSelect" class="form-select">
          <option value="true">Ходки</option>
          <option value="false">Бунты</option>
        </select>
      </div>
      <div class="form-group">
        <label class="form-label">Запросов</label>
        <input type="number" id="requestsCount" class="form-input" value="100" min="1">
      </div>
    </div>

    <div class="form-group">
      <label class="form-label">Задержка (мс)</label>
      <input type="number" id="delayInput" class="form-input" value="1000" min="800">
    </div>
  </div>

  <!-- Мастера -->
  <div class="tab-panel" id="masters-panel">
    <div class="form-group">
      <label class="form-label">Мастера</label>
      <div class="checkbox-grid small">
  ${[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16].map(id => `
    <label class="custom-checkbox" title="${masterNames[id]} (ID: ${id})">
      <input type="checkbox" class="master-checkbox" value="${id}">
      <span class="checkmark"></span>
      <div class="label-text">
        <span>${masterNames[id]}</span>
      </div>
    </label>
  `).join('')}
</div>
    </div>

    <div class="form-row">
      <div class="form-group">
        <label class="form-label">Попыток</label>
        <input type="number" id="mastersRequestsCount" class="form-input" value="50" min="1">
      </div>
      <div class="form-group">
        <label class="form-label">Неудач до мыла</label>
        <input type="number" id="failsBeforeSoap" class="form-input" value="3" min="1">
      </div>
    </div>

    <div class="form-group" style="display:none;">
      <label class="form-label">Задержка (мс)</label>
      <input type="number" id="mastersDelayInput" class="form-input" value="400" min="0">
    </div>
  </div>

  <!-- Общие настройки -->
  <div class="common-settings">
    <div class="form-group">
      <label class="form-label">Способ восстановления Энергии</label>
      <div class="radio-group">
        <label class="custom-radio"><input type="radio" name="restoreMethod" value="chefir" checked><span class="radio-mark"></span><span class="label-text">Чифир</span></label>
        <label class="custom-radio"><input type="radio" name="restoreMethod" value="soap"><span class="radio-mark"></span><span class="label-text">Мыло</span></label>
        <label class="custom-radio"><input type="radio" name="restoreMethod" value="both"><span class="radio-mark"></span><span class="label-text">Мыло + Чифир</span></label>
        <label class="custom-radio"><input type="radio" name="restoreMethod" value="none"><span class="radio-mark"></span><span class="label-text">Без восстановления</span></label>
      </div>
    </div>

    <div class="form-row">
      <div class="form-group">
        <label class="form-label">Пауза каждые N-запросов</label>
        <input type="number" id="pauseAfterRequests" class="form-input" value="0" min="0" placeholder="0 = без">
      </div>
      <div class="form-group">
        <label class="form-label">Выдерживаемая пауза в (мин)</label>
        <input type="number" id="pauseDuration" class="form-input" value="10" min="1">
      </div>
    </div>
  </div>

  <div class="action-buttons">
    <button id="workerStart" class="btn-primary">Запустить</button>
    <button id="workerStop" class="btn-danger" disabled>Остановить</button>
  </div>

  <div class="status-bar" id="worker-status">Готово</div>
  <div class="progress-text" id="worker-progress">0 / 0</div>
</div>`;

    // === Переключение вкладок ===
    div.querySelectorAll('.worker-tabs .tab-btn').forEach(btn => {
      btn.onclick = () => {
        div.querySelectorAll('.worker-tabs .tab-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        div.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
        const panelId = btn.dataset.tab === 'zones' ? 'zones-panel' : 'masters-panel';
        div.querySelector('#' + panelId).classList.add('active');

        const isZones = btn.dataset.tab === 'zones';
        div.querySelector('#delayInput').style.display = isZones ? 'block' : 'none';
        div.querySelector('#mastersDelayInput').style.display = isZones ? 'none' : 'block';
      };
    });

    // === Статус ===
    window.updateWorkerStatus = (msg, type = '') => {
      const status = div.querySelector('#worker-status');
      const progress = div.querySelector('#worker-progress');
      status.textContent = msg;
      status.className = `status-bar ${type}`;
      if (type === 'success') status.classList.add('success');
      if (type === 'error') status.classList.add('error');
      if (type === 'running') status.classList.add('warning');
    };

    // === Кнопки ===
    div.querySelector('#workerStart').onclick = startWorkerHandler;
    div.querySelector('#workerStop').onclick = stopWorkerHandler;

    return div;
  }

  /** Mass Actions **/
  function attachActionHandlers() {
    document.querySelectorAll('.action-btn').forEach(btn => {
      btn.onclick = () => {
        const action = btn.dataset.action;
        let players = selectedPlayers;
        if (['biceps', 'droj', 'harknut', 'fight'].includes(action)) {
          players = talentFilteredPlayers.length ? talentFilteredPlayers : selectedPlayers;
        }
        if (!players.length) return showError('Ошибка', 'Выберите игроков!');

        const actions = {
          send: () => confirmAction('Отправить заявки', `Для ${players.length} игроков?`, () => sendFriendRequests(players)),
          remove: () => confirmAction('Удалить друзей', `Удалить ${players.length} друзей?`, () => removeFriends(players)),
          biceps: () => confirmAction('Бицуха', `Для ${players.length} игроков?`, () => performMassAction(players, 'UpgradeBiceps', 'Бицуха')),
          droj: () => confirmAction('Дрожжи', `Для ${players.length} игроков?`, () => performMassAction(players, 'TossDroj', 'Дрожжи')),
          harknut: () => confirmAction('Харкнуть', `Для ${players.length} игроков?`, () => performMassAction(players, 'Harknut', 'Харканье')),
          fight: () => confirmAction('Наезд', `Для ${players.length} игроков?`, () => performMassAction(players, 'Fight', 'Наезд')),
        };
        actions[action]?.();
      };
    });
  }
  async function sendFriendRequests(players) { await massAction(players, sendFriendRequest, 'заявок'); }
  async function removeFriends(players) { await massAction(players, removeFriend, 'удалений'); }
  async function performMassAction(players, type, name) { await massAction(players, p => performInteraction(p.userId, type), name); }

  async function massAction(players, action, name) {
    showProgressModal(players.length, name + '...');
    let success = 0, fail = 0;
    for (let i = 0; i < players.length; i++) {
      if (window.cancelRequest) break;
      try { await action(players[i]); success++; } catch { fail++; }
      updateProgress(i + 1, players.length, success, fail);
      await new Promise(r => setTimeout(r, 300));
    }
    completeProgress(name, success, fail, players.length);
  }

    /** Tab Friends **/

    function openTopPlayersModal() {
      if (!currentPlayers.length) {
        showError('Список пуст', 'Сначала загрузите список игроков');
        return;
      }

      document.getElementById('top-players-modal')?.remove();

      const modal = document.createElement('div');
      modal.id = 'top-players-modal';
      modal.className = 'prison-interface';
      modal.style.cssText = `
    position: fixed !important;
    top: 50% !important;
    left: 50% !important;
    transform: translate(-50%, -50%);
    width: 95vw !important;
    height: 80vh !important;
    max-width: 1000px;
    max-height: 700px;
    z-index: 10010 !important;
    resize: none;
    overflow: hidden;
    border-radius: 28px;
    box-shadow: 0 40px 100px rgba(0,0,0,0.8);
    background: linear-gradient(145deg, #1e293b, #0f172a);
  `;

      modal.innerHTML = `
  <div class="interface-header" style="padding:20px 28px; font-size:18px;">
    <div class="header-title">
      <svg width="26" height="26" viewBox="0 0 24 24" fill="currentColor" style="margin-right:12px;">
        <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
      </svg>
      <h3>ТОП ИГРОКОВ — ${currentPlayers.length.toLocaleString()} чел.</h3>
    </div>
    <div class="header-controls">
      <button class="ctrl-btn minimize" title="Свернуть">−</button>
      <button class="ctrl-btn close" title="Закрыть">×</button>
    </div>
  </div>

  <div class="interface-content" style="padding:24px; height:calc(100% - 80px); display:flex; flex-direction:column; gap:16px;">
    
    <!-- УПРАВЛЕНИЕ -->
    <div style="display:flex; gap:16px; flex-wrap:wrap; align-items:center; font-size:15px;">
      <select id="top-filter" class="status-filter" style="padding:10px 16px; min-width:180px;">
        <option value="all">Все игроки</option>
        <option value="friends">Только друзья</option>
        <option value="not-friends">Только не друзья</option>
      </select>

      <div style="display:flex; align-items:center; gap:12px; flex:1; min-width:300px;">
        <span style="white-space:nowrap;">Показать топ:</span>
        <input type="range" id="top-range" min="1" max="${currentPlayers.length}" value="500" 
               style="flex:1; height:8px;">
        <span id="top-range-label" style="min-width:80px; font-weight:600; color:#60a5fa;">1–500</span>
      </div>

      <input type="text" id="top-search" placeholder="Поиск по нику или ID..." 
             style="padding:12px 16px; border-radius:16px; border:1px solid #475569; background:#1e293b; color:white; width:300px; font-size:14px;">

      <button id="top-add-friends" class="action-btn success" style="padding:14px 28px; font-size:15px; display:none;">
        Добавить в друзья
      </button>

      <button id="top-collapse" class="collapse-btn" style="padding:12px 20px;">Свернуть</button>
    </div>

    <!-- ЗАГОЛОВОК ПРИ СВЁРНУТОМ СОСТОЯНИИ -->
    <div id="top-header-collapsed" class="players-table-header" 
         style="display:none; grid-template-columns:80px 70px 1fr 140px 160px; padding:16px 20px; font-size:16px; font-weight:600; background:rgba(52,71,85,0.9);">
      <div>Статус</div><div>#</div><div>Игрок</div><div>ID</div><div style="text-align:right">Урон</div>
    </div>

    <!-- ТАБЛИЦА -->
    <div id="top-table-wrap" class="players-table-container" style="flex:1; overflow:auto; border-radius:16px;">
      <table class="players-table" style="font-size:15px;">
        <thead style="position:sticky; top:0; z-index:10;">
          <tr>
            <th style="width:80px; text-align:center;">Статус</th>
            <th style="width:70px; text-align:center;">#</th>
            <th style="text-align:left;">Игрок</th>
            <th style="width:140px; text-align:center;">ID</th>
            <th style="width:120px; text-align:center;">Таланты</th>
            <th style="width:160px; text-align:right;">Урон</th>
          </tr>
        </thead>
        <tbody id="top-tbody"></tbody>
      </table>
    </div>
  </div>
  `;

      document.body.appendChild(modal);

      // Элементы
      const tbody = modal.querySelector('#top-tbody');
      const filter = modal.querySelector('#top-filter');
      const range = modal.querySelector('#top-range');
      const rangeLabel = modal.querySelector('#top-range-label');
      const search = modal.querySelector('#top-search');
      const addBtn = modal.querySelector('#top-add-friends');
      const collapseBtn = modal.querySelector('#top-collapse');
      const tableWrap = modal.querySelector('#top-table-wrap');
      const collapsedHeader = modal.querySelector('#top-header-collapsed');

      let collapsed = false;

      // ГЛАВНАЯ ФУНКЦИЯ ОТРИСОВКИ
      function render() {
        const maxShow = +range.value;
        const query = search.value.trim().toLowerCase();
        const filterMode = filter.value;

        let filtered = currentPlayers;

        // Фильтр по друзьям
        if (filterMode === 'friends') {
          filtered = filtered.filter(p => window.friendsList.includes(String(p.userId)));
        } else if (filterMode === 'not-friends') {
          filtered = filtered.filter(p => !window.friendsList.includes(String(p.userId)));
        }

        // Поиск
        if (query) {
          filtered = filtered.filter(p =>
            (p.nickname || '').toLowerCase().includes(query) ||
            String(p.userId).includes(query)
          );
        }

        // Обрезаем по слайдеру
        filtered = filtered.slice(0, maxShow);

        rangeLabel.textContent = `1–${filtered.length.toLocaleString()}`;

        // Кнопка "Добавить в друзья"
        const notFriends = filtered.filter(p => !window.friendsList.includes(String(p.userId)));
        addBtn.style.display = notFriends.length ? 'flex' : 'none';
        addBtn.onclick = () => addAllToFriends(notFriends);

        // Рендерим строки
        tbody.innerHTML = filtered.map(player => {
          const realPosition = currentPlayers.indexOf(player) + 1;
          const userId = String(player.userId);
          const isFriend = window.friendsList.includes(userId);

          // Таланты
          let talentsDisplay = '—';
          if (window.talentsCache?.[userId] !== undefined) {
            const points = window.talentsCache[userId];
            const color = points >= 700 ? '#f59e0b' : points >= 400 ? '#60a5fa' : '#94a3b8';
            talentsDisplay = `<span style="color:${color}; font-weight:600;">${points.toLocaleString()}</span>`;
          } else {
            talentsDisplay = `<button class="talent-btn" data-userid="${userId}" style="
          background:#1e293b; color:#94a3b8; border:1px solid #475569; 
          padding:4px 10px; border-radius:8px; font-size:12px; cursor:pointer;
        ">Показать</button>`;
          }

          return `
<tr style="height:52px;">
  <td style="text-align:center; font-size:20px;">
    ${isFriend ? 'Friend' : 'Cross'}
  </td>
  <td style="text-align:center; font-weight:700; color:#60a5fa; font-size:16px;">
    ${realPosition}
  </td>
  <td style="color:#e2e8f0;" title="${player.nickname || ''}">${player.nickname || '—'}</td>
  <td style="text-align:center; font-family:monospace; color:#94a3b8;">${userId}</td>
  <td style="text-align:center;">${talentsDisplay}</td>
  <td style="text-align:right; color:#86efac; font-weight:600;">
    ${(player.damage || 0).toLocaleString()}
  </td>
</tr>
      `.trim();
        }).join('');
      }

      // Обработчик кнопок "Показать таланты"
      tbody.addEventListener('click', async (e) => {
        const btn = e.target.closest('.talent-btn');
        if (!btn) return;
        const userId = btn.dataset.userid;
        const cell = btn.parentElement;

        btn.disabled = true;
        btn.textContent = 'Загрузка...';

        try {
          const points = await fetchTalentPoints(userId);
          const color = points >= 700 ? '#f59e0b' : points >= 400 ? '#60a5fa' : '#94a3b8';
          cell.innerHTML = `<span style="color:${color}; font-weight:600;">${points.toLocaleString()}</span>`;
        } catch (err) {
          cell.innerHTML = '<span style="color:#ef4444;">Ошибка</span>';
        }
      });

      // События
      filter.onchange = range.oninput = search.oninput = render;

      collapseBtn.onclick = () => {
        collapsed = !collapsed;
        collapseBtn.textContent = collapsed ? 'Развернуть' : 'Свернуть';
        tableWrap.style.display = collapsed ? 'none' : 'block';
        collapsedHeader.style.display = collapsed ? 'grid' : 'none';
        modal.style.height = collapsed ? 'auto' : '92vh';
      };

      modal.querySelector('.minimize').onclick = () => collapseBtn.click();
      modal.querySelector('.close').onclick = () => modal.remove();

      makeInterfaceDraggable(modal);
      bringToFront(modal);

      // Инициализация
      range.value = Math.min(500, currentPlayers.length);
      render();
    }

    function displayPlayersTable(players) {
      currentPlayers = players.map(p => ({
        ...p,
        userId: String(p.userId)
      }));

      // Обновляем кнопку
      const viewBtn = document.getElementById('view-top-table-btn');
      if (viewBtn) {
        viewBtn.style.display = 'block';
        viewBtn.onclick = openTopPlayersModal;
      }

      updateRangeInfo();
      updateStatus(`Загружено: ${currentPlayers.length} игроков`);
    }

    async function addAllToFriends(playersToAdd) {
      if (!playersToAdd.length) return;
      confirmAction('Добавить в друзья', `Отправить заявки ${playersToAdd.length} игрокам?`, async () => {
        const modal = showModal({
          title: 'Добавление в друзья',
          content: '<div id="add-progress">Подготовка...</div>',
          buttons: []
        });

        const progressEl = modal.querySelector('#add-progress');
        const cancelBtn = document.createElement('button');
        cancelBtn.textContent = 'Отмена';
        cancelBtn.className = 'prison-btn danger';
        let isCancelled = false;
        cancelBtn.onclick = () => {
          isCancelled = true;
          modal.remove();
          showError('Отменено', 'Процесс прерван.');
        };
        progressEl.appendChild(cancelBtn);

        let success = 0, failed = 0;
        for (let i = 0; i < playersToAdd.length; i++) {
          if (isCancelled) break;
          const p = playersToAdd[i];
          progressEl.firstChild.textContent = `Отправка... ${i + 1}/${playersToAdd.length}`;
          try {
            await sendFriendRequest(p);
            success++;
            window.friendsList.push(p.userId);
          } catch { failed++; }
          if (i < playersToAdd.length - 1) {
            await new Promise(r => setTimeout(r, 200 + Math.random() * 100));
          }

        }

        if (!isCancelled) {
          cancelBtn.remove();
          progressEl.innerHTML = `<div class="text-success">Успешно: ${success}</div>${failed ? `<div class="text-error">Ошибок: ${failed}</div>` : ''}`;
          const doneBtn = document.createElement('button');
          doneBtn.textContent = 'Готово';
          doneBtn.className = 'prison-btn primary';
          doneBtn.onclick = () => { modal.remove(); displayPlayersTable(currentPlayers); };
          progressEl.appendChild(doneBtn);
        }
      });
    }


  /** Progress **/
    /** Progress Modal — стиль основного окна, но в углу, без блюра **/
    function showProgressModal(total, title = "Выполняется...") {
      window.cancelRequest = false;

      // Удаляем старую, если была
      const old = document.getElementById('progress-interface');
      if (old) old.remove();

      const container = document.createElement('div');
      container.id = 'progress-interface';
      container.className = 'prison-interface';

      container.style.cssText = `
    position: fixed !important;
    top: 20px !important;
    left: 20px !important;
    width: 340px !important;
    z-index: 10001 !important;
    transition: all 0.3s ease !important;
  `;

      const header = document.createElement('div');
      header.className = 'interface-header';
      header.innerHTML = `
    <div class="header-title">
      <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" style="margin-right:8px;">
        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2" fill="none"/>
        <path d="M12 8v4l3 3" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
      </svg>
      <span style="font-size:15px;">${title}</span>
    </div>
  `;

      const controls = document.createElement('div');
      controls.className = 'header-controls';

      // Свернуть
      const minimizeBtn = document.createElement('button');
      minimizeBtn.className = 'ctrl-btn minimize';
      minimizeBtn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M5 12h14"/></svg>`;

      // Отмена
      const cancelBtn = document.createElement('button');
      cancelBtn.className = 'ctrl-btn close';
      cancelBtn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M18 6L6 18M6 6l12 12"/></svg>`;
      cancelBtn.title = 'Отменить';

      controls.append(minimizeBtn, cancelBtn);
      header.appendChild(controls);
      container.appendChild(header);

      // === Контент ===
      const content = document.createElement('div');
      content.className = 'interface-content';
      content.style.padding = '18px';
      content.innerHTML = `
    <div id="progress-text" style="font-size:15px; font-weight:600; margin-bottom:12px; text-align:center;">
      0 / ${total}
    </div>
    <div style="height:10px; background:#334155; border-radius:8px; overflow:hidden; margin-bottom:8px;">
      <div id="progress-fill" style="width:0%; height:100%; background:linear-gradient(90deg,#3b82f6,#1d4ed8); transition:width 0.4s ease;"></div>
    </div>
  `;

      container.appendChild(content);
      document.body.appendChild(container);


      makeInterfaceDraggable(container);


      // При клике — на передний план
      container.addEventListener('mousedown', () => bringToFront(container));

      let isMinimized = false;
      minimizeBtn.onclick = () => {
        isMinimized = !isMinimized;
        content.style.display = isMinimized ? 'none' : 'block';
        minimizeBtn.innerHTML = isMinimized
          ? `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M5 12h14M12 5v14"/></svg>`
          : `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M5 12h14"/></svg>`;
        container.style.height = isMinimized ? '64px' : 'auto';
      };

      // Отмена
      cancelBtn.onclick = () => {
        window.cancelRequest = true;
        document.getElementById('progress-text').textContent = 'Отменяется...';
        document.getElementById('progress-fill').style.width = '100%';
        document.getElementById('progress-fill').style.background = '#ef4444';
      };

      // Сохраняем ссылки
      window.__progressElements = {
        text: document.getElementById('progress-text'),
        fill: document.getElementById('progress-fill')
      };

      return container;
    }

// Обновление прогресса
    function updateProgress(current, total, success, fail) {
      const el = window.__progressElements;
      if (!el) return;
      el.text.textContent = `${current}/${total} | Успешно: ${success} | Ошибок: ${fail}`;
      el.fill.style.width = `${(current / total) * 100}%`;
    }

// Завершение
    function completeProgress(type, success, fail, total) {
      setTimeout(() => {
        const progress = document.getElementById('progress-interface');
        if (progress) {
          progress.style.transition = 'all 0.4s ease';
          progress.style.opacity = '0';
          progress.style.transform = 'translateY(-20px) scale(0.95)';
          setTimeout(() => progress.remove(), 400);
        }

        delete window.__progressElements;

        if (!window.cancelRequest) {
          showSuccess('Готово!', `Успешно: ${success}<br>Ошибок: ${fail}<br>Всего: ${total}`);
          updateStatus(`${type}: ${success}/${total}`);
        } else {
          showError('Отменено', 'Действие было прервано');
        }
      }, 600);
    }

  function updateStatus(msg) {
    const el = document.getElementById('friends-status');
    if (el) el.textContent = msg;
  }

  function updateRangeInfo() {
    const info = document.getElementById('range-info');
    if (info) {
      info.innerHTML = `Всего игроков: <strong>${currentPlayers.length}</strong> | Выбрано: <strong>${selectedPlayers.length}</strong>`;
    }
  }

  function toggleMinimize() {
    const container = document.getElementById('friends-interface');
    const content = container.querySelector('.interface-content');
    content.style.display = content.style.display === 'none' ? 'block' : 'none';
  }

  function bringToFront(element) {
    highestZIndex++;
    element.style.zIndex = highestZIndex;
  }

  function makeInterfaceDraggable(element) {
    const header = element.querySelector('.interface-header');
    if (!header) return;

    // Сохраняем/читаем смещение от перетаскивания
    let offsetX = parseFloat(element.dataset.dragX || '0');
    let offsetY = parseFloat(element.dataset.dragY || '0');

    // Сохраняем оригинальный transform (например translate(-50%, -50%))
    if (!element.dataset.originalTransform) {
      const computed = getComputedStyle(element).transform;
      element.dataset.originalTransform = (computed === 'none') ? '' : computed;
    }
    const originalTransform = element.dataset.originalTransform;

    // Применяем: оригинальный transform + смещение от drag
    const applyTransform = () => {
      if (offsetX === 0 && offsetY === 0) {
        element.style.transform = originalTransform || 'none';
      } else if (originalTransform && originalTransform !== 'none') {
        element.style.transform = `${originalTransform} translate(${offsetX}px, ${offsetY}px)`;
      } else {
        element.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
      }
      element.dataset.dragX = offsetX;
      element.dataset.dragY = offsetY;
    };

    // Применяем сразу при открытии (если уже таскали раньше)
    applyTransform();

    header.style.cursor = 'grab';
    element.addEventListener('mousedown', () => bringToFront(element));

    header.addEventListener('mousedown', function (e) {
      if (e.target.closest('.header-controls')) return;

      bringToFront(element);
      header.style.cursor = 'grabbing';

      const startX = e.clientX;
      const startY = e.clientY;
      const startOffsetX = offsetX;
      const startOffsetY = offsetY;

      const onMouseMove = (e) => {
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;

        offsetX = startOffsetX + deltaX;
        offsetY = startOffsetY + deltaY;

        applyTransform();
      };

      const onMouseUp = () => {
        header.style.cursor = 'grab';
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
      };

      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    });
  }

  /** Tattoo **/
  const TATTOO_CACHE_KEY = 'tp_tattoo_cache_v3';
  const CACHE_TTL = 5 * 60 * 1000; // 5 минут

  const COMBO_HINTS = {
    'Комплект "Храм мёртвых"': '(Комбо: Авто. Махно)',
    'Комплект "Метки судьбы"': '(Комбо: Авто. Шайба)',
    'Комплект "Тёмный район"': '(Комбо: Авто. Циклоп)',
    'Комплект "Воины духов"': '(Комбо: Сизый Блатной + Лютый Пацанский)',
    'Комплект "Дорога чести"': '(Комбо: Бурят Авторитетный)',
    'Комплект "Солнце Ацтеков"': '(Комбо: Бес Авторитетный)',
    'Комплект "Пепел и Пламя"': '(Комбо: Паленый Авторитетный)',
    'Комплект "Зомби"': '(Комбо: Авто. Сизый)',
    'Комплект "Короли ринга"': '(Комбо: Авто. Борзов)',
    'Комплект "Синдикат"': '(Комбо: Лютый Блатной)',
    'Комплект "Хранители"': '(Комбо: Авто. Палыч)'
  };

  async function fetchWithRetry(url, retries = 3) {
    for (let i = 0; i < retries; i++) {
      const res = await fetch(url, {
        headers: { 'authorization': getAuthToken(), 'accept': 'application/json' }
      });
      if (res.status === 429) {
        await new Promise(r => setTimeout(r, 200 * (i + 1)));
        continue;
      }
      return res;
    }
    throw new Error('429 после повторов');
  }

  async function loadOwnedTattooIds() {
    try {
      const res = await fetch('https://oldprison-prod.luckygem.online/api/clothing/inventory', {
        headers: { 'authorization': getAuthToken() }
      });
      if (!res.ok) return new Set();
      const data = await res.json();
      return new Set(data.ownedTattoos || []);
    } catch {
      return new Set();
    }
  }

  async function loadAllTattoos() {
    const cache = localStorage.getItem(TATTOO_CACHE_KEY);
    if (cache) {
      const { data, timestamp } = JSON.parse(cache);
      if (Date.now() - timestamp < CACHE_TTL) {
        return data;
      }
    }

    const all = [];
    let emptyStreak = 0;

    for (let zone = 1; zone <= 60; zone++) {
      try {
        const res = await fetchWithRetry(`https://oldprison-prod.luckygem.online/api/tattoo/by-zone?zone=${zone}`);
        if (!res.ok) {
          if (res.status === 400) break;
          emptyStreak++;
          if (emptyStreak >= 5) break;
          continue;
        }
        const data = await res.json();
        if (data.success && data.tattoos?.length) {
          all.push(...data.tattoos);
          emptyStreak = 0;
        } else {
          emptyStreak++;
          if (emptyStreak >= 5) break;
        }
      } catch (e) {
        emptyStreak++;
        if (emptyStreak >= 5) break;
      }
      await new Promise(r => setTimeout(r, 100));
    }

    const unique = Array.from(new Map(all.map(t => [t.id, t])).values());
    localStorage.setItem(TATTOO_CACHE_KEY, JSON.stringify({ data: unique, timestamp: Date.now() }));
    return unique;
  }

  function parseFullCount(desc) {
    const m = desc?.match(/за\s+(\d+)\s+тату/i);
    return m ? parseInt(m[1], 10) : null;
  }

  function buildSets(allTattoos) {
    const sets = {};

    allTattoos.forEach(t => {
      if (!t.setName?.trim() || !t.isSet) return;

      const key = t.setName.trim();

      if (!sets[key]) {
        sets[key] = {
          name: key,
          desc: '',
          sources: new Set(),
          pieces: [],
          buyOptions: {},
          canBeBought: false,
          authorityValue: 0,
          hasGambling: false,
          hasBoss: false,
          hasBaul: false,
          hasMaster: false,
          hasPrison: false,
          hasAchievement: false,
          hasTattooist: false,
          hasHacking: false,
          hasVoron: false
        };
      }

      const s = sets[key];

      if (t.id) s.pieces.push(t.id);
      if (t.setDescription && !s.desc) s.desc = t.setDescription;
      if (t.description) s.sources.add(t.description);

      // === Авторитет ===
      if (t.authorityValue && typeof t.authorityValue === 'number') {
        s.authorityValue += t.authorityValue;
      }

      // === Цена ===
      if (t.canBeBought && t.price > 0 && t.currency) {
        const allowed = ['rubles', 'paper', 'cigarettes', 'sugar', 'soap'];
        if (!allowed.includes(t.currency)) return;

        s.canBeBought = true;
        if (!s.buyOptions[t.currency]) s.buyOptions[t.currency] = 0;
        s.buyOptions[t.currency] += t.price;
      }

      // === ОПРЕДЕЛЯЕМ ИСТОЧНИК ===
      const desc = (t.description || '').toLowerCase();
      const setDesc = (t.setDescription || '').toLowerCase();

      // Азарт
      if (/карт|покер|колесе|фортуны|ставк|джекпот|рулетк/i.test(desc + setDesc)) {
        s.hasGambling = true;
      }

      // Боссы
      if (/босс|убийство|комбо|выпал|с босса|награда за убийство/i.test(desc + setDesc)) {
        s.hasBoss = true;
      }

      // Баулы
      if (/баул|только в бауле/i.test(desc + setDesc)) {
        s.hasBaul = true;
      }

      // Мастер
      if (/мастер|кузнец|алхимик|у мастера|обмен у мастера/i.test(desc + setDesc)) {
        s.hasMaster = true;
      }

      // Тюрьма
      if (/тюрьм|колония|зона|камера|побег|в тюрьме|тюремный/i.test(desc + setDesc)) {
        s.hasPrison = true;
      }

      // Достижения
      if (/достижения|за достижения|только за достижение/i.test(desc + setDesc)) {
        s.hasAchievement = true;
      }
      // Слепой кольщик
      if (/кольщик|слепо|татуировщик|салон|у кольщика|за рубли в салоне/i.test(desc + setDesc)) {
        s.hasTattooist = true;
      }
      // Зарубы
      if (/заруб|в зарубах/i.test(desc + setDesc)) {
        s.hasHacking = true;
      }
      // Ворон
      if (/ворон|с ворона|ворона/i.test(desc + setDesc)) {
        s.hasVoron = true;
      }
    });

    return Object.values(sets).map(s => {
      const full = parseFullCount(s.desc) || s.pieces.length;
      const sourceTextBase = Array.from(s.sources).join(' / ') || '—';
      const combo = COMBO_HINTS[s.name] || '';
      const source = combo ? (sourceTextBase !== '—' ? `${sourceTextBase} ${combo}` : combo) : sourceTextBase;

      const descLower = (s.desc || '').toLowerCase();
      const hasKnife = /пырнуть финк/i.test(descLower);
      const hasPoison = /подкинуть яд/i.test(descLower);
      const hasGun = /шмальн/i.test(descLower);
      const noBonus = !hasKnife && !hasPoison && !hasGun && /не даёт/i.test(descLower);

      let finalSource = source;

      // === Цены + Авторитет ===
      if (s.canBeBought && Object.keys(s.buyOptions).length > 0) {
        const icons = { rubles: '₽', paper: 'Б', cigarettes: 'сиг.', sugar: 'сах.', soap: 'мыло' };
        const colors = {
          rubles: '#f59e0b', paper: '#60a5fa', cigarettes: '#94a3b8',
          sugar: '#fca5a5', soap: '#c4b5fd'
        };

        const priceParts = Object.entries(s.buyOptions)
          .sort(([a], [b]) => a.localeCompare(b))
          .map(([currency, price]) => {
            return `<span style="color:${colors[currency] || '#e2e8f0'};font-weight:700;">
                  ${price.toLocaleString()} ${icons[currency]}
                </span>`;
          });

        const priceHtml = priceParts.join(' + ');
        const authHtml = s.authorityValue > 0
          ? ` <span style="color:#86efac;font-weight:700;">+${s.authorityValue.toLocaleString()} A</span>`
          : '';

        const fullInfo = priceHtml + authHtml;
        finalSource = finalSource !== '—' ? `${finalSource} • ${fullInfo}` : fullInfo;
      } else if (s.authorityValue > 0) {
        finalSource = finalSource !== '—'
          ? `${finalSource} • <span style="color:#86efac;font-weight:700;">+${s.authorityValue.toLocaleString()} A</span>`
          : `<span style="color:#86efac;font-weight:700;">+${s.authorityValue.toLocaleString()} A</span>`;
      }

      return {
        ...s,
        full,
        source: finalSource,
        hasKnife,
        hasPoison,
        hasGun,
        noBonus,
        hasGambling: s.hasGambling,
        hasBoss: s.hasBoss,
        hasMaster: s.hasMaster,
        hasPrison: s.hasPrison,
        hasAchievement: s.hasAchievement,
        hasTattooist: s.hasTattooist,
        hasHacking: s.hasHacking,
        hasBaul: s.hasBaul,
        hasVoron: s.hasVoron
      };
    }).sort((a, b) => a.name.localeCompare(b.name, 'ru'));
  }

  function initTattooPanel() {
    const existing = document.getElementById('tp-tattoo-panel');
    if (existing) {
      existing.remove();
      return;
    }

    updateStatus('Загружаем татуировки...');

    Promise.all([loadAllTattoos(), loadOwnedTattooIds()])
      .then(([allTattoos, ownedIds]) => {
        const sets = buildSets(allTattoos);
        createTattooPanel(sets, ownedIds);
        updateStatus('Готово');
      })
      .catch(e => {
        showError('Ошибка', 'Не удалось загрузить тату: ' + e.message);
      });
  }

  function createTattooPanel(sets, ownedIds) {
    const PANEL_ID = 'tp-tattoo-panel';
    const existing = document.getElementById(PANEL_ID);
    if (existing) existing.remove();

    const panel = document.createElement('div');
    panel.id = PANEL_ID;
    panel.className = 'tp-tattoo-panel';

    const panelWidth = 640;
    const panelHeight = 600;
    const centerX = (window.innerWidth - panelWidth) / 2 + window.scrollX;
    const centerY = (window.innerHeight - panelHeight) / 2 + window.scrollY;
    panel.style.left = Math.max(10, centerX) + 'px';
    panel.style.top = Math.max(10, centerY) + 'px';
    panel.style.width = panelWidth + 'px';
    panel.style.height = panelHeight + 'px';

    const header = document.createElement('div');
    header.className = 'tattoo-header';
    header.innerHTML = `
    <div style="font-weight:600; color:#60a5fa;">Сеты Татуировок и их бонусы</div>
    <div style="display:flex; gap:8px;">
      <button id="minimize-tattoo" style="width:32px; height:32px; background:#64748b; color:white; border:none; border-radius:50%; font-size:16px; cursor:pointer;">–</button>
      <button id="close-tattoo" style="width:32px; height:32px; background:#ef4444; color:white; border:none; border-radius:50%; font-size:16px; cursor:pointer;">×</button>
    </div>
  `;

    const minimizeBtn = header.querySelector('#minimize-tattoo');
    const closeBtn = header.querySelector('#close-tattoo');
    let isMinimized = false;

    const content = document.createElement('div');
    content.style.cssText = `display:flex; flex-direction:column; height:calc(100% - 56px);`;

    // === ПОИСК ===
    const searchBar = document.createElement('div');
    searchBar.style.cssText = `padding:8px 16px; background:#1e293b; border-bottom:1px solid #475569;`;
    searchBar.innerHTML = `
    <input type="text" id="tattoo-search" placeholder="Поиск по названию сета..." 
           style="width:100%; padding:8px 12px; background:#334155; color:#e5e7eb; 
                  border:1px solid #475569; border-radius:8px; font-size:13px; outline:none;">
  `;

    const searchInput = searchBar.querySelector('#tattoo-search');
    let searchQuery = '';
    let activeTab = 'all';
    let collectFilter = 'all';
    let sourceFilter = 'all';

    searchInput.oninput = () => {
      searchQuery = searchInput.value.toLowerCase().trim();
      updateTable();
    };

    // === КОНТРОЛЬ ===
    const controlsBar = document.createElement('div');
    controlsBar.style.cssText = `display:flex; flex-direction:column; gap:10px; padding:8px 16px; background:#1e293b;`;

    // Вкладки
    const tabs = document.createElement('div');
    tabs.style.cssText = `display:flex; gap:8px; flex-wrap:wrap;`;

    const tabData = [
      { key: 'all',    label: 'Все сеты',   color: '#e2e8f0' },
      { key: 'knife',  label: 'Финка',     color: '#f87171' },
      { key: 'poison', label: 'Яд',        color: '#34d399' },
      { key: 'gun',    label: 'Самопал',   color: '#60a5fa' },
      { key: 'none',   label: 'Без бонуса',color: '#94a3b8' }
    ];

    tabData.forEach(t => {
      const btn = document.createElement('button');
      btn.textContent = t.label;
      btn.dataset.key = t.key;
      btn.style.cssText = `
      padding:6px 12px; border:none; border-radius:8px; font-size:12px; font-weight:600;
      background:${t.key === 'all' ? '#e2e8f0' : '#334155'};
      color:${t.key === 'all' ? '#000' : 'white'};
      cursor:pointer; transition:all 0.2s;
    `;
      btn.onclick = () => {
        activeTab = t.key;
        updateActiveButtons();
        updateTable();
      };
      tabs.appendChild(btn);
    });

    // Фильтр: Все / Собраны / Не собраны
    const collectGroup = document.createElement('div');
    collectGroup.style.cssText = `display:flex; gap:6px; background:#334155; border-radius:8px; padding:4px;`;
    const collectFilters = [
      { key: 'all',       label: 'Все',       color: '#60a5fa' },
      { key: 'collected', label: 'Собраны',   color: '#34d399' },
      { key: 'missing',   label: 'Не собраны',color: '#ef4444' }
    ];
    collectFilters.forEach(f => {
      const btn = document.createElement('button');
      btn.textContent = f.label;
      btn.dataset.filter = f.key;
      btn.style.cssText = `padding:5px 10px; border:none; border-radius:6px; font-size:11px; cursor:pointer; background:${f.key === 'all' ? f.color : 'transparent'}; color:white;`;
      btn.onclick = () => {
        collectFilter = f.key;
        collectGroup.querySelectorAll('button').forEach(b => b.style.background = b.dataset.filter === collectFilter ? collectFilters.find(x => x.key === collectFilter).color : 'transparent');
        updateTable();
      };
      collectGroup.appendChild(btn);
    });

    // НОВЫЕ ФИЛЬТРЫ ПО ИСТОЧНИКАМ
    const sourceGroup = document.createElement('div');
    sourceGroup.style.cssText = `display:flex; gap:6px; background:#334155; border-radius:8px; padding:4px; flex-wrap:wrap;`;

    const sourceFilters = [
      { key: 'all',         label: 'Все источники', color: '#64748b' },
      { key: 'gambling',    label: 'Азарт',        color: '#f59e0b' },
      { key: 'boss',        label: 'Боссы',        color: '#ef4444' },
      { key: 'baul',        label: 'Баулы',        color: '#ef4444' },
      { key: 'master',      label: 'Мастера',      color: '#8b5cf6' },
      { key: 'prison',      label: 'Тюрьмы',       color: '#06b6d4' },
      // { key: 'achievement', label: 'Достижения',   color: '#10b981' }, Достижения пока выкл. в них только шмот
      { key: 'tattooist',   label: 'Кольщик',     color: '#ff6b6b' },
      { key: 'hacking',   label: 'Зарубы',     color: '#ff6b6b' },
      { key: 'voron',      label: 'Ворон',       color: '#06b6d4' },
    ];

    sourceFilters.forEach(f => {
      const btn = document.createElement('button');
      btn.textContent = f.label;
      btn.dataset.source = f.key;
      btn.style.cssText = `padding:5px 10px; border:none; border-radius:6px; font-size:11px; cursor:pointer; background:${f.key === 'all' ? f.color : 'transparent'}; color:white; transition:all 0.2s;`;
      btn.onclick = () => {
        sourceFilter = f.key;
        sourceGroup.querySelectorAll('button').forEach(b => {
          const sf = sourceFilters.find(x => x.key === b.dataset.source);
          b.style.background = b.dataset.source === sourceFilter ? sf.color : 'transparent';
        });
        updateTable();
      };
      sourceGroup.appendChild(btn);
    });

    controlsBar.append(tabs, collectGroup, sourceGroup);

    const tableWrap = document.createElement('div');
    tableWrap.style.cssText = `flex:1; overflow:auto; padding:12px;`;

    function updateActiveButtons() {
      tabs.querySelectorAll('button').forEach(b => {
        const data = tabData.find(d => d.key === b.dataset.key);
        const isActive = b.dataset.key === activeTab;
        b.style.background = isActive ? (data.key === 'all' ? '#e2e8f0' : data.color) : '#334155';
        b.style.color = data.key === 'all' ? '#000' : 'white';
      });
    }

    function updateTable() {
      let filtered = sets.filter(s => {
        // Вкладка
        if (activeTab !== 'all') {
          if (activeTab === 'knife' && !s.hasKnife) return false;
          if (activeTab === 'poison' && !s.hasPoison) return false;
          if (activeTab === 'gun' && !s.hasGun) return false;
          if (activeTab === 'none' && !s.noBonus) return false;
        }

        // Собранность
        const ownedCount = s.pieces.filter(id => ownedIds.has(id)).length;
        const isCollected = ownedCount >= s.full;
        if (collectFilter === 'collected' && !isCollected) return false;
        if (collectFilter === 'missing' && isCollected) return false;

        // Источник (новый фильтр)
        if (sourceFilter !== 'all') {
          if (sourceFilter === 'gambling' && !s.hasGambling) return false;
          if (sourceFilter === 'boss' && !s.hasBoss) return false;
          if (sourceFilter === 'baul' && !s.hasBaul) return false;
          if (sourceFilter === 'master' && !s.hasMaster) return false;
          if (sourceFilter === 'prison' && !s.hasPrison) return false;
          if (sourceFilter === 'achievement' && !s.hasAchievement) return false;
          if (sourceFilter === 'tattooist' && !s.hasTattooist) return false;
          if (sourceFilter === 'hacking' && !s.hasHacking) return false;
          if (sourceFilter === 'voron' && !s.hasVoron) return false;
        }

        // Поиск
        if (searchQuery && !s.name.toLowerCase().includes(searchQuery)) return false;

        return true;
      });

      const sorted = [...filtered].sort((a, b) => {
        const pa = a.pieces.filter(id => ownedIds.has(id)).length / a.full;
        const pb = b.pieces.filter(id => ownedIds.has(id)).length / b.full;
        return pb - pa || (b.authorityValue || 0) - (a.authorityValue || 0);
      });

      const rows = sorted.map(s => {
        const owned = s.pieces.filter(id => ownedIds.has(id)).length;
        const total = s.full;
        const done = owned >= total;

        const highlightedName = searchQuery
          ? s.name.replace(new RegExp(`(${searchQuery})`, 'gi'), '<span style="background:#f59e0b;color:#000;padding:0 2px;border-radius:2px;">$1</span>')
          : s.name;

        return `
        <tr style="border-bottom:1px solid #334155; ${done ? 'background:rgba(34,197,94,0.15);' : ''}">
          <td style="padding:8px 6px; color:#60a5fa; font-weight:500; white-space:nowrap; width:160px;">
            <div style="overflow:hidden; text-overflow:ellipsis;" title="${s.name}">${highlightedName}</div>
          </td>
          <td style="padding:8px 6px; text-align:center; color:${done?'#34d399':'#fbbf24'}; font-weight:700; width:80px;">${owned}/${total}</td>
          <td style="padding:8px 6px; text-align:center; color:#fbbf24; font-size:11px; line-height:1.3; width:150px; word-wrap:break-word;">${s.desc || '—'}</td>
          <td style="padding:8px 6px; text-align:center; color:#94a3b8; font-size:11px; line-height:1.3; width:130px; word-wrap:break-word;">${s.source || '—'}</td>
        </tr>
      `;
      }).join('');

      const infoText = searchQuery
        ? `Найдено: ${sorted.length}`
        : `Показано: ${sorted.length} из ${sets.length} | Тату в инвентаре: ${ownedIds.size}`;

      tableWrap.innerHTML = `
      <div style="margin-bottom:8px; color:#94a3b8; font-size:12px; text-align:center;">${infoText}</div>
      <table style="width:100%; border-collapse:collapse; font-size:13px; table-layout:fixed;">
        <thead>
          <tr style="background:#1e293b; position:sticky; top:0;">
            <th style="text-align:left; padding:8px 6px; width:160px;">Сет</th>
            <th style="text-align:center; padding:8px 6px; width:80px;">Собрано</th>
            <th style="text-align:center; padding:8px 6px; width:150px;">Бонус</th>
            <th style="text-align:center; padding:8px 6px; width:130px;">Источник</th>
          </tr>
        </thead>
        <tbody>${rows}</tbody>
      </table>
    `;
    }

    // === DRAG & RESIZE ===
    let isDragging = false;
    let isResizing = false;
    let startX, startY, startLeft, startTop, startW, startH;

    const startDrag = (e) => {
      if (e.target.tagName === 'BUTTON') return;
      isDragging = true;
      startX = e.clientX;
      startY = e.clientY;
      startLeft = panel.offsetLeft;
      startTop = panel.offsetTop;
      document.body.style.userSelect = 'none';
    };

    const startResize = (e) => {
      e.stopPropagation();
      isResizing = true;
      startX = e.clientX;
      startY = e.clientY;
      startW = panel.offsetWidth;
      startH = panel.offsetHeight;
      document.body.style.userSelect = 'none';
    };

    const handleMove = (e) => {
      if (isDragging) {
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        panel.style.left = `${startLeft + dx}px`;
        panel.style.top = `${startTop + dy}px`;
      } else if (isResizing) {
        const dw = e.clientX - startX;
        const dh = e.clientY - startY;
        panel.style.width = `${Math.max(620, startW + dw)}px`;
        panel.style.height = `${Math.max(400, startH + dh)}px`;
      }
    };

    const handleUp = () => {
      if (isDragging || isResizing) {
        isDragging = isResizing = false;
        document.body.style.userSelect = '';
      }
    };

    header.addEventListener('mousedown', startDrag);
    document.addEventListener('mousemove', handleMove);
    document.addEventListener('mouseup', handleUp);

    const resizeHandle = document.createElement('div');
    resizeHandle.style.cssText = `position:absolute;right:0;bottom:0;width:16px;height:16px;cursor:se-resize;background:transparent;`;
    resizeHandle.innerHTML = `<svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg" style="position:absolute;right:4px;bottom:4px;">
    <path d="M12 0L0 12M12 4L8 8M12 8L4 12" stroke="#64748b" stroke-width="1.5"/>
  </svg>`;
    resizeHandle.addEventListener('mousedown', startResize);
    panel.appendChild(resizeHandle);

    closeBtn.onclick = () => {
      document.removeEventListener('mousemove', handleMove);
      document.removeEventListener('mouseup', handleUp);
      header.removeEventListener('mousedown', startDrag);
      resizeHandle.removeEventListener('mousedown', startResize);
      panel.remove();
    };

    minimizeBtn.onclick = (e) => {
      e.stopPropagation();
      isMinimized = !isMinimized;
      panel.style.height = isMinimized ? '40px' : '600px';
      minimizeBtn.textContent = isMinimized ? '+' : '–';
      content.style.display = isMinimized ? 'none' : 'flex';
    };

    content.append(searchBar, controlsBar, tableWrap);
    panel.append(header, content);
    document.body.appendChild(panel);

    updateActiveButtons();
    updateTable();
  }

  /** Clothing **/

  const CLOTHING_CACHE_KEY = 'tp_clothing_cache_v5';
  const CACHE_TTLL = 5 * 60 * 1000; // 5 минут

  // Загрузка всех зон шмота (1-8)
  async function loadAllClothing() {
    const cache = localStorage.getItem(CLOTHING_CACHE_KEY);
    if (cache) {
      const { data, timestamp } = JSON.parse(cache);
      if (Date.now() - timestamp < CACHE_TTLL) {
        console.log('Шмот из кэша');
        return data;
      }
    }

    console.log('Загружаем шмот по зонам 1-8...');
    const allClothing = [];

    for (let zone = 1; zone <= 8; zone++) {
      try {
        const token = getAuthToken();
        const res = await fetch(`https://oldprison-prod.luckygem.online/api/clothing/by-zone?zone=${zone}`, {
          headers: {
            'authorization': token,
            'accept': 'application/json'
          }
        });

        if (!res.ok) {
          console.warn(`Зона ${zone}: ${res.status}`);
          continue;
        }

        const data = await res.json();
        if (data.success && Array.isArray(data.clothing)) {
          allClothing.push(...data.clothing);
          console.log(`Зона ${zone}: ${data.clothing.length} предметов`);
        }
      } catch (e) {
        console.warn(`Ошибка зоны ${zone}:`, e.message);
      }

      // Задержка между запросами
      await new Promise(r => setTimeout(r, 150));
    }

    // Удаляем дубликаты по ID
    const uniqueClothing = Array.from(new Map(allClothing.map(c => [c.id, c])).values());

    localStorage.setItem(CLOTHING_CACHE_KEY, JSON.stringify({
      data: uniqueClothing,
      timestamp: Date.now()
    }));

    console.log(`Всего уникального шмота: ${uniqueClothing.length}`);
    return uniqueClothing;
  }

  // Парсинг количества предметов в сете
  function parseClothingSetCount(setDescription) {
    if (!setDescription) return null;

    // Регулярки для разных вариантов
    const patterns = [
      /за\s+(\d+)\s+вещ/i,
      /за\s+(\d+)\s+предмет/i,
      /за\s+(\d+)\s+тату/i
    ];

    for (const pattern of patterns) {
      const match = setDescription.match(pattern);
      if (match) return parseInt(match[1], 10);
    }

    return null;
  }

  // === Построение сетов шмота ===
  function buildClothingSets(allClothing) {
    const sets = {};

    allClothing.forEach(clothing => {
      const setName = clothing.setName?.trim();
      if (!setName || !clothing.isSet) return;

      if (!sets[setName]) {
        sets[setName] = {
          name: setName,
          pieces: [],
          setDescription: '',
          sources: new Set(),
          buyPrice: 0,
          buyCurrency: null,
          canBeBought: false,
          authorityValue: 0,
          // ← новые флаги
          hasGambling: false,
          hasBoss: false,
          hasMaster: false,
          hasPrison: false,
          hasAchievement: false,
        };
      }

      const set = sets[setName];

      // собираем части сета
      set.pieces.push(clothing.id);
      if (set.setDescription === '' && clothing.setDescription) {
        set.setDescription = clothing.setDescription;
      }
      if (clothing.description) {
        set.sources.add(clothing.description);
      }

      // === Цена (одинаковая валюта у всех частей) ===
      if (clothing.canBeBought && clothing.price > 0 && clothing.currency) {
        const allowed = ['rubles', 'paper', 'cigarettes', 'sugar', 'soap'];
        if (!allowed.includes(clothing.currency)) return;

        if (!set.canBeBought) {
          set.buyCurrency = clothing.currency;
          set.canBeBought = true;
        }

        if (set.buyCurrency === clothing.currency) {
          set.buyPrice += clothing.price;
        } else {
          // разные валюты в одном сете — считаем непокупным
          set.canBeBought = false;
          set.buyPrice = 0;
          set.buyCurrency = null;
        }
      }

      // === Авторитет ===
      if (clothing.authorityValue && typeof clothing.authorityValue === 'number') {
        set.authorityValue += clothing.authorityValue;
      }

      // === АВТОМАТИЧЕСКОЕ ОПРЕДЕЛЕНИЕ ИСТОЧНИКОВ ===
      const text = (clothing.description || '' + clothing.setDescription || '').toLowerCase();

      if (/карт|покер|колесе|фортуны|ставк|джекпот|рулетк|казино/i.test(text)) {
        set.hasGambling = true;
      }
      if (/босс|убийство|комбо|награда за убийство|с босса/i.test(text)) {
        set.hasBoss = true;
      }
      if (/мастер|кузнец|алхимик|обмен|выдаёт мастер|у мастера/i.test(text)) {
        set.hasMaster = true;
      }
      if (/тюрьм|колония|зона|камера|побег|тюремный/i.test(text)) {
        set.hasPrison = true;
      }
      if (/достижения|награда|медаль|угодно|легенда|за достижения|выдано за/i.test(text)) {
        set.hasAchievement = true;
      }
    });

    // === Формируем финальный массив сетов ===
    return Object.values(sets).map(set => {
      const fullCount = parseClothingSetCount(set.setDescription) || set.pieces.length;
      const source = Array.from(set.sources).join(' / ') || '—';

      const descLower = (set.setDescription || '').toLowerCase();
      const hasKnife = /п(ы[рр]нуть|ырнуть)\s+финк/i.test(descLower);
      const hasPoison = /подкинуть\s+яд/i.test(descLower);
      const hasGun = /шмальн/i.test(descLower);
      const noBonus = /не\s+даёт/i.test(descLower);

      let sourceText = source;

      // Цена + авторитет
      if (set.canBeBought && set.buyPrice > 0 && set.buyCurrency) {
        const icons = { rubles: '₽', paper: 'Б', cigarettes: 'сиг.', sugar: 'сах.', soap: 'мыло' };
        const colors = {
          rubles: '#f59e0b', paper: '#60a5fa', cigarettes: '#94a3b8',
          sugar: '#fca5a5', soap: '#c4b5fd'
        };
        const priceHtml = `<span style="color:${colors[set.buyCurrency]};font-weight:700;">
                         ${set.buyPrice.toLocaleString()} ${icons[set.buyCurrency]}
                       </span>`;
        const authHtml = set.authorityValue > 0
          ? ` <span style="color:#86efac;font-weight:700;">+${set.authorityValue.toLocaleString()} A</span>`
          : '';
        const fullInfo = `${priceHtml}${authHtml}`;
        sourceText = sourceText && sourceText !== '—' ? `${sourceText} • ${fullInfo}` : fullInfo;
      } else if (set.authorityValue > 0) {
        sourceText += (sourceText && sourceText !== '—' ? ' • ' : '') +
          `<span style="color:#86efac;font-weight:700;">+${set.authorityValue.toLocaleString()} A</span>`;
      }

      return {
        ...set,
        full: fullCount,
        source: sourceText,
        hasKnife,
        hasPoison,
        hasGun,
        noBonus,
        hasGambling: set.hasGambling,
        hasBoss: set.hasBoss,
        hasMaster: set.hasMaster,
        hasPrison: set.hasPrison,
        hasAchievement: set.hasAchievement
      };
    }).sort((a, b) => a.name.localeCompare(b.name, 'ru'));
  }

  // Загрузка инвентаря игрока
  async function loadOwnedClothingIds() {
    try {
      const token = getAuthToken();
      const res = await fetch('https://oldprison-prod.luckygem.online/api/clothing/inventory', {
        headers: {
          'authorization': token,
          'accept': 'application/json'
        }
      });

      if (!res.ok) return new Set();

      const data = await res.json();
      return new Set(data.ownedClothing || []);
    } catch (e) {
      console.warn('Ошибка инвентаря шмота:', e.message);
      return new Set();
    }
  }

  // Инициализация панели шмота
  function initClothingPanel() {
    // Закрываем существующую панель
    const existing = document.getElementById('tp-clothing-panel');
    if (existing) {
      existing.remove();
      return;
    }

    updateStatus('Загружаем шмот...');

    Promise.all([loadAllClothing(), loadOwnedClothingIds()])
      .then(([allClothing, ownedIds]) => {
        const sets = buildClothingSets(allClothing);
        createClothingPanel(sets, ownedIds);
        updateStatus(`Шмот: ${sets.length} сетов`);
      })
      .catch(e => {
        console.error('Ошибка загрузки шмота:', e);
        showError('Ошибка шмота', e.message);
      });
  }


  // Создание панели (для шмота)
  function createClothingPanel(sets, ownedIds) {
    const PANEL_ID = 'tp-clothing-panel';
    const existing = document.getElementById(PANEL_ID);
    if (existing) existing.remove();

    const panel = document.createElement('div');
    panel.id = PANEL_ID;
    panel.style.cssText = `
    position: fixed; z-index: 99999; font-family: system-ui;
    background: #0f172a; color: #e2e8f0; border: 1px solid #475569;
    border-radius: 16px; box-shadow: 0 20px 40px rgba(0,0,0,0.6);
    overflow: hidden; cursor: default; user-select: none;
    transition: all 0.3s ease; min-width: 640px; min-height: 500px;
  `;

    const panelWidth = 640;
    const panelHeight = 600;
    const centerX = (window.innerWidth - panelWidth) / 2 + window.scrollX;
    const centerY = (window.innerHeight - panelHeight) / 2 + window.scrollY;
    panel.style.left = Math.max(10, centerX) + 'px';
    panel.style.top = Math.max(10, centerY) + 'px';
    panel.style.width = panelWidth + 'px';
    panel.style.height = panelHeight + 'px';

    let isMinimized = false;

    const header = document.createElement('div');
    header.style.cssText = `
    padding: 12px 16px; background: #1e293b; display: flex;
    justify-content: space-between; align-items: center; cursor: move;
    border-bottom: 1px solid #475569; position: relative;
  `;
    header.innerHTML = `
    <div style="font-weight:600; color:#8b5cf6;">Сеты Шмота и их бонусы(<strong>${sets.length}</strong>)</div>
    <div style="display:flex; gap:8px;">
      <button id="minimize-clothing" style="width:32px; height:32px; background:#64748b; color:white; border:none; border-radius:50%; font-size:16px; cursor:pointer;">–</button>
      <button id="close-clothing" style="width:32px; height:32px; background:#ef4444; color:white; border:none; border-radius:50%; font-size:16px; cursor:pointer;">×</button>
    </div>
  `;

    const content = document.createElement('div');
    content.style.cssText = `display:flex; flex-direction:column; height:calc(100% - 56px);`;

    const searchBar = document.createElement('div');
    searchBar.style.cssText = `padding:8px 16px; background:#1e293b; border-bottom:1px solid #475569;`;
    searchBar.innerHTML = `
    <input type="text" id="clothing-search" placeholder="Поиск по названию сета..." 
           style="width:100%; padding:8px 12px; background:#334155; color:#e5e7eb; 
                  border:1px solid #475569; border-radius:8px; font-size:13px; outline:none;">
  `;

    const searchInput = searchBar.querySelector('#clothing-search');
    let searchQuery = '';
    let activeTab = 'all';
    let collectFilter = 'all';
    let sourceFilter = 'all';

    searchInput.oninput = () => {
      searchQuery = searchInput.value.toLowerCase().trim();
      updateClothingTable();
    };

    const controlsBar = document.createElement('div');
    controlsBar.style.cssText = `display:flex; flex-direction:column; gap:10px; padding:8px 16px; background:#1e293b;`;

    const tabs = document.createElement('div');
    tabs.style.cssText = `display:flex; gap:8px; flex-wrap:wrap;`;

    const tabData = [
      { key: 'all',    label: 'Все сеты',   color: '#e2e8f0' },
      { key: 'knife',  label: 'Финка',     color: '#f87171' },
      { key: 'poison', label: 'Яд',        color: '#34d399' },
      { key: 'gun',    label: 'Самопал',   color: '#60a5fa' },
      { key: 'none',   label: 'Без бонуса',color: '#94a3b8' }
    ];

    tabData.forEach(t => {
      const btn = document.createElement('button');
      btn.textContent = t.label;
      btn.dataset.key = t.key;
      btn.style.cssText = `
      padding:6px 12px; border:none; border-radius:8px; font-size:12px; font-weight:600;
      background:${t.key === 'all' ? '#e2e8f0' : '#334155'};
      color:${t.key === 'all' ? '#000' : 'white'};
      cursor:pointer; transition:all 0.2s;
    `;
      btn.onclick = () => {
        activeTab = t.key;
        updateTabButtons();
        updateClothingTable();
      };
      tabs.appendChild(btn);
    });

    const collectGroup = document.createElement('div');
    collectGroup.style.cssText = `display:flex; gap:6px; background:#334155; border-radius:8px; padding:4px;`;
    const collectFilters = [
      { key: 'all',       label: 'Все',       color: '#8b5cf6' },
      { key: 'collected', label: 'Собраны',   color: '#34d399' },
      { key: 'missing',   label: 'Не собраны',color: '#ef4444' }
    ];
    collectFilters.forEach(f => {
      const btn = document.createElement('button');
      btn.textContent = f.label;
      btn.dataset.filter = f.key;
      btn.style.cssText = `padding:5px 10px; border:none; border-radius:6px; font-size:11px; cursor:pointer; background:${f.key === 'all' ? f.color : 'transparent'}; color:white;`;
      btn.onclick = () => {
        collectFilter = f.key;
        collectGroup.querySelectorAll('button').forEach(b => b.style.background = b.dataset.filter === collectFilter ? collectFilters.find(x => x.key === collectFilter).color : 'transparent');
        updateClothingTable();
      };
      collectGroup.appendChild(btn);
    });

    const sourceGroup = document.createElement('div');
    sourceGroup.style.cssText = `display:flex; gap:6px; background:#334155; border-radius:8px; padding:4px; flex-wrap:wrap;`;

    const sourceFilters = [
      { key: 'all',         label: 'Все источники', color: '#64748b' },
      { key: 'gambling',    label: 'Азарт',        color: '#f59e0b' },
      { key: 'boss',        label: 'Боссы',        color: '#ef4444' },
      { key: 'master',      label: 'Мастера',      color: '#8b5cf6' },
      { key: 'prison',      label: 'Тюрьмы',       color: '#06b6d4' },
      { key: 'achievement', label: 'Достижения',   color: '#10b981' }
    ];

    sourceFilters.forEach(f => {
      const btn = document.createElement('button');
      btn.textContent = f.label;
      btn.dataset.source = f.key;
      btn.style.cssText = `padding:5px 10px; border:none; border-radius:6px; font-size:11px; cursor:pointer; background:${f.key === 'all' ? f.color : 'transparent'}; color:white; transition:all 0.2s;`;
      btn.onclick = () => {
        sourceFilter = f.key;
        sourceGroup.querySelectorAll('button').forEach(b => {
          const sf = sourceFilters.find(x => x.key === b.dataset.source);
          b.style.background = b.dataset.source === sourceFilter ? sf.color : 'transparent';
        });
        updateClothingTable();
      };
      sourceGroup.appendChild(btn);
    });

    controlsBar.append(tabs, collectGroup, sourceGroup);

    const tableWrap = document.createElement('div');
    tableWrap.style.cssText = `flex:1; overflow:auto; padding:12px;`;

    function updateTabButtons() {
      tabs.querySelectorAll('button').forEach(b => {
        const data = tabData.find(d => d.key === b.dataset.key);
        const isActive = b.dataset.key === activeTab;
        b.style.background = isActive ? (data.key === 'all' ? '#e2e8f0' : data.color) : '#334155';
        b.style.color = data.key === 'all' ? '#000' : 'white';
      });
    }

    function updateClothingTable() {
      let filtered = sets.filter(s => {
        if (activeTab !== 'all') {
          if (activeTab === 'knife' && !s.hasKnife) return false;
          if (activeTab === 'poison' && !s.hasPoison) return false;
          if (activeTab === 'gun' && !s.hasGun) return false;
          if (activeTab === 'none' && !s.noBonus) return false;
        }

        const owned = s.pieces.filter(id => ownedIds.has(id)).length;
        const isCollected = owned >= s.full;
        if (collectFilter === 'collected' && !isCollected) return false;
        if (collectFilter === 'missing' && isCollected) return false;

        if (sourceFilter !== 'all') {
          if (sourceFilter === 'gambling' && !s.hasGambling) return false;
          if (sourceFilter === 'boss' && !s.hasBoss) return false;
          if (sourceFilter === 'master' && !s.hasMaster) return false;
          if (sourceFilter === 'prison' && !s.hasPrison) return false;
          if (sourceFilter === 'achievement' && !s.hasAchievement) return false;
        }

        if (searchQuery && !s.name.toLowerCase().includes(searchQuery)) return false;

        return true;
      });

      const sorted = [...filtered].sort((a, b) => {
        const pa = a.pieces.filter(id => ownedIds.has(id)).length / a.full;
        const pb = b.pieces.filter(id => ownedIds.has(id)).length / b.full;
        return pb - pa || (b.authorityValue || 0) - (a.authorityValue || 0);
      });

      const rows = sorted.map(s => {
        const owned = s.pieces.filter(id => ownedIds.has(id)).length;
        const total = s.full;
        const done = owned >= total;

        const highlightedName = searchQuery
          ? s.name.replace(new RegExp(`(${searchQuery.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi'),
            `<span style="background:#f59e0b; color:#000; padding:0 2px; border-radius:2px; font-weight:600;">$1</span>`)
          : s.name;

        return `
        <tr style="border-bottom:1px solid #334155; ${done ? 'background:rgba(34,197,94,0.15);' : ''}">
          <td style="padding:8px 6px; color:#8b5cf6; font-weight:500; white-space:nowrap; width:160px;">
            <div style="overflow:hidden; text-overflow:ellipsis;" title="${s.name}">${highlightedName}</div>
          </td>
          <td style="padding:8px 6px; text-align:center; color:${done ? '#34d399' : '#fbbf24'}; font-weight:700; width:80px;">${owned}/${total}</td>
          <td style="padding:8px 6px; text-align:center; color:#fbbf24; font-size:11px; line-height:1.3; width:150px; word-wrap:break-word;">${s.setDescription || '—'}</td>
          <td style="padding:8px 6px; text-align:center; color:#94a3b8; font-size:11px; line-height:1.3; width:130px; word-wrap:break-word;">${s.source || '—'}</td>
        </tr>
      `;
      }).join('');

      const infoText = searchQuery
        ? `Найдено: ${sorted.length}`
        : `Показано: ${sorted.length} из ${sets.length} | В инвентаре: ${ownedIds.size}`;

      tableWrap.innerHTML = `
      <div style="margin-bottom:8px; color:#94a3b8; font-size:12px; text-align:center;">${infoText}</div>
      <table style="width:100%; border-collapse:collapse; font-size:13px; table-layout:fixed;">
        <thead>
          <tr style="background:#1e293b; position:sticky; top:0;">
            <th style="text-align:left; padding:8px 6px; width:160px;">Сет</th>
            <th style="text-align:center; padding:8px 6px; width:80px;">Собрано</th>
            <th style="text-align:center; padding:8px 6px; width:150px;">Бонус</th>
            <th style="text-align:center; padding:8px 6px; width:130px;">Источник</th>
          </tr>
        </thead>
        <tbody>${rows}</tbody>
      </table>
    `;
    }

    // === DRAG & RESIZE ===
    let isDragging = false;
    let isResizing = false;
    let startX, startY, startLeft, startTop, startW, startH;

    const startDrag = (e) => {
      if (e.target.tagName === 'BUTTON') return;
      isDragging = true;
      const rect = panel.getBoundingClientRect();
      startX = e.clientX - rect.left;
      startY = e.clientY - rect.top;
      document.body.style.userSelect = 'none';
      panel.style.cursor = 'grabbing';
    };

    const startResize = (e) => {
      e.stopPropagation();
      isResizing = true;
      startX = e.clientX;
      startY = e.clientY;
      startW = panel.offsetWidth;
      startH = panel.offsetHeight;
      document.body.style.userSelect = 'none';
    };

    const handleMove = (e) => {
      if (isDragging) {
        const x = e.clientX - startX;
        const y = e.clientY - startY;
        panel.style.left = Math.max(0, Math.min(x, window.innerWidth - panel.offsetWidth)) + 'px';
        panel.style.top = Math.max(0, Math.min(y, window.innerHeight - panel.offsetHeight)) + 'px';
      } else if (isResizing) {
        const dw = e.clientX - startX;
        const dh = e.clientY - startY;
        panel.style.width = `${Math.max(620, startW + dw)}px`;
        panel.style.height = `${Math.max(400, startH + dh)}px`;
      }
    };

    const handleUp = () => {
      if (isDragging || isResizing) {
        isDragging = isResizing = false;
        document.body.style.userSelect = '';
        panel.style.cursor = 'default';
      }
    };

    header.addEventListener('mousedown', startDrag);
    document.addEventListener('mousemove', handleMove);
    document.addEventListener('mouseup', handleUp);

    const resizeHandle = document.createElement('div');
    resizeHandle.style.cssText = `position:absolute;right:0;bottom:0;width:16px;height:16px;cursor:se-resize;background:transparent;`;
    resizeHandle.innerHTML = `<svg width="12" height="12" viewBox="0 0 12 12" fill="none" style="position:absolute;right:4px;bottom:4px;">
    <path d="M12 0L0 12M12 4L8 8M12 8L4 12" stroke="#64748b" stroke-width="1.5"/>
  </svg>`;
    resizeHandle.addEventListener('mousedown', startResize);
    panel.appendChild(resizeHandle);

    const minimizeBtn = header.querySelector('#minimize-clothing');
    const closeBtn = header.querySelector('#close-clothing');

    minimizeBtn.onclick = (e) => {
      e.stopPropagation();
      isMinimized = !isMinimized;
      panel.style.height = isMinimized ? '40px' : '600px';
      minimizeBtn.textContent = isMinimized ? '+' : '–';
      content.style.display = isMinimized ? 'none' : 'flex';
    };

    closeBtn.onclick = (e) => {
      e.stopPropagation();
      document.removeEventListener('mousemove', handleMove);
      document.removeEventListener('mouseup', handleUp);
      header.removeEventListener('mousedown', startDrag);
      resizeHandle.removeEventListener('mousedown', startResize);
      panel.remove();
    };

    content.append(searchBar, controlsBar, tableWrap);
    panel.append(header, content, resizeHandle);
    document.body.appendChild(panel);

    updateTabButtons();
    updateClothingTable();
  }

  function createHideoutsContent() {
    const div = document.createElement('div');
    div.className = 'tab-content';
    div.id = 'hideouts-content';

    // === КНОПКА ЗАГРУЗКИ (автоматически по текущему игроку) ===
    const loadBtn = document.createElement('button');
    loadBtn.innerHTML = `
    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px;">
      <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
    </svg>
    Загрузить мои нычки
  `;
    loadBtn.className = 'load-btn hideouts-load-btn';
    loadBtn.onclick = async () => {
      const userId = getCurrentUserId(); // ← ТВОЯ ФУНКЦИЯ!
      if (!userId) {
        showError('Ошибка', 'Не авторизован или ID не найден');
        return;
      }

      loadBtn.disabled = true;
      loadBtn.innerHTML = `
      <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px; animation: spin 1s linear infinite;">
        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4" fill="none" opacity="0.3"/>
        <path d="M4 12a8 8 0 018-8v8z"/>
      </svg>
      Загружаем...
    `;

      await fetchPlayerCollections(userId);

      loadBtn.disabled = false;
      loadBtn.innerHTML = `
      <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px;">
        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
      </svg>
      Обновить нычки
    `;
    };
    div.appendChild(loadBtn);

    // === КОНТЕЙНЕР ДЛЯ СПИСКОВ ТЮРЕМ ===
    const prisonsContainer = document.createElement('div');
    prisonsContainer.id = 'prisons-container';
    prisonsContainer.className = 'prisons-container';
    prisonsContainer.style.display = 'none';
    div.appendChild(prisonsContainer);

    // === СТАТУС ===
    const status = document.createElement('div');
    status.id = 'hideouts-status';
    status.className = 'hideouts-status';
    status.textContent = 'Нажмите кнопку, чтобы загрузить ваши нычки';
    div.appendChild(status);

    return div;
  }

  /** Collections **/
  async function fetchPlayerCollections(userId) {
    const token = getAuthToken();
    if (!token) return showError('Ошибка', 'Токен не найден');

    try {
      updateStatus('Загружаем нычки...');
      const res = await fetch(`https://oldprison-prod.luckygem.online/api/collection/player/full?userId=${userId}`, {
        headers: { 'authorization': token, 'accept': 'application/json' }
      });

      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const data = await res.json();

      playerCollections = data;
      currentPrisonData = data;

      // === ПОДСЧЁТ НЫЧЕК ===
      totalFoundHideouts = calculateTotalFoundHideouts(data.playerProgress);
      updateTotalHideoutsCounter();

      // ВЫЗЫВАЕМ РЕНДЕР!
      renderPrisonsList(data);

      updateStatus(`Загружено: ${data.collections?.length || 0} коллекций • Найдено: ${totalFoundHideouts} нычек`);
      return data;
    } catch (e) {
      showError('Ошибка нычек', e.message);
      updateStatus('Ошибка загрузки');
      return null;
    }
  }


  function calculateCollectionProgress(collection) {
    const items = Array.isArray(collection.items) ? collection.items : [];
    const total = items.length;
    const collected = items.filter(item => item.collected === true).length;
    const percent = total > 0 ? Math.round((collected / total) * 100) : 0;
    return { collected, total, percent };
  }

  // Функция сбора данных
  function collectSellableData(playerProgress, collectionsData, prisonId = null) {
    const progressData = playerProgress?.data || {};
    const result = [];

    collectionsData.forEach(prisonData => {
      const currentPrisonId = prisonData.prisonid;

      if (prisonId && currentPrisonId !== prisonId) return;

      const prisonCollections = prisonData.collections || [];

      prisonCollections.forEach(collection => {
        const collectionId = collection.id;
        const progress = progressData[currentPrisonId]?.[collectionId] || {};
        const itemsProgress = progress.items || {};
        const collectionItems = collection.items || [];

        console.log(`Проверка коллекции ${collectionId}:`, {
          name: collection.name,
          itemsProgress: itemsProgress
        });

        // Проверяем что для КАЖДОГО предмета коллекции есть хотя бы 1
        const hasAllItems = collectionItems.every(item =>
          itemsProgress[item.id] >= 1
        );

        if (hasAllItems && collectionItems.length > 0) {
          result.push({
            prisonId: currentPrisonId,
            collectionId: collectionId,
            collectionName: collection.name
          });

          console.log(`✅ Коллекция "${collection.name}" готова к продаже`);
        } else {
          console.log(`❌ Коллекция "${collection.name}" не готова`);
        }
      });
    });

    console.log('Итоговые данные для продажи:', result);
    return result;
  }

  // Функция продажи
  async function sellPrisonHideouts(prisonId, event) {
    console.log('sellPrisonHideouts: КЛИК!', prisonId);

    const btn = event.target.closest('.sell-prison-btn');
    if (!btn) return;

    const token = getAuthToken();
    if (!token) {
      showError('Ошибка', 'Токен не найден');
      return;
    }

    const userId = getCurrentUserId();
    if (!userId) {
      showError('Ошибка', 'User ID не найден');
      return;
    }

    btn.disabled = true;
    btn.innerHTML = `
    <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor" style="animation: spin 1s linear infinite;">
      <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4" fill="none" opacity="0.3"/>
      <path d="M4 12a8 8 0 018-8v8z"/>
    </svg>
  `;

    try {
      const sellable = collectSellableData(
        playerCollections.playerProgress,
        playerCollections.collections,
        prisonId
      );

      console.log(`Найдено собранных коллекций в тюрьме ${prisonId}:`, sellable.length);

      if (sellable.length === 0) {
        showError('Пусто', 'Нет собранных коллекций для продажи в этой тюрьме');
        return;
      }

      const results = [];
      let totalCigs = 0;
      let totalAuth = 0;
      let successfulSales = 0;

      for (const [index, collectionData] of sellable.entries()) {
        console.log(`\n=== Продаём коллекцию ${index + 1}/${sellable.length} ===`);
        console.log('Название:', collectionData.collectionName);
        console.log('Данные:', collectionData);

        btn.innerHTML = `
            <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor" style="animation: spin 1s linear infinite;">
              <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4" fill="none" opacity="0.3"/>
              <path d="M4 12a8 8 0 018-8v8z"/>
            </svg>
            ${index + 1}/${sellable.length}
          `;

        const payload = {
          userId: userId,
          prisonId: collectionData.prisonId,
          collectionId: collectionData.collectionId
        };

        console.log('Отправляемый запрос:', JSON.stringify(payload, null, 2));

        const res = await fetch('https://oldprison-prod.luckygem.online/api/collection/player/vparit', {
          method: 'POST',
          headers: {
            'authorization': token,
            'content-type': 'application/json',
            'accept': 'application/json'
          },
          body: JSON.stringify(payload)
        });

        if (!res.ok) {
          const errorText = await res.text();
          console.warn(`❌ Ошибка продажи коллекции ${collectionData.collectionId}:`, errorText);

          try {
            const err = JSON.parse(errorText);
            console.warn('Детали ошибки:', err);
          } catch (e) {
            console.warn('Текст ошибки:', errorText);
          }
          continue;
        }

        const data = await res.json();
        console.log(`✅ Успешно продана коллекция ${collectionData.collectionId}:`, data);

        results.push(data);
        successfulSales++;
        totalCigs += data.collection?.currencies?.cigarettes || 0;
        totalAuth += data.collection?.authority || 0;

        await new Promise(resolve => setTimeout(resolve, 500));
      }

      // Обновляем данные после всех продаж
      await fetchPlayerCollections(getCurrentUserId());

      if (successfulSales > 0) {
        showSuccess('Продано!', `Продано ${successfulSales} коллекций • +${totalCigs} сиг • +${totalAuth}A`);
      } else {
        showError('Ошибка', `Не удалось продать ни одной коллекции из ${sellable.length}`);
      }

    } catch (e) {
      console.error('Критическая ошибка:', e);
      showError('Фатал', e.message);
    } finally {
      btn.disabled = false;
      btn.innerHTML = `
        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
          <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z"/>
        </svg>
        Впарить
      `;
    }
  }

  async function sellAllHideouts() {
    const btn = document.querySelector('.sell-all-btn');
    if (!btn) return;

    const token = getAuthToken();
    if (!token) {
      showError('Ошибка', 'Токен не найден');
      return;
    }

    const userId = getCurrentUserId();
    if (!userId) {
      showError('Ошибка', 'User ID не найден');
      return;
    }

    btn.disabled = true;
    btn.innerHTML = `
    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 6px; animation: spin 1s linear infinite;">
      <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4" fill="none" opacity="0.3"/>
      <path d="M4 12a8 8 0 018-8v8z"/>
    </svg>
    Продаём всё...
  `;

    try {
      const sellable = collectSellableData(
        playerCollections.playerProgress,
        playerCollections.collections
      );

      if (sellable.length === 0) {
        showError('Нечего продавать', 'Нет собранных коллекций');
        return;
      }

      console.log(`Найдено собранных коллекций для продажи: ${sellable.length}`);

      const results = [];
      let totalCigs = 0;
      let totalAuth = 0;
      let successfulSales = 0;

      for (const [index, collectionData] of sellable.entries()) {
        console.log(`Продаём коллекцию ${index + 1}/${sellable.length}: ${collectionData.collectionName}`);

        btn.innerHTML = `
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 6px; animation: spin 1s linear infinite;">
              <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4" fill="none" opacity="0.3"/>
              <path d="M4 12a8 8 0 018-8v8z"/>
            </svg>
            ${index + 1}/${sellable.length}
          `;

        const payload = {
          userId: userId,
          prisonId: collectionData.prisonId,
          collectionId: collectionData.collectionId
        };

        console.log('Отправляемый запрос:', JSON.stringify(payload, null, 2));

        const res = await fetch('https://oldprison-prod.luckygem.online/api/collection/player/vparit', {
          method: 'POST',
          headers: {
            'authorization': token,
            'content-type': 'application/json',
            'accept': 'application/json'
          },
          body: JSON.stringify(payload)
        });

        if (!res.ok) {
          const errorText = await res.text();
          console.warn(`Ошибка продажи коллекции ${collectionData.collectionId}:`, errorText);
          continue;
        }

        const data = await res.json();
        console.log(`Успешно продана коллекция ${collectionData.collectionId}:`, data);

        results.push(data);
        successfulSales++;
        totalCigs += data.collection?.currencies?.cigarettes || 0;
        totalAuth += data.collection?.authority || 0;

        await new Promise(resolve => setTimeout(resolve, 500));
      }

      // Обновляем данные после всех продаж
      await fetchPlayerCollections(getCurrentUserId());

      if (successfulSales > 0) {
        showSuccess('Всё продано!', `Продано ${successfulSales} коллекций • +${totalCigs} сиг • +${totalAuth}A`);
      } else {
        showError('Ошибка', `Не удалось продать ни одной коллекции из ${sellable.length}`);
      }

    } catch (e) {
      console.error('Ошибка:', e);
      showError('Фатал', e.message);
    } finally {
      btn.disabled = false;
      btn.innerHTML = `
        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 6px;">
          <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
        </svg>
        Впарить все нычки
      `;
    }
  }

  function renderPrisonsList(data) {
    const container = document.getElementById('prisons-container');
    if (!container || !Array.isArray(data?.collections)) return;

    const playerProgress = data.playerProgress?.data || {};
    container.innerHTML = '';

    // КНОПКА "ВПАРИТЬ ВСЁ"
    const sellAllBtn = document.createElement('button');
    sellAllBtn.className = 'sell-all-btn';
    sellAllBtn.innerHTML = `
    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 6px;">
      <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
    </svg>
    Впарить все нычки
  `;
    sellAllBtn.addEventListener('click', sellAllHideouts);
    container.appendChild(sellAllBtn);

    data.collections.forEach(prisonData => {
      const prisonId = prisonData.prisonid;
      const prison = prisonData.prison || 'Неизвестная тюрьма';
      const collections = Array.isArray(prisonData.collections) ? prisonData.collections : [];

      const prisonBlock = document.createElement('div');
      prisonBlock.className = 'prison-block';

      const prisonHeader = document.createElement('div');
      prisonHeader.className = 'prison-header';

      // Название
      const titleDiv = document.createElement('div');
      titleDiv.className = 'prison-title';
      titleDiv.innerHTML = `
      <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
        <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z"/>
      </svg>
      ${prison}
    `;
      prisonHeader.appendChild(titleDiv);

      // Правая часть
      const rightDiv = document.createElement('div');
      rightDiv.className = 'prison-header-right';

      const countSpan = document.createElement('span');
      countSpan.className = 'prison-collections-count';
      countSpan.textContent = collections.length;
      rightDiv.appendChild(countSpan);

      // КНОПКА "ВПАРИТЬ"
      const sellBtn = document.createElement('button');
      sellBtn.className = 'sell-prison-btn';
      sellBtn.innerHTML = `
      <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
        <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z"/>
      </svg>
      Впарить
    `;

      sellBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        sellPrisonHideouts(prisonId, e);
      });

      rightDiv.appendChild(sellBtn);
      prisonHeader.appendChild(rightDiv);
      prisonBlock.appendChild(prisonHeader);

      // КОЛЛЕКЦИИ
      collections.forEach(collection => {
        const collectionId = collection.id;
        const progress = calculateCollectionProgress(collection);
        const isComplete = progress.percent === 100;
        const mainImage = collection.mainimage || 'https://via.placeholder.com/28/333/94a3b8?text=?';

        const progressData = playerProgress[prisonId]?.[collectionId] || {};
        const completedTimes = progressData.completedTimes || 0;
        const itemsFound = progressData.items || {};

        const row = document.createElement('div');
        row.className = `collection-row ${isComplete ? 'complete' : ''}`;

        row.innerHTML = `
        <div class="collection-main-with-count">
          <img src="${mainImage}" alt="${collection.name}" class="collection-image ${isComplete ? 'complete' : ''}" loading="lazy">
          ${completedTimes > 0 ? `<span class="collection-completed-count">${completedTimes}</span>` : ''}
        </div>
        <div class="collection-progress-compact">
          <span>${progress.collected}/${progress.total}</span>
          <div class="progress-bar-compact">
            <div class="progress-fill-compact" style="width: ${progress.percent}%"></div>
          </div>
        </div>
        <div class="collection-rewards-compact">${renderRewardsCompact(collection.rewards)}</div>
        <div class="collection-items-compact">
          ${Array.isArray(collection.items) ? collection.items.map(item => {
          const foundCount = itemsFound[item.id] || 0;
          return `<div class="item-with-count">
              <img src="${item.image}" alt="Item ${item.id}" loading="lazy">
              ${foundCount > 0 ? `<span class="item-count">${foundCount}</span>` : ''}
            </div>`;
        }).join('') : ''}
        </div>
      `;

        prisonBlock.appendChild(row);
      });

      container.appendChild(prisonBlock);
    });

    container.style.display = 'block';
    const totalCollections = data.collections.reduce((a, p) => a + (p.collections?.length || 0), 0);
    document.getElementById('hideouts-status').textContent = `Готово: ${data.collections.length} тюрем • ${totalCollections} коллекций`;
  }

  function updateTotalHideoutsCounter() {
    let counter = document.getElementById('total-hideouts-counter');
    if (!counter) {
      counter = document.createElement('div');
      counter.id = 'total-hideouts-counter';
      counter.className = 'total-hideouts-counter';
      document.getElementById('hideouts-content').insertBefore(counter, document.getElementById('prisons-container'));
    }
    counter.innerHTML = `
    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 6px;">
      <path d="M12 2L2 7v10c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V7l-10-5zm-1.5 15.5l-4-4 1.41-1.41L11 15.17l5.59-5.59L18 11l-7.5 7.5z"/>
    </svg>
    Всего найдено: <strong>${totalFoundHideouts}</strong> нычек
  `;
  }

  function calculateTotalFoundHideouts(playerProgress) {
    if (!playerProgress?.data) return 0;

    let total = 0;
    const data = playerProgress.data;

    for (const prisonId in data) {
      for (const collectionId in data[prisonId]) {
        const collection = data[prisonId][collectionId];
        const items = collection.items || {};

        for (const itemId in items) {
          total += items[itemId];
        }
      }
    }

    return total;
  }

  function renderRewardsCompact(rewards) {
    if (!rewards) return '';
    const parts = [];
    if (rewards.authority) parts.push(`<span class="reward-compact authority">+${rewards.authority}A</span>`);
    if (rewards.cigarettes) parts.push(`<span class="reward-compact cigarettes">${rewards.cigarettes}сиг</span>`);
    if (rewards.rubles) parts.push(`<span class="reward-compact rubles">${rewards.rubles}₽</span>`);
    if (rewards.paper) parts.push(`<span class="reward-compact paper">${rewards.paper}Б</span>`);
    return parts.join('');
  }


  async function api(url, options = {}) {
    const token = getAuthToken();
    if (!token) throw new Error('Нет токена — перезайдите в игру');

    const defaultHeaders = {
      'Authorization': token,
      'Content-Type': 'application/json',
      'Accept': 'application/json',
    };

    if (options.body instanceof FormData) {
      delete defaultHeaders['Content-Type'];
    }

    const response = await fetch(url, {
      ...options,
      method: options.method || 'GET',
      headers: { ...defaultHeaders, ...(options.headers || {}) },
      credentials: 'include',
      cache: 'no-store'
    });

    if (!response.ok && response.status !== 401 && response.status !== 403) {
      console.warn(`API ошибка ${response.status}: ${url}`);
    }

    const text = await response.text();
    try {
      return JSON.parse(text);
    } catch {
      return { success: true, raw: text };
    }
  }

  // === ПОПОЛНЕНИЯ ЭНЕРГИИ ===
  async function useChefir() {
    try {
      console.log('Пробую использовать чифир...');
      const data = await api(
        "https://oldprison-prod.luckygem.online/api/player/energy/use-chefir",
        { method: 'POST', body: JSON.stringify({}) }
      );

      if (data.success !== false && !data.error) {
        console.log('Чифир использован');
        window.chifirFailed = false; // Сброс
        return true;
      } else {
        console.log('Чифир не сработал:', data.error || data);
        if (data.status === 400 || (data.error && data.error.includes('не хватает'))) {
          window.chifirFailed = true;
        }
        return false;
      }
    } catch (error) {
      if (error.message.includes('400')) {
        window.chifirFailed = true;
        console.warn('400 при чифире → считаем, что закончился');
      }
      console.error('Ошибка при использовании чифира:', error);
      return false;
    }
  }

  async function useSoap() {
    try {
      console.log('Пробую использовать мыло...');
      const data = await api(
        "https://oldprison-prod.luckygem.online/api/player/energy/use-soap",
        { method: 'POST', body: JSON.stringify({}) }
      );

      if (data.success !== false && !data.error) {
        console.log('Мыло использовано');
        window.soapFailed = false;
        return true;
      } else {
        console.log('Мыло не сработало:', data.error || data);
        if (data.status === 400 || (data.error && data.error.includes('не хватает'))) {
          window.soapFailed = true;
        }
        return false;
      }
    } catch (error) {
      if (error.message.includes('400')) {
        window.soapFailed = true;
        console.warn('400 при мыле → считаем, что закончилось');
      }
      console.error('Ошибка при использовании мыла:', error);
      return false;
    }
  }

  async function restoreEnergy(restoreMethod) {
    console.log(`Восстановление энергии: ${restoreMethod}`);

    const method = getRestoreMethod(); // 'chefir', 'soap', 'both'

    // === Если выбран "Не восстанавливать" ===
    if (method === 'none') {
      showModal({
        title: 'Энергия закончилась',
        content: `<div class="text-error">Энергия закончилась. Восстановление отключено.</div>`,
        buttons: [{ label: 'Закрыть', action: () => {} }]
      });
      updateWorkerStatus('Энергия закончилась. Остановлено.', 'error');
      workerStopRequested = true;
      return false;
    }

    // Определяем, что пытаемся использовать
    const tryingChefir = method === 'chefir' || method === 'both';
    const tryingSoap = method === 'soap' || method === 'both';

    let success = false;

    // === Попытка восстановления ===
    if (tryingChefir && !window.chifirFailed) {
      success = await useChefir();
    }
    if (!success && tryingSoap && !window.soapFailed) {
      success = await useSoap();
    }

    // === Проверка после попытки ===
    const chifirDepleted = tryingChefir && window.chifirFailed;
    const soapDepleted = tryingSoap && window.soapFailed;

    if (chifirDepleted || soapDepleted) {
      let message = '';

      if (chifirDepleted && soapDepleted) {
        message = 'У вас закончился чифир и мыло';
      } else if (chifirDepleted) {
        message = 'У вас закончился чифир';
      } else if (soapDepleted) {
        message = 'У вас закончилось мыло';
      }

      showModal({
        title: 'Нет энергии',
        content: `<div class="text-error">${message}</div>`,
        buttons: [{ label: 'Закрыть', action: () => {} }]
      });

      updateWorkerStatus(message, 'error');
      workerStopRequested = true;
      return false;
    }

    return success;
  }

  function startTimer(duration, message) {
    return new Promise((resolve) => {
      let timeLeft = duration;

      const timerInterval = setInterval(() => {
        if (workerStopRequested) {
          clearInterval(timerInterval);
          console.log('⏹️ Таймер остановлен пользователем');
          resolve();
          return;
        }

        const minutes = Math.floor(timeLeft / 60);
        const seconds = timeLeft % 60;

        console.clear();
        console.log(`⏰ ${message}`);
        console.log(`🕒 Осталось времени: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`);

        if (timeLeft <= 0) {
          clearInterval(timerInterval);
          console.log('✅ Пауза завершена, продолжаем работу...');
          resolve();
        }

        timeLeft--;
      }, 1000);
    });
  }

  function getRestoreMethod() {
    const selected = document.querySelector('input[name="restoreMethod"]:checked');
    return selected ? selected.value : 'chefir';
  }

  async function doZonesWork(zoneIds, isDay, times, delay, pauseAfterRequests, pauseDuration, restoreMethod) {
    console.log(`Запуск: ${zoneIds.join(', ')}, ${times} раз, задержка: ~${delay}мс (+рандом)`);

    let totalCompleted = 0;
    let totalErrors = 0;
    window.chifirFailed = false;
    window.soapFailed = false;

    for (let i = 0; i < times; i++) {
      if (workerStopRequested) break;

      // Пауза каждые N запросов
      if (pauseAfterRequests > 0 && i > 0 && i % pauseAfterRequests === 0) {
        console.log(`Пауза ${pauseDuration / 60} мин после ${i} запросов`);
        await startTimer(pauseDuration, `Пауза ${pauseDuration / 60} мин`);
        if (workerStopRequested) break;
      }

      // Обрабатываем по 1 зоне за итерацию (чтобы не спамить)
      for (const zoneId of zoneIds) {
        if (workerStopRequested) break;

        try {
          console.log(`Зона ${zoneId}, попытка ${i + 1}/${times}`);

          const data = await api(
            `https://oldprison-prod.luckygem.online/api/player/prison/${zoneId}/work?isDay=${isDay}`,
            { method: 'POST', body: JSON.stringify({}) }
          );

          if (data.error === "Не хватает энергии") {
            const restored = await restoreEnergy(restoreMethod);
            if (restored) {
              const retry = await api(
                `https://oldprison-prod.luckygem.online/api/player/prison/${zoneId}/work?isDay=${isDay}`,
                { method: 'POST', body: JSON.stringify({}) }
              );
              if (retry.success !== false) totalCompleted++;
              else totalErrors++;
            } else totalErrors++;
          } else if (data.success === false) {
            totalErrors++;
          } else {
            totalCompleted++;
          }

          updateWorkerStatus(`Выполнено: ${totalCompleted}/${times * zoneIds.length}`, 'running');

        } catch (err) {
          if (err.message.includes('429')) {
            console.warn('429 — жду 15 секунд...');
            await new Promise(r => setTimeout(r, 15000));
            i--;
            continue;
          }

          totalErrors++;
          console.error(`Ошибка в зоне ${zoneId}:`, err.message);

          if (err.message.includes('403') || err.message.includes('401')) {
            updateWorkerStatus('Ошибка авторизации!', 'error');
            workerStopRequested = true;
            break;
          }
        }

        // РАНДОМНАЯ ЗАДЕРЖКА
        if (delay > 0 && !workerStopRequested) {
          const randomDelay = delay + Math.floor(Math.random() * 600);
          await new Promise(r => setTimeout(r, randomDelay));
        }
      }
    }

    isWorkerRunning = false;
    updateWorkerStatus(`Завершено! Успех: ${totalCompleted}, Ошибок: ${totalErrors}`, 'success');
  }

  async function doMastersWork(times, masterIds, delay, failsBeforeSoap, pauseAfterRequests, pauseDuration, restoreMethod) {
    console.log(`🛠️ Запуск работы с мастерами: ${masterIds.join(', ')}, ${times} попыток, задержка: ${delay}мс`);
    console.log(`⚡ Метод восстановления энергии: ${restoreMethod}`);
    console.log(`⏸️ Пауза: каждые ${pauseAfterRequests} запросов на ${pauseDuration / 60} минут`);

    let totalSuccessCount = 0;
    let totalFailCount = 0;
    let masterFailCounts = {};
    window.chifirFailed = false;
    window.soapFailed = false;

    masterIds.forEach(id => {
      masterFailCounts[id] = 0;
    });

    for (let i = 0; i < times; i++) {
      if (workerStopRequested) {
        console.log('⏹️ Работа с мастерами остановлена пользователем');
        updateWorkerStatus(`⏹️ Остановлено. Выполнено: ${i}/${times}`, 'stopped');
        break;
      }

      if (pauseAfterRequests > 0 && i > 0 && i % pauseAfterRequests === 0) {
        console.log(`⏸️ Достигнуто ${pauseAfterRequests} запросов, делаю паузу ${pauseDuration / 60} минут...`);
        updateWorkerStatus(`⏸️ Пауза ${pauseDuration / 60} минут после ${pauseAfterRequests} запросов`, 'running');

        await startTimer(pauseDuration, `Пауза после ${pauseAfterRequests} запросов (${pauseDuration / 60} минут)`);

        if (workerStopRequested) break;
        console.log('🔄 Продолжаем работу после паузы...');
        updateWorkerStatus('🔄 Продолжаем работу...', 'running');
      }

      for (const masterId of masterIds) {
        if (workerStopRequested) break;

        try {
          const randomDelay = Math.floor(Math.random() * 200) + delay;
          await new Promise(r => setTimeout(r, randomDelay));

          console.log(`🔄 Мастер ${masterId}, попытка ${i + 1}/${times}`);

          const data = await api(
            `https://oldprison-prod.luckygem.online/api/player/masters/${masterId}/work`,
            {
              method: 'POST',
              body: JSON.stringify({})
            }
          );

          console.log(`📊 Мастер ${masterId}:`, data);

          if (data.success === false) {
            console.log(`❌ Мастер ${masterId}: неудача`);
            totalFailCount++;
            masterFailCounts[masterId]++;

            if (masterFailCounts[masterId] >= failsBeforeSoap) {
              console.warn(`🔄 ${failsBeforeSoap} неудач у мастера ${masterId}, восстанавливаю энергию...`);

              const energyRestored = await restoreEnergy(restoreMethod);
              if (energyRestored) {
                console.log('✅ Энергия восстановлена, сбрасываю счетчик неудач');
                masterFailCounts[masterId] = 0;
              }
            }
          } else if (data.error === "Не хватает энергии") {
            console.warn(`⚡ Нет энергии у мастера ${masterId}, восстанавливаю энергию...`);

            const energyRestored = await restoreEnergy(restoreMethod);
            if (energyRestored) {
              console.log('✅ Энергия восстановлена, повторяю запрос...');
              await new Promise(r => setTimeout(r, 500));

              const retryData = await api(
                `https://oldprison-prod.luckygem.online/api/player/masters/${masterId}/work`,
                {
                  method: 'POST',
                  body: JSON.stringify({})
                }
              );

              if (retryData.success !== false && !retryData.error) {
                totalSuccessCount++;
                console.log(`✅ Мастер ${masterId} после восстановления энергии: успех`);
              } else {
                totalFailCount++;
              }
            } else {
              totalFailCount++;
            }
          } else if (data.error) {
            console.error(`❌ Ошибка у мастера ${masterId}:`, data.error);
            totalFailCount++;
          } else {
            totalSuccessCount++;
            masterFailCounts[masterId] = 0;
            console.log(`✅ Мастер ${masterId}: успех`);
          }

        } catch (err) {
          totalFailCount++;
          console.error(`❌ Ошибка сети у мастера ${masterId}:`, err.message);

          if (err.message.includes('403') || err.message.includes('401')) {
            updateWorkerStatus('❌ Критическая ошибка авторизации!', 'error');
            workerStopRequested = true;
            break;
          }

          await new Promise(r => setTimeout(r, 1000));
        }

        if ((i + 1) % 10 === 0) {
          console.log(`📈 Прогресс: ${i + 1}/${times} | Успехов: ${totalSuccessCount} | Неудач: ${totalFailCount}`);
          updateWorkerStatus(`🛠️ Мастера: ${i + 1}/${times} | Успехов: ${totalSuccessCount}`, 'running');
        }
      }
    }

    isWorkerRunning = false;
    if (!workerStopRequested) {
      console.log(`🎉 Работа с мастерами завершена! Успехов: ${totalSuccessCount}, Неудач: ${totalFailCount}`);
      updateWorkerStatus(`🎉 Мастера завершены! Успехов: ${totalSuccessCount}, Неудач: ${totalFailCount}`, 'success');
    }
  }

  // ========== ОБРАБОТЧИКИ РАБОТЫ ==========
  function startWorkerHandler() {
    if (isWorkerRunning) return;

    window.chifirFailed = false;
    window.soapFailed = false;

    // Мастера имеют приоритет
    const selectedMasters = Array.from(document.querySelectorAll('.master-checkbox:checked'))
      .map(c => +c.value).filter(Boolean);
    if (selectedMasters.length) { startMastersWork(); return; }

    // Иначе – активный таб
    const activeBtn = document.querySelector('.worker-tabs .tab-btn.active');
    if (!activeBtn) return;

    const tab = activeBtn.dataset.tab;
    if (tab === 'zones') startZonesWork();
    else if (tab === 'masters') startMastersWork();
  }

  function startZonesWork() {
    const selectedZones = Array.from(document.querySelectorAll('.zone-checkbox:checked'))
      .map(checkbox => parseInt(checkbox.value))
      .filter(id => !isNaN(id));

    if (selectedZones.length === 0) {
      updateWorkerStatus('❌ Выберите хотя бы одну зону', 'error');
      return;
    }

    const requestsCount = parseInt(document.getElementById('requestsCount').value);
    const delay = parseInt(document.getElementById('delayInput').value);
    const isDay = document.getElementById('modeSelect').value === 'true';
    const pauseAfterRequests = parseInt(document.getElementById('pauseAfterRequests').value);
    const pauseDuration = parseInt(document.getElementById('pauseDuration').value) * 60;
    const restoreMethod = getRestoreMethod();

    if (requestsCount <= 0) {
      updateWorkerStatus('❌ Количество запросов должно быть больше 0', 'error');
      return;
    }

    isWorkerRunning = true;
    workerStopRequested = false;
    document.getElementById('workerStart').disabled = true;
    document.getElementById('workerStop').disabled = false;
    updateWorkerStatus('🔄 Запуск работы по зонам...', 'running');

    doZonesWork(selectedZones, isDay, requestsCount, delay, pauseAfterRequests, pauseDuration, restoreMethod).then(() => {
      isWorkerRunning = false;
      document.getElementById('workerStart').disabled = false;
      document.getElementById('workerStop').disabled = true;
    }).catch(error => {
      console.error('Ошибка работы:', error);
      updateWorkerStatus('❌ Ошибка работы', 'error');
      isWorkerRunning = false;
      document.getElementById('workerStart').disabled = false;
      document.getElementById('workerStop').disabled = true;
    });
  }

  function startMastersWork() {
    const selectedMasters = Array.from(document.querySelectorAll('.master-checkbox:checked'))
      .map(checkbox => parseInt(checkbox.value))
      .filter(id => !isNaN(id));

    if (selectedMasters.length === 0) {
      updateWorkerStatus('❌ Выберите хотя бы одного мастера', 'error');
      return;
    }

    const requestsCount = parseInt(document.getElementById('mastersRequestsCount').value);
    const delay = parseInt(document.getElementById('mastersDelayInput').value);
    const failsBeforeSoap = parseInt(document.getElementById('failsBeforeSoap').value);
    const pauseAfterRequests = parseInt(document.getElementById('pauseAfterRequests').value);
    const pauseDuration = parseInt(document.getElementById('pauseDuration').value) * 60;
    const restoreMethod = getRestoreMethod();

    if (requestsCount <= 0) {
      updateWorkerStatus('❌ Количество попыток должно быть больше 0', 'error');
      return;
    }

    isWorkerRunning = true;
    workerStopRequested = false;
    document.getElementById('workerStart').disabled = true;
    document.getElementById('workerStop').disabled = false;
    updateWorkerStatus('🔄 Запуск работы с мастерами...', 'running');

    doMastersWork(requestsCount, selectedMasters, delay, failsBeforeSoap, pauseAfterRequests, pauseDuration, restoreMethod).then(() => {
      isWorkerRunning = false;
      document.getElementById('workerStart').disabled = false;
      document.getElementById('workerStop').disabled = true;
    }).catch(error => {
      console.error('Ошибка работы с мастерами:', error);
      updateWorkerStatus('❌ Ошибка работы с мастерами', 'error');
      isWorkerRunning = false;
      document.getElementById('workerStart').disabled = false;
      document.getElementById('workerStop').disabled = true;
    });
  }

  function stopWorkerHandler() {
    if (isWorkerRunning) {
      workerStopRequested = true;
      document.getElementById('workerStop').disabled = true;
      updateWorkerStatus('⏹️ Останавливаю работу...', 'error');
    }
  }

    /** Clear Friends **/
    async function openFriendsModal() {
      document.getElementById('friends-modal')?.remove();

      // 1. ПРОВЕРКА КЭША (5 минут)
      if (friendsCache && Date.now() - friendsCache.timestamp < 300000) {
        const modal = document.createElement('div');
        modal.id = 'friends-modal';
        modal.className = 'prison-interface';
        modal.style.cssText = `
      position: fixed !important;
      width: 94vw !important;
      height: 88vh !important;
      max-width: 1150px !important;
      max-height: 840px !important;
      z-index: ${++highestZIndex} !important;
      border-radius: 24px !important;
      overflow: hidden !important;
      background: #0f172a;
      box-shadow: 0 30px 80px rgba(0,0,0,0.8) !important;
    `;

        modal.innerHTML = `
      <div class="interface-header" style="padding:18px 24px;cursor:move;background:#1e293b;user-select:none;display:flex;justify-content:space-between;align-items:center;">
        <div class="header-title" style="display:flex;align-items:center;gap:12px;">
          <svg width="28" height="28" viewBox="0 0 24 24" fill="#8b5cf6">
            <path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.83 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/>
          </svg>
          <h3 style="margin:0;color:#e2e8f0;font-size:20px;">Друзья (<span id="fcnt">0</span>)</h3>
        </div>
        <div class="header-controls" style="display:flex;gap:8px;">
          <button class="ctrl-btn minimize" title="Свернуть" style="font-size:20px;color:#94a3b8;background:none;border:none;cursor:pointer;">−</button>
          <button class="ctrl-btn close" title="Закрыть" style="font-size:26px;color:#94a3b8;background:none;border:none;cursor:pointer;">×</button>
        </div>
      </div>

      <div id="friends-body" style="height:calc(100% - 68px);display:flex;flex-direction:column;">
        <div style="padding:16px 20px 12px;background:#1e293b;display:flex;gap:16px;flex-wrap:wrap;align-items:center;">
          <input id="fsearch" type="text" placeholder="Поиск по нику или ID..." style="flex:1;max-width:230px;min-width:200px;padding:12px 16px;border-radius:16px;background:#334155;border:1px solid #475569;color:white;font-size:15px;">
          <select id="ftalent" style="padding:11px 16px;border-radius:14px;background:#334155;color:white;border:1px solid #475569;font-size:14.5px;">
            <option value="">Все таланты</option>
            <option value="100">до 100</option>
            <option value="300">до 300</option>
            <option value="500">до 500</option>
            <option value="700">700+</option>
          </select>
          <select id="fsort" style="padding:11px 16px;border-radius:14px;background:#334155;color:white;border:1px solid #475569;font-size:14.5px;">
            <option value="desc">Таланты: по убыванию</option>
            <option value="asc">Таланты: по возрастанию</option>
          </select>
          <div style="display:flex;align-items:center;gap:12px;white-space:nowrap;">
            <span style="color:#cbd5e1;font-size:16.5px;font-weight:700;">Игроки, с тал-ми меньше:</span>
            <input id="clean-threshold" type="number" min="1" placeholder="напр. 300" style="width:150px;padding:12px 16px;border-radius:16px;background:#334155;border:1px solid #475569;color:white;font-size:15px;">
            <button id="clean-confirm" style="padding:10px 22px;background:#ef4444;color:white;border:none;border-radius:12px;font-size:14.5px;cursor:pointer;">Выбрать</button>
          </div>
        </div>

        <div style="flex:1;overflow:auto;background:#0f172a;">
          <table style="width:100%;border-collapse:collapse;font-size:14.8px;">
            <thead style="position:sticky;top:0;background:#1e293b;z-index:10;">
              <tr style="height:52px;">
                <th style="width:60px;text-align:center;color:#60a5fa;">#</th>
                <th style="text-align:left;padding-left:18px;color:#e2e8f0;">Ник</th>
                <th style="width:150px;text-align:center;color:#94a3b8;">ID</th>
                <th style="width:140px;text-align:center;color:#e2e8f0;">Таланты</th>
                <th style="width:130px;text-align:center;">Действие</th>
              </tr>
            </thead>
            <tbody id="ftbody" style="color:#e2e8f0;"></tbody>
          </table>
        </div>

        <div style="padding:14px 20px;background:#1e293b;border-top:1px solid #334155;text-align:center;color:#94a3b8;font-size:14.5px;">
          <span id="fstatus">Из кэша • ${friendsCache.friends.length} друзей</span>
        </div>
      </div>
    `;

        document.body.appendChild(modal);

        const rect = modal.getBoundingClientRect();
        modal.style.left = Math.max(20, (window.innerWidth - rect.width) / 2 + window.scrollX) + 'px';
        modal.style.top = Math.max(20, (window.innerHeight - rect.height) / 2 + window.scrollY) + 'px';
        bringToFront(modal);
        makeInterfaceDraggable(modal);

        const tbody = modal.querySelector('#ftbody');
        const count = modal.querySelector('#fcnt');
        const search = modal.querySelector('#fsearch');
        const talentFilter = modal.querySelector('#ftalent');
        const sortSelect = modal.querySelector('#fsort');
        const cleanBtn = modal.querySelector('#clean-confirm');

        let friends = friendsCache.friends;
        Object.assign(window.talentsCache, friendsCache.talents);
        count.textContent = friends.length;

        // Сворачивание
        const bodyEl = modal.querySelector('#friends-body');
        const minimizeBtn = modal.querySelector('.minimize');
        let minimized = false;
        minimizeBtn.onclick = () => {
          minimized = !minimized;
          bodyEl.style.display = minimized ? 'none' : 'flex';
          minimizeBtn.textContent = minimized ? '+' : '−';
          modal.style.height = minimized ? '68px' : '88vh';
          modal.style.maxHeight = minimized ? '68px' : '840px';
        };

        modal.querySelector('.close').onclick = () => modal.remove();

        // Удаление по кнопке
        modal.addEventListener('click', async e => {
          const btn = e.target.closest('.action-btn.danger');
          if (!btn?.dataset.id) return;

          const userId = btn.dataset.id;
          btn.disabled = true;
          btn.textContent = 'Удаляем...';

          try {
            await removeFriend(userId);
            btn.closest('tr')?.remove();
            count.textContent = Number(count.textContent) - 1;
            friends = friends.filter(f => f.id !== userId);

          } catch (err) {
            console.error('Ошибка удаления:', err);
            btn.textContent = 'Ошибка';
            setTimeout(() => {
              btn.textContent = 'Удалить';
              btn.disabled = false;
            }, 1500);
          }
        });

        // Рендер
        function render() {
          const q = search.value.trim().toLowerCase();
          const filter = talentFilter.value;
          let list = friends.filter(f => {
            if (q && !f.nick.toLowerCase().includes(q) && !f.id.includes(q)) return false;
            const t = window.talentsCache[f.id] ?? 0;
            if (filter === '700') return t >= 700;
            if (filter === '500') return t <= 500;
            if (filter === '300') return t <= 300;
            if (filter === '100') return t <= 100;
            return true;
          });
          list.sort((a, b) => (sortSelect.value === 'desc'
              ? (window.talentsCache[b.id] ?? 0) - (window.talentsCache[a.id] ?? 0)
              : (window.talentsCache[a.id] ?? 0) - (window.talentsCache[b.id] ?? 0)
          ));
          tbody.innerHTML = list.length === 0
            ? `<tr><td colspan="5" style="text-align:center;padding:120px;color:#64748b;">Ничего не найдено</td></tr>`
            : list.map((f, i) => {
              const t = window.talentsCache[f.id] ?? 0;
              const col = t >= 700 ? '#f59e0b' : t >= 400 ? '#8b5cf6' : t >= 200 ? '#60a5fa' : '#94a3b8';
              return `<tr style="height:58px;">
              <td style="text-align:center;color:#60a5fa;font-weight:600;">${i + 1}</td>
              <td style="padding-left:18px;overflow:hidden;text-overflow:ellipsis;max-width:260px;white-space:nowrap;">${f.nick}</td>
              <td style="text-align:center;font-family:monospace;color:#94a3b8;">${f.id}</td>
              <td style="text-align:center;color:${col};font-weight:700;">${t.toLocaleString()}</td>
              <td style="text-align:center;">
                <button class="action-btn danger small" data-id="${f.id}" style="padding:8px 14px;font-size:13px;">Удалить</button>
              </td>
            </tr>`;
            }).join('');
        }

        search.oninput = talentFilter.onchange = sortSelect.onchange = render;
        render();

        // Массовая чистка
        const cleanInput = modal.querySelector('#clean-threshold');
        cleanBtn.onclick = async () => {
          const threshold = parseInt(cleanInput.value, 10);
          if (isNaN(threshold) || threshold <= 0) return showError('Ошибка', 'Некорректное число');

          showModal({
            title: 'Подтверждение',
            content: `Удалить всех друзей с талантами меньше ${threshold}?`,
            buttons: [
              { label: 'Нет', action: () => {} },
              { label: 'Да', danger: true, action: async () => {
                  const toDelete = friends.filter(f => (window.talentsCache[f.id] ?? 0) < threshold);
                  if (!toDelete.length) return showSuccess('Готово', 'Нет друзей для удаления');

                  const progress = showProgressModal(toDelete.length, 'Удаление друзей...');
                  let success = 0, fail = 0;
                  window.cancelRequest = false;

                  for (let i = 0; i < toDelete.length; i++) {
                    if (window.cancelRequest) break;
                    try {
                      await removeFriend(toDelete[i].id);
                      success++;
                      friends = friends.filter(f => f.id !== toDelete[i].id);
                      count.textContent = friends.length;
                      render();
                      friendsCache.friends = friends;
                    } catch { fail++; }
                    updateProgress(i + 1, toDelete.length, success, fail);
                    await new Promise(r => setTimeout(r, 350));
                  }
                  completeProgress('Удаление', success, fail, toDelete.length);
                }}
            ]
          });
        };

        return;
      }

      // НОВАЯ ЗАГРУЗКА (если кэша нет)
      const modal = document.createElement('div');
      modal.id = 'friends-modal';
      modal.className = 'prison-interface';
      modal.style.cssText = `
    position: fixed !important;
    width: 94vw !important;
    height: 88vh !important;
    max-width: 1150px !important;
    max-height: 840px !important;
    z-index: ${++highestZIndex} !important;
    border-radius: 24px !important;
    overflow: hidden !important;
    background: #0f172a;
    box-shadow: 0 30px 80px rgba(0,0,0,0.8) !important;
  `;

      modal.innerHTML = `
    <div class="interface-header" style="padding:18px 24px;cursor:move;background:#1e293b;user-select:none;display:flex;justify-content:space-between;align-items:center;">
      <div class="header-title" style="display:flex;align-items:center;gap:12px;">
        <svg width="28" height="28" viewBox="0 0 24 24" fill="#8b5cf6">
          <path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.83 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/>
        </svg>
        <h3 style="margin:0;color:#e2e8f0;font-size:20px;">Друзья (<span id="fcnt">0</span>)</h3>
      </div>
      <div class="header-controls" style="display:flex;gap:8px;">
        <button class="ctrl-btn minimize" title="Свернуть" style="font-size:20px;color:#94a3b8;background:none;border:none;cursor:pointer;">−</button>
        <button class="ctrl-btn close" title="Закрыть" style="font-size:26px;color:#94a3b8;background:none;border:none;cursor:pointer;opacity:0.4;pointer-events:none;">×</button>
      </div>
    </div>

    <div id="friends-body" style="height:calc(100% - 68px);display:flex;flex-direction:column;">
      <div style="padding:16px 20px 12px;background:#1e293b;display:flex;gap:16px;flex-wrap:wrap;align-items:center;">
        <input id="fsearch" type="text" placeholder="Поиск по нику или ID..." style="flex:1;max-width:230px;min-width:200px;padding:12px 16px;border-radius:16px;background:#334155;border:1px solid #475569;color:white;font-size:15px;">
        <select id="ftalent" style="padding:11px 16px;border-radius:14px;background:#334155;color:white;border:1px solid #475569;font-size:14.5px;">
          <option value="">Все таланты</option>
          <option value="100">до 100</option>
          <option value="300">до 300</option>
          <option value="500">до 500</option>
          <option value="700">700+</option>
        </select>
        <select id="fsort" style="padding:11px 16px;border-radius:14px;background:#334155;color:white;border:1px solid #475569;font-size:14.5px;">
          <option value="desc">Таланты: по убыванию</option>
          <option value="asc">Таланты: по возрастанию</option>
        </select>
        <div style="display:flex;align-items:center;gap:12px;white-space:nowrap;">
          <span style="color:#cbd5e1;font-size:16.5px;font-weight:700;">Игроки, с тал-ми меньше:</span>
          <input id="clean-threshold" type="number" min="1" placeholder="напр. 300" style="width:150px;padding:12px 16px;border-radius:16px;background:#334155;border:1px solid #475569;color:white;font-size:15px;">
          <button id="clean-confirm" style="padding:10px 22px;background:#94a3b8;color:#cbd5e1;border:none;border-radius:12px;font-size:14.5px;cursor:not-allowed;opacity:0.6;" disabled>Выбрать</button>
        </div>
      </div>

      <div style="flex:1;overflow:auto;background:#0f172a;">
        <table style="width:100%;border-collapse:collapse;font-size:14.8px;">
          <thead style="position:sticky;top:0;background:#1e293b;z-index:10;">
            <tr style="height:52px;">
              <th style="width:60px;text-align:center;color:#60a5fa;">#</th>
              <th style="text-align:left;padding-left:18px;color:#e2e8f0;">Ник</th>
              <th style="width:150px;text-align:center;color:#94a3b8;">ID</th>
              <th style="width:140px;text-align:center;color:#e2e8f0;">Таланты</th>
              <th style="width:130px;text-align:center;">Действие</th>
            </tr>
          </thead>
          <tbody id="ftbody" style="color:#e2e8f0;">
            <tr><td colspan="5" style="text-align:center;padding:140px;color:#64748b;font-size:17px;">Загружаем друзей...</td></tr>
          </tbody>
        </table>
      </div>

      <div style="padding:14px 20px;background:#1e293b;border-top:1px solid #334155;text-align:center;color:#94a3b8;font-size:14.5px;">
        <span id="fstatus">Инициализация...</span>
      </div>
    </div>
  `;

      document.body.appendChild(modal);

      const rect = modal.getBoundingClientRect();
      modal.style.left = Math.max(20, (window.innerWidth - rect.width) / 2 + window.scrollX) + 'px';
      modal.style.top = Math.max(20, (window.innerHeight - rect.height) / 2 + window.scrollY) + 'px';
      bringToFront(modal);
      makeInterfaceDraggable(modal);
      bringToFront(modal);

      const bodyEl = modal.querySelector('#friends-body');
      const minimizeBtn = modal.querySelector('.minimize');
      const closeBtn = modal.querySelector('.close');
      let minimized = false;

      minimizeBtn.onclick = () => {
        minimized = !minimized;
        bodyEl.style.display = minimized ? 'none' : 'flex';
        minimizeBtn.textContent = minimized ? '+' : '−';
        modal.style.height = minimized ? '68px' : '88vh';
        modal.style.maxHeight = minimized ? '68px' : '840px';
      };

      const tbody = modal.querySelector('#ftbody');
      const status = modal.querySelector('#fstatus');
      const count = modal.querySelector('#fcnt');
      const search = modal.querySelector('#fsearch');
      const talentFilter = modal.querySelector('#ftalent');
      const sortSelect = modal.querySelector('#fsort');
      const cleanBtn = modal.querySelector('#clean-confirm');

      if (!window.talentsCache) window.talentsCache = {};
      let friends = [];

      modal.addEventListener('click', async e => {
        const btn = e.target.closest('.action-btn.danger');
        if (!btn?.dataset.id) return;
        const userId = btn.dataset.id;
        btn.disabled = true;
        btn.textContent = 'Удаляем...';
        try {
          await removeFriend(userId);
          btn.closest('tr')?.remove();
          count.textContent = Number(count.textContent) - 1;
        } catch {
          btn.textContent = 'Ошибка';
          setTimeout(() => { btn.textContent = 'Удалить'; btn.disabled = false; }, 1500);
        }
      });

      async function loadFriends() {
        const token = getAuthToken();
        if (!token) {
          status.textContent = 'Нет токена';
          closeBtn.style.opacity = '1';
          closeBtn.style.pointerEvents = 'auto';
          closeBtn.onclick = () => modal.remove();
          return;
        }

        friends = [];
        let page = 0;

        while (true) {
          try {
            const r = await fetch(`https://oldprison-prod.luckygem.online/api/friendship/profiles?page=${page}&pageSize=100`, {
              headers: { authorization: token }
            });
            if (!r.ok) break;
            const data = await r.json();
            if (!data || data.length === 0) break;

            friends.push(...data.map(p => ({
              id: String(p.userId),
              nick: p.nickname?.trim() || `(ID ${p.userId})`
            })));

            count.textContent = friends.length;
            status.textContent = `Друзья: ${friends.length} (стр. ${page + 1})`;

            if (data.length < 100) break;
            page++;
            await new Promise(r => setTimeout(r, 120));
          } catch (e) {
            break;
          }
        }

        if (friends.length === 0) {
          status.textContent = 'Нет друзей';
          render();
          finishLoading();
          return;
        }

        status.textContent = `Загрузка талантов: 0/${friends.length}`;
        const BATCH_SIZE = 25;
        const DELAY_MS = 1100;

        for (let i = 0; i < friends.length; i += BATCH_SIZE) {
          const batch = friends.slice(i, i + BATCH_SIZE);
          await Promise.allSettled(batch.map(f => fetchTalentPoints(f.id)));
          render();
          const loaded = Math.min(i + BATCH_SIZE, friends.length);
          status.textContent = `Таланты: ${loaded}/${friends.length}`;
          if (i + BATCH_SIZE < friends.length) {
            await new Promise(r => setTimeout(r, DELAY_MS));
          }
        }

        finishLoading();
      }

      function finishLoading() {
        status.textContent = `ГОТОВО! ${friends.length} друзей загружено`;
        render();

        // Разблокируем крестик
        closeBtn.style.opacity = '1';
        closeBtn.style.pointerEvents = 'auto';
        closeBtn.onclick = () => modal.remove();

        // Включаем кнопку чистки
        cleanBtn.disabled = false;
        cleanBtn.style.background = '#ef4444';
        cleanBtn.style.color = 'white';
        cleanBtn.style.cursor = 'pointer';
        cleanBtn.style.opacity = '1';

        // Сохраняем кэш
        friendsCache = {
          friends: JSON.parse(JSON.stringify(friends)),
          talents: { ...window.talentsCache },
          timestamp: Date.now()
        };

        // Уведомление через 5 минут
        if (friendsCacheTimer) clearTimeout(friendsCacheTimer);
        friendsCacheTimer = setTimeout(() => {
          friendsCache = null;
          showModal({
            title: 'Кэш друзей истёк',
            content: 'Список друзей будет храниться в кэше 5 мин.<br><br>При следующем открытии таблицы — загрузка начнётся заново!',
            buttons: [{ label: 'Ок', action: () => {} }]
          });
        }, 1500);
      }

      function render() {
        const q = search.value.trim().toLowerCase();
        const filter = talentFilter.value;
        let list = friends.filter(f => {
          if (q && !f.nick.toLowerCase().includes(q) && !f.id.includes(q)) return false;
          const t = window.talentsCache[f.id] ?? 0;
          if (filter === '700') return t >= 700;
          if (filter === '500') return t <= 500;
          if (filter === '300') return t <= 300;
          if (filter === '100') return t <= 100;
          return true;
        });
        list.sort((a, b) => (sortSelect.value === 'desc'
            ? (window.talentsCache[b.id] ?? 0) - (window.talentsCache[a.id] ?? 0)
            : (window.talentsCache[a.id] ?? 0) - (window.talentsCache[b.id] ?? 0)
        ));
        tbody.innerHTML = list.length === 0
          ? `<tr><td colspan="5" style="text-align:center;padding:120px;color:#64748b;">Ничего не найдено</td></tr>`
          : list.map((f, i) => {
            const t = window.talentsCache[f.id] ?? 0;
            const col = t >= 700 ? '#f59e0b' : t >= 400 ? '#8b5cf6' : t >= 200 ? '#60a5fa' : '#94a3b8';
            return `<tr style="height:58px;">
            <td style="text-align:center;color:#60a5fa;font-weight:600;">${i + 1}</td>
            <td style="padding-left:18px;overflow:hidden;text-overflow:ellipsis;max-width:260px;white-space:nowrap;">${f.nick}</td>
            <td style="text-align:center;font-family:monospace;color:#94a3b8;">${f.id}</td>
            <td style="text-align:center;color:${col};font-weight:700;">${t.toLocaleString()}</td>
            <td style="text-align:center;">
              <button class="action-btn danger small" data-id="${f.id}" style="padding:8px 14px;font-size:13px;">Удалить</button>
            </td>
          </tr>`;
          }).join('');
      }

      search.oninput = talentFilter.onchange = sortSelect.onchange = render;

      const cleanInput = modal.querySelector('#clean-threshold');
      cleanBtn.onclick = async () => {
        const threshold = parseInt(cleanInput.value, 10);
        if (isNaN(threshold) || threshold <= 0) return showError('Ошибка', 'Некорректное число');

        showModal({
          title: 'Подтверждение',
          content: `Удалить всех друзей с талантами меньше ${threshold}?`,
          buttons: [
            { label: 'Нет', action: () => {} },
            { label: 'Да', danger: true, action: async () => {
                const toDelete = friends.filter(f => (window.talentsCache[f.id] ?? 0) < threshold);
                if (!toDelete.length) return showSuccess('Готово', 'Нет друзей для удаления');

                const progress = showProgressModal(toDelete.length, 'Удаление друзей...');
                let success = 0, fail = 0;
                window.cancelRequest = false;

                for (let i = 0; i < toDelete.length; i++) {
                  if (window.cancelRequest) break;
                  try {
                    await removeFriend(toDelete[i].id);
                    success++;
                    friends = friends.filter(f => f.id !== toDelete[i].id);
                    count.textContent = friends.length;
                    render();
                  } catch { fail++; }
                  updateProgress(i + 1, toDelete.length, success, fail);
                  await new Promise(r => setTimeout(r, 350));
                }
                completeProgress('Удаление', success, fail, toDelete.length);
              }}
          ]
        });
      };

      loadFriends();
    }

  /** Init **/
    function init() {
      setTimeout(() => {
        const btn = document.getElementById('friends-plus-btn');
        if (btn) {
          btn.classList.add('pulse');
          setTimeout(() => btn.classList.remove('pulse'), 6000);
        }
      }, 1500);
      setTimeout(mainButton, 1000);
      setTimeout(mainButton, 3000);
    }

    init();
  })();
